--- a/gui/simple-greeter/gdm-user-manager.c	2010-04-27 01:08:42.000000000 +0800
+++ b/gui/simple-greeter/gdm-user-manager.c.new	2010-11-24 15:34:49.529000059 +0800
@@ -78,6 +78,8 @@
 #define DEFAULT_GLOBAL_FACE_DIR DATADIR "/faces"
 #define DEFAULT_USER_ICON       "stock_person"
 
+#define LOGIN_CACHE_FILE CACHEDIR "/login_frequency.cache"
+
 struct GdmUserManagerPrivate
 {
         GHashTable            *users;
@@ -98,6 +100,8 @@
         guint                  ck_history_id;
 
         guint8                 users_dirty : 1;
+	guint8                 loaded_cache : 1;
+	guint8                 loading_users : 1;
 };
 
 enum {
@@ -1218,6 +1222,7 @@
         gboolean res;
         char    *username;
         gulong   frequency;
+	struct passwd *pwent;
         GdmUser *user;
 
         frequency = 0;
@@ -1233,6 +1238,18 @@
                 return;
         }
 
+	/* do not show system users; we cannot use gdm_user_manager_get_user()
+         * here since this creates/signals users as a side effect */
+        pwent = getpwnam (username);
+        if (pwent == NULL) {
+                g_warning ("Unable to lookup user name %s: %s", username, g_strerror (errno));
+	        return;
+        }
+        if (pwent->pw_uid < DEFAULT_MINIMAL_UID) {
+                g_debug ("GdmUserManager: excluding user '%s'", username);
+                return;
+        }
+
         user = gdm_user_manager_get_user (manager, username);
         if (user == NULL) {
                 g_debug ("GdmUserManager: unable to lookup user '%s'", username);
@@ -1279,7 +1296,31 @@
         }
 
         if (done) {
-                g_signal_emit (G_OBJECT (manager), signals[USERS_LOADED], 0);
+                //g_signal_emit (G_OBJECT (manager), signals[USERS_LOADED], 0);
+		                FILE *fp;
+		
+		                /* Cache login counts */
+		                fp = fopen (LOGIN_CACHE_FILE, "w");
+		                if (fp != NULL) {
+		                        GHashTableIter iter;
+		                        gpointer value;
+		
+		                        g_hash_table_iter_init (&iter, manager->priv->users);
+		                        while (g_hash_table_iter_next (&iter, NULL, &value)) {
+		                                GdmUser *user = (GdmUser *) value;
+		                                fprintf (fp, "%s %lu\n",
+		                                         gdm_user_get_user_name (user),
+		                                         gdm_user_get_login_frequency (user));
+		                        }
+		                        fclose (fp);
+		                }
+		                else
+		                        g_warning ("Unable to write to login cache file: %s", LOGIN_CACHE_FILE);
+		
+		                if (manager->priv->loading_users) {
+		                        g_signal_emit (G_OBJECT (manager), signals[USERS_LOADED], 0);
+		                        manager->priv->loading_users = FALSE;
+		                }
 
                 manager->priv->ck_history_id = 0;
                 return FALSE;
@@ -1517,9 +1558,38 @@
         g_slist_free (old_users);
 }
 
+ static void
+ load_login_frequency_cache (GdmUserManager *manager)
+ {
+         GIOChannel *channel;
+         gchar *line;
+ 
+         channel = g_io_channel_new_file (LOGIN_CACHE_FILE, "r", NULL);
+         if (channel == NULL)
+                 return;
+ 
+         while (g_io_channel_read_line (channel, &line, NULL, NULL, NULL) == G_IO_STATUS_NORMAL) {
+                 process_ck_history_line (manager, line);
+                 g_free (line);
+         }
+     
+         g_io_channel_close (channel);
+     
+         if (manager->priv->loading_users) {
+                 g_signal_emit (G_OBJECT (manager), signals[USERS_LOADED], 0);
+                 manager->priv->loading_users = FALSE;
+         }    
+ }
+
+
 static void
 reload_users (GdmUserManager *manager)
 {
+	        if (!manager->priv->loaded_cache) {
+	                load_login_frequency_cache (manager);
+	                manager->priv->loaded_cache = TRUE;
+	        }
+
         reload_ck_history (manager);
         reload_passwd (manager);
 }
@@ -1541,6 +1611,7 @@
         }
 
         g_signal_emit (G_OBJECT (manager), signals[LOADING_USERS], 0);
+	manager->priv->loading_users = TRUE;
         manager->priv->reload_id = g_idle_add ((GSourceFunc)reload_users_timeout, manager);
 }
 
