Index: gdm-2.30.4/common/gdm-settings.c
===================================================================
--- gdm-2.30.4.orig/common/gdm-settings.c	2010-06-30 12:35:02.000000000 +0200
+++ gdm-2.30.4/common/gdm-settings.c	2010-06-30 12:35:06.000000000 +0200
@@ -28,6 +28,7 @@
 #include <signal.h>
 #include <sys/stat.h>
 #include <sys/types.h>
+#include <pwd.h>
 
 #include <glib.h>
 #include <glib/gi18n.h>
@@ -49,6 +50,9 @@
 #define GDM_SETTINGS_DBUS_PATH GDM_DBUS_PATH "/Settings"
 #define GDM_SETTINGS_DBUS_NAME "org.gnome.DisplayManager.Settings"
 
+#define GCONF_SOUND_EVENT_KEY "/desktop/gnome/sound/event_sounds"
+#define GCONF_FACE_BROWSER_DISABLE_KEY "/apps/gdm/simple-greeter/disable_user_list"
+
 #define GDM_SETTINGS_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), GDM_TYPE_SETTINGS, GdmSettingsPrivate))
 
 struct GdmSettingsPrivate
@@ -83,6 +87,190 @@
         return ret;
 }
 
+static void
+set_gdm_uid_child_setup ()
+{
+        struct passwd *pwent;
+        uid_t  gdm_uid;
+        uid_t  gdm_gid;
+
+        pwent = getpwnam (GDM_USERNAME);
+        // --shutdown take into account the resuid/resgid and HOME whereas
+        // --get --set take the euid/egid
+        setenv("HOME", pwent->pw_dir, 1);
+        gdm_uid = pwent->pw_uid;
+        gdm_gid = pwent->pw_gid;
+        setresgid (gdm_gid, gdm_gid, gdm_gid);
+        setresuid (gdm_uid, gdm_uid, gdm_uid);
+
+}
+
+static gboolean
+gdm_settings_get_gconf_value (gchar *gconf_key, gchar **value) {
+
+        GError  *error = NULL;
+        char    *shutdown_command[] = { "gconftool-2", "--shutdown", NULL };
+        char    *get_command[]  =  { "gconftool-2", "--direct", "-g", gconf_key, "--config-source", NULL, NULL };
+        gboolean res;
+        struct passwd *pwent;
+        gboolean success = FALSE;
+
+        pwent = getpwnam (GDM_USERNAME);
+        if G_UNLIKELY (pwent == NULL)
+                g_warning ("Can't access to 'gdm' user name in passwd");
+        else {
+                get_command[5] = g_strdup_printf("xml:readwrite:%s/.gconf", pwent->pw_dir);
+                res = g_spawn_sync (NULL,
+                                    shutdown_command,
+                                    NULL,
+                                    G_SPAWN_SEARCH_PATH,
+                                    (GSpawnChildSetupFunc)set_gdm_uid_child_setup,
+                                    NULL,
+                                    NULL,
+                                    NULL,
+                                    NULL,
+                                    &error);
+                if (!res) {
+                        if (error != NULL) {
+                                g_warning ("Unable to shutdown gconf: %s", error->message);
+                                g_error_free (error);
+                        }
+                        else
+                                g_warning ("Unable to shutdown gconf: unknown error");
+                }
+                else {
+                        res = g_spawn_sync (NULL,
+                                            get_command,
+                                            NULL,
+                                            G_SPAWN_SEARCH_PATH | G_SPAWN_STDERR_TO_DEV_NULL,
+                                            (GSpawnChildSetupFunc)set_gdm_uid_child_setup,
+                                            NULL,
+                                            value,
+                                            NULL,
+                                            NULL,
+                                            &error);
+                        if (!res) {
+                                 if (error != NULL) {
+                                         g_warning ("Unable to get event key to gconf: %s", error->message);
+                                         g_error_free (error);
+                                 }
+                                else
+                                         g_warning ("Unable to get event key to gconf: unknown error");
+                         }
+                        else {
+                                 if (error != NULL) {
+                                         g_warning ("Unable to get event key to gconf: %s", error->message);
+                                         g_error_free (error);
+                                 }
+                                 else {
+                                         g_debug ("gconftool call returning: %s", *value);
+                                         success = TRUE;
+                                 }
+                        }
+                }
+        }
+
+        return success;
+}
+
+
+
+static gboolean
+gdm_settings_get_bool_gconf_value (gchar *gconf_key, gboolean *enabled) {
+
+        gchar *value = NULL;
+        gboolean result = FALSE;
+
+        if (gdm_settings_get_gconf_value(gconf_key, &value)) {
+                result = TRUE;
+                if (strstr(value, "false") != NULL)
+                        *enabled = FALSE;
+                else if (strstr(value, "true") != NULL)
+                        *enabled = TRUE;
+                else
+                    result = FALSE;
+        }
+
+        if (value)
+                g_free (value);
+        return result;
+
+}
+
+static gboolean
+gdm_settings_set_gconf_value (gchar *gconf_key, gchar *type, gchar *value) {
+
+        GError  *error = NULL;
+        char    *shutdown_command[] = { "gconftool-2", "--shutdown", NULL };
+        char    *set_command[]  =  { "gconftool-2", "--direct", "-s", gconf_key, "--config-source", NULL, "-t", type, value, NULL };
+        gboolean res;
+        struct passwd *pwent;
+        gboolean success = FALSE;
+
+        pwent = getpwnam (GDM_USERNAME);
+        if G_UNLIKELY (pwent == NULL)
+                g_warning ("Can't access to 'gdm' user name in passwd");
+        else {
+                set_command[5] = g_strdup_printf("xml:readwrite:%s/.gconf", pwent->pw_dir);
+                res = g_spawn_sync (NULL,
+                                    shutdown_command,
+                                    NULL,
+                                    G_SPAWN_SEARCH_PATH,
+                                    (GSpawnChildSetupFunc)set_gdm_uid_child_setup,
+                                    NULL,
+                                    NULL,
+                                    NULL,
+                                    NULL,
+                                    &error);
+                if (!res) {
+                        if (error != NULL) {
+                                g_warning ("Unable to shutdown gconf: %s", error->message);
+                                g_error_free (error);
+                        }
+                        else
+                                g_warning ("Unable to shutdown gconf: unknown error");
+                }
+                else {
+                        res = g_spawn_async (NULL,
+                                             set_command,
+                                             NULL,
+                                             G_SPAWN_SEARCH_PATH
+                                             | G_SPAWN_STDOUT_TO_DEV_NULL
+                                             | G_SPAWN_STDERR_TO_DEV_NULL,
+                                             (GSpawnChildSetupFunc)set_gdm_uid_child_setup,
+                                             NULL,
+                                             NULL,
+                                             &error);
+                        if (!res) {
+                                if (error != NULL) {
+                                        g_warning ("Unable to set event key to gconf: %s", error->message);
+                                        g_error_free (error);
+                                 }
+                                 else
+                                        g_warning ("Unable to set event key to gconf: unknown error");
+                        }
+                        else
+                                 success = TRUE;
+                }
+        }
+
+        return success;
+}
+
+static gboolean
+gdm_settings_set_bool_gconf_value (gchar *gconf_key, gboolean enabled) {
+
+        gchar *value = g_strdup_printf ("%i", enabled);
+        gboolean result;
+
+        result = gdm_settings_set_gconf_value (gconf_key, "bool", value);
+
+        if (value)
+                g_free (value);
+        return result;
+}
+
+
 /*
 dbus-send --system --print-reply --dest=org.gnome.DisplayManager /org/gnome/DisplayManager/Settings org.gnome.DisplayManager.Settings.GetValue string:"xdmcp/Enable"
 */
@@ -111,6 +299,51 @@
         return res;
 }
 
+
+/*
+dbus-send --system --print-reply --dest=org.gnome.DisplayManager /org/gnome/DisplayManager/Settings org.gnome.DisplayManager.Settings.GetSoundEnabled
+*/
+
+gboolean
+gdm_settings_get_sound_enabled (GdmSettings *settings,
+                                gboolean    *enabled,
+                                GError     **error)
+{
+        gboolean res;
+        g_debug ("Trying to get sound");
+
+        g_return_val_if_fail (GDM_IS_SETTINGS (settings), FALSE);
+
+        *enabled = FALSE;
+        res = gdm_settings_get_bool_gconf_value (GCONF_SOUND_EVENT_KEY, enabled);
+        if (res)
+                  g_debug ("get sound returned: %i", *enabled);
+
+        return TRUE;
+}
+
+
+/*
+dbus-send --system --print-reply --dest=org.gnome.DisplayManager /org/gnome/DisplayManager/Settings org.gnome.DisplayManager.Settings.GetFaceBrowserEnabled
+*/
+
+gboolean
+gdm_settings_get_face_browser_enabled (GdmSettings *settings,
+                                       gboolean    *enabled,
+                                       GError     **error)
+{
+        gboolean res;
+
+        g_return_val_if_fail (GDM_IS_SETTINGS (settings), FALSE);
+
+        *enabled = TRUE;  
+        res = gdm_settings_get_bool_gconf_value (GCONF_FACE_BROWSER_DISABLE_KEY, enabled);
+        if (res)
+            *enabled = !*enabled;
+
+        return TRUE;
+}
+
 static void
 unlock_auth_cb (PolkitAuthority *authority,
                 GAsyncResult *result,
@@ -155,6 +388,12 @@
         gchar *key, *value;
 } SetValueData;
 
+typedef struct
+{
+        DBusGMethodInvocation *context;
+        gboolean enabled;
+} SetGConfBooleanData;
+
 static void
 set_value_auth_cb (PolkitAuthority *authority,
                    GAsyncResult *result,
@@ -229,6 +468,129 @@
         return TRUE;
 }
 
+static void
+set_sound_enabled_auth_cb (PolkitAuthority *authority,
+                           GAsyncResult *result,
+                           SetGConfBooleanData *data)
+{
+        PolkitAuthorizationResult *auth_result;
+        GError  *error = NULL;
+        
+        auth_result = polkit_authority_check_authorization_finish (authority, result, &error);
+
+        if (!auth_result)
+                dbus_g_method_return_error (data->context, error);
+        else {
+                if (polkit_authorization_result_get_is_authorized (auth_result)) {
+                        if (!gdm_settings_set_bool_gconf_value (GCONF_SOUND_EVENT_KEY, data->enabled))
+                                g_warning ("set new value for sound failed");
+                        dbus_g_method_return (data->context);
+                }
+                else {
+                        error = g_error_new (DBUS_GERROR_REMOTE_EXCEPTION, 0, "Not authorized");
+                        dbus_g_method_return_error (data->context, error);
+                }
+        }
+    
+        if (auth_result)
+                g_object_unref (auth_result);
+        if (error)
+                g_error_free (error);
+
+        g_free (data);
+}
+
+/*
+dbus-send --system --print-reply --dest=org.gnome.DisplayManager /org/gnome/DisplayManager/Settings org.gnome.DisplayManager.Settings.SetSoundEnabled boolean:false
+*/
+
+gboolean
+gdm_settings_set_sound_enabled (GdmSettings *settings,
+                                gboolean     enabled,
+                                DBusGMethodInvocation *context)
+{
+        SetGConfBooleanData *data;
+    
+        g_return_val_if_fail (GDM_IS_SETTINGS (settings), FALSE);
+
+
+        g_debug ("Setting sound enabled to %s", enabled ? "true" : "false");
+    
+        /* Authorize with PolicyKit */
+        data = g_malloc (sizeof(SetGConfBooleanData));
+        data->context = context;
+        data->enabled = enabled;
+        polkit_authority_check_authorization (polkit_authority_get (),
+                                              polkit_system_bus_name_new (dbus_g_method_get_sender (context)),
+                                              "org.gnome.displaymanager.settings.write",
+                                              NULL,
+                                              POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION,
+                                              NULL,
+                                              (GAsyncReadyCallback) set_sound_enabled_auth_cb,
+                                              data);
+        return TRUE;
+}
+
+static void
+set_face_browser_enabled_auth_cb (PolkitAuthority *authority,
+                                  GAsyncResult *result,
+                                  SetGConfBooleanData *data)
+{
+        PolkitAuthorizationResult *auth_result;
+        GError  *error = NULL;
+        
+        auth_result = polkit_authority_check_authorization_finish (authority, result, &error);
+
+        if (!auth_result)
+                dbus_g_method_return_error (data->context, error);
+        else {
+                if (polkit_authorization_result_get_is_authorized (auth_result)) {
+                        if (!gdm_settings_set_bool_gconf_value (GCONF_FACE_BROWSER_DISABLE_KEY, !data->enabled))
+                                g_warning ("set new value for face browser failed");
+                        dbus_g_method_return (data->context);
+                }
+                else {
+                        error = g_error_new (DBUS_GERROR_REMOTE_EXCEPTION, 0, "Not authorized");
+                        dbus_g_method_return_error (data->context, error);
+                }
+        }
+    
+        if (auth_result)
+                g_object_unref (auth_result);
+        if (error)
+                g_error_free (error);
+
+        g_free (data);
+}
+
+/*
+dbus-send --system --print-reply --dest=org.gnome.DisplayManager /org/gnome/DisplayManager/Settings org.gnome.DisplayManager.Settings.SetFaceBrowserEnabled boolean:true
+*/
+
+gboolean
+gdm_settings_set_face_browser_enabled (GdmSettings *settings,
+                                       gboolean     enabled,
+                                       DBusGMethodInvocation *context)
+{
+        SetGConfBooleanData *data;
+    
+        g_return_val_if_fail (GDM_IS_SETTINGS (settings), FALSE);
+    
+        /* Authorize with PolicyKit */
+        data = g_malloc (sizeof(SetGConfBooleanData));
+        data->context = context;
+        data->enabled = enabled;
+        polkit_authority_check_authorization (polkit_authority_get (),
+                                              polkit_system_bus_name_new (dbus_g_method_get_sender (context)),
+                                              "org.gnome.displaymanager.settings.write",
+                                              NULL,
+                                              POLKIT_CHECK_AUTHORIZATION_FLAGS_ALLOW_USER_INTERACTION,
+                                              NULL,
+                                              (GAsyncReadyCallback) set_face_browser_enabled_auth_cb,
+                                              data);
+        return TRUE;
+}
+
 static gboolean
 register_settings (GdmSettings *settings)
 {
Index: gdm-2.30.4/common/gdm-settings.h
===================================================================
--- gdm-2.30.4.orig/common/gdm-settings.h	2010-06-30 12:35:02.000000000 +0200
+++ gdm-2.30.4/common/gdm-settings.h	2010-06-30 12:35:06.000000000 +0200
@@ -71,12 +71,24 @@
                                                                  const char  *key,
                                                                  char       **value,
                                                                  GError     **error);
+gboolean            gdm_settings_get_sound_enabled              (GdmSettings *settings,
+                                                                 gboolean    *value,
+                                                                 GError     **error);
+gboolean            gdm_settings_get_face_browser_enabled       (GdmSettings *settings,
+                                                                 gboolean    *value,
+                                                                 GError     **error);
 gboolean            gdm_settings_unlock                         (GdmSettings *settings,
                                                                  DBusGMethodInvocation *context);
 gboolean            gdm_settings_set_value                      (GdmSettings *settings,
                                                                  const char  *key,
                                                                  const char  *value,
                                                                  DBusGMethodInvocation *context);
+gboolean            gdm_settings_set_sound_enabled              (GdmSettings *settings,
+                                                                 gboolean     value,
+                                                                 DBusGMethodInvocation *context);
+gboolean            gdm_settings_set_face_browser_enabled       (GdmSettings *settings,
+                                                                 gboolean     value,
+                                                                 DBusGMethodInvocation *context);
 
 G_END_DECLS
 
Index: gdm-2.30.4/common/gdm-settings.xml
===================================================================
--- gdm-2.30.4.orig/common/gdm-settings.xml	2010-06-30 12:35:02.000000000 +0200
+++ gdm-2.30.4/common/gdm-settings.xml	2010-06-30 12:35:06.000000000 +0200
@@ -5,6 +5,12 @@
       <arg name="key" direction="in" type="s"/>
       <arg name="value" direction="out" type="s"/>
     </method>
+    <method name="GetSoundEnabled">
+      <arg name="enabled" direction="out" type="b"/>
+    </method>
+    <method name="GetFaceBrowserEnabled">
+      <arg name="enabled" direction="out" type="b"/>
+    </method>
     <method name="Unlock">
       <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
       <arg name="is_unlocked" direction="out" type="b"/>
@@ -14,6 +20,14 @@
       <arg name="key" direction="in" type="s"/>
       <arg name="value" direction="in" type="s"/>
     </method>
+    <method name="SetSoundEnabled">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="enabled" direction="in" type="b"/>
+    </method>
+    <method name="SetFaceBrowserEnabled">
+      <annotation name="org.freedesktop.DBus.GLib.Async" value=""/>
+      <arg name="enabled" direction="in" type="b"/>
+    </method>
     <signal name="ValueChanged">
       <arg name="key" type="s"/>
       <arg name="old_value" type="s"/>
