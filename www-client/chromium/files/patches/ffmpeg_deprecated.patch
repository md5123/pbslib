diff -aur chromium-14.0.795.0/media/filters/audio_file_reader.cc chromium-14.0.795.0.patched/media/filters/audio_file_reader.cc
--- chromium-14.0.795.0/media/filters/audio_file_reader.cc	2011-06-18 11:35:56.000000000 +0300
+++ chromium-14.0.795.0.patched/media/filters/audio_file_reader.cc	2011-06-20 00:49:48.528657480 +0300
@@ -71,7 +71,7 @@
   codec_context_ = NULL;
   for (size_t i = 0; i < format_context_->nb_streams; ++i) {
     AVCodecContext* c = format_context_->streams[i]->codec;
-    if (c->codec_type == CODEC_TYPE_AUDIO) {
+    if (c->codec_type == AVMEDIA_TYPE_AUDIO) {
       codec_context_ = c;
       break;
     }
diff -aur chromium-14.0.795.0/media/filters/bitstream_converter.cc chromium-14.0.795.0.patched/media/filters/bitstream_converter.cc
--- chromium-14.0.795.0/media/filters/bitstream_converter.cc	2011-06-18 11:35:56.000000000 +0300
+++ chromium-14.0.795.0.patched/media/filters/bitstream_converter.cc	2011-06-20 00:49:48.574650239 +0300
@@ -52,7 +52,7 @@
   if (av_bitstream_filter_filter(stream_filter_, stream_context_, NULL,
                                  &converted_data, &converted_size,
                                  packet->data, packet->size,
-                                 packet->flags & PKT_FLAG_KEY) < 0) {
+                                 packet->flags & AV_PKT_FLAG_KEY) < 0) {
     return false;
   }
 
diff -aur chromium-14.0.795.0/media/filters/ffmpeg_demuxer.cc chromium-14.0.795.0.patched/media/filters/ffmpeg_demuxer.cc
--- chromium-14.0.795.0/media/filters/ffmpeg_demuxer.cc	2011-06-18 11:35:56.000000000 +0300
+++ chromium-14.0.795.0.patched/media/filters/ffmpeg_demuxer.cc	2011-06-20 00:49:48.596646780 +0300
@@ -64,10 +64,10 @@
 
   // Determine our media format.
   switch (stream->codec->codec_type) {
-    case CODEC_TYPE_AUDIO:
+    case AVMEDIA_TYPE_AUDIO:
       type_ = AUDIO;
       break;
-    case CODEC_TYPE_VIDEO:
+    case AVMEDIA_TYPE_VIDEO:
       type_ = VIDEO;
       break;
     default:
@@ -378,7 +378,7 @@
   // If read has ever failed, return with an error.
   // TODO(hclam): use a more meaningful constant as error.
   if (read_has_failed_)
-    return AVERROR_IO;
+    return AVERROR(EIO);
 
   // Even though FFmpeg defines AVERROR_EOF, it's not to be used with I/O
   // routines.  Instead return 0 for any read at or past EOF.
@@ -402,7 +402,7 @@
 
     // Returns with a negative number to signal an error to FFmpeg.
     read_has_failed_ = true;
-    return AVERROR_IO;
+    return AVERROR(EIO);
   }
   read_position_ += last_read_bytes;
 
@@ -487,8 +487,8 @@
   bool no_supported_streams = true;
   for (size_t i = 0; i < format_context_->nb_streams; ++i) {
     AVCodecContext* codec_context = format_context_->streams[i]->codec;
-    CodecType codec_type = codec_context->codec_type;
-    if (codec_type == CODEC_TYPE_AUDIO || codec_type == CODEC_TYPE_VIDEO) {
+    AVMediaType codec_type = codec_context->codec_type;
+    if (codec_type == AVMEDIA_TYPE_AUDIO || codec_type == AVMEDIA_TYPE_VIDEO) {
       AVStream* stream = format_context_->streams[i];
       // WebM is currently strictly VP8 and Vorbis.
       if (kDemuxerIsWebm && (stream->codec->codec_id != CODEC_ID_VP8 &&
@@ -663,7 +663,7 @@
     // look for such reference, and this will result in deleting the
     // audio packets after they are demuxed.
     if (packet_streams_[i]->GetAVStream()->codec->codec_type ==
-        CODEC_TYPE_AUDIO) {
+        AVMEDIA_TYPE_AUDIO) {
       packet_streams_[i] = NULL;
     }
   }
diff -aur chromium-14.0.795.0/media/filters/ffmpeg_demuxer_unittest.cc chromium-14.0.795.0.patched/media/filters/ffmpeg_demuxer_unittest.cc
--- chromium-14.0.795.0/media/filters/ffmpeg_demuxer_unittest.cc	2011-06-18 11:35:56.000000000 +0300
+++ chromium-14.0.795.0.patched/media/filters/ffmpeg_demuxer_unittest.cc	2011-06-20 00:49:48.605645362 +0300
@@ -82,15 +82,15 @@
     memset(&codecs_, 0, sizeof(codecs_));
 
     // Initialize AVCodecContext structures.
-    codecs_[AV_STREAM_DATA].codec_type = CODEC_TYPE_DATA;
+    codecs_[AV_STREAM_DATA].codec_type = AVMDEDIA_TYPE_DATA;
     codecs_[AV_STREAM_DATA].codec_id = CODEC_ID_NONE;
 
-    codecs_[AV_STREAM_VIDEO].codec_type = CODEC_TYPE_VIDEO;
+    codecs_[AV_STREAM_VIDEO].codec_type = AVMEDIA_TYPE_VIDEO;
     codecs_[AV_STREAM_VIDEO].codec_id = CODEC_ID_THEORA;
     codecs_[AV_STREAM_VIDEO].width = kWidth;
     codecs_[AV_STREAM_VIDEO].height = kHeight;
 
-    codecs_[AV_STREAM_AUDIO].codec_type = CODEC_TYPE_AUDIO;
+    codecs_[AV_STREAM_AUDIO].codec_type = AVMEDIA_TYPE_AUDIO;
     codecs_[AV_STREAM_AUDIO].codec_id = CODEC_ID_VORBIS;
     codecs_[AV_STREAM_AUDIO].channels = kChannels;
     codecs_[AV_STREAM_AUDIO].sample_rate = kSampleRate;
@@ -190,7 +190,7 @@
   EXPECT_CALL(mock_ffmpeg_, AVOpenInputFile(_, _, NULL, 0, NULL))
       .WillOnce(DoAll(SetArgumentPointee<0>(&format_context_), Return(0)));
   EXPECT_CALL(mock_ffmpeg_, AVFindStreamInfo(&format_context_))
-      .WillOnce(Return(AVERROR_IO));
+      .WillOnce(Return(AVERROR(EIO)));
   EXPECT_CALL(mock_ffmpeg_, AVCloseInputFile(&format_context_));
 
   demuxer_->Initialize(
@@ -266,7 +266,7 @@
   EXPECT_CALL(mock_ffmpeg_, AVReadFrame(&format_context_, _))
       .WillOnce(CreatePacketNoCount(AV_STREAM_DATA, kNullData, 0));
   EXPECT_CALL(mock_ffmpeg_, AVReadFrame(&format_context_, _))
-      .WillOnce(Return(AVERROR_IO));
+      .WillOnce(Return(AVERROR(EIO)));
 
   // Attempt a read from the audio stream and run the message loop until done.
   scoped_refptr<DemuxerStream> audio =
@@ -474,7 +474,7 @@
   EXPECT_CALL(mock_ffmpeg_, AVFreePacket(_)).Times(AnyNumber());
 
   EXPECT_CALL(mock_ffmpeg_, AVReadFrame(&format_context_, _))
-      .WillOnce(Return(AVERROR_IO));
+      .WillOnce(Return(AVERROR(EIO)));
 
   // We should now expect an end of stream buffer.
   scoped_refptr<DemuxerStream> audio =
@@ -717,7 +717,7 @@
 
   // Then an end-of-stream packet is read.
   EXPECT_CALL(mock_ffmpeg_, AVReadFrame(&format_context_, _))
-      .WillOnce(Return(AVERROR_IO));
+      .WillOnce(Return(AVERROR(EIO)));
 
   // Get our streams.
   scoped_refptr<DemuxerStream> video =
diff -aur chromium-14.0.795.0/media/filters/ffmpeg_glue.cc chromium-14.0.795.0.patched/media/filters/ffmpeg_glue.cc
--- chromium-14.0.795.0/media/filters/ffmpeg_glue.cc	2011-06-18 11:35:56.000000000 +0300
+++ chromium-14.0.795.0.patched/media/filters/ffmpeg_glue.cc	2011-06-20 00:49:48.607645048 +0300
@@ -20,7 +20,7 @@
   FFmpegURLProtocol* protocol;
   FFmpegGlue::GetInstance()->GetProtocol(filename, &protocol);
   if (!protocol)
-    return AVERROR_IO;
+    return AVERROR(EIO);
 
   h->priv_data = protocol;
   h->flags = URL_RDONLY;
@@ -32,7 +32,7 @@
   FFmpegURLProtocol* protocol = ToProtocol(h->priv_data);
   int result = protocol->Read(size, buf);
   if (result < 0)
-    result = AVERROR_IO;
+    result = AVERROR(EIO);
   return result;
 }
 
@@ -42,12 +42,12 @@
 static int WriteContext(URLContext* h, unsigned char* buf, int size) {
 #endif
   // We don't support writing.
-  return AVERROR_IO;
+  return AVERROR(EIO);
 }
 
 static int64 SeekContext(URLContext* h, int64 offset, int whence) {
   FFmpegURLProtocol* protocol = ToProtocol(h->priv_data);
-  int64 new_offset = AVERROR_IO;
+  int64 new_offset = AVERROR(EIO);
   switch (whence) {
     case SEEK_SET:
       if (protocol->SetPosition(offset))
@@ -78,7 +78,7 @@
       NOTREACHED();
   }
   if (new_offset < 0)
-    new_offset = AVERROR_IO;
+    new_offset = AVERROR(EIO);
   return new_offset;
 }
 
diff -aur chromium-14.0.795.0/media/filters/ffmpeg_glue_unittest.cc chromium-14.0.795.0.patched/media/filters/ffmpeg_glue_unittest.cc
--- chromium-14.0.795.0/media/filters/ffmpeg_glue_unittest.cc	2011-06-18 11:35:56.000000000 +0300
+++ chromium-14.0.795.0.patched/media/filters/ffmpeg_glue_unittest.cc	2011-06-20 00:49:48.610644577 +0300
@@ -150,7 +150,7 @@
   memset(&context, 0, sizeof(context));
 
   // Test opening a URLContext with a protocol that doesn't exist.
-  EXPECT_EQ(AVERROR_IO, protocol_->url_open(&context, "foobar", 0));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_open(&context, "foobar", 0));
 
   // Test opening a URLContext with our protocol.
   EXPECT_EQ(0, protocol_->url_open(&context, key.c_str(), 0));
@@ -190,9 +190,9 @@
   uint8 buffer[kBufferSize];
 
   // Writing should always fail and never call the protocol.
-  EXPECT_EQ(AVERROR_IO, protocol_->url_write(&context, NULL, 0));
-  EXPECT_EQ(AVERROR_IO, protocol_->url_write(&context, buffer, 0));
-  EXPECT_EQ(AVERROR_IO, protocol_->url_write(&context, buffer, kBufferSize));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_write(&context, NULL, 0));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_write(&context, buffer, 0));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_write(&context, buffer, kBufferSize));
 
   // Destroy the protocol.
   protocol_->url_close(&context);
@@ -218,7 +218,7 @@
 
   EXPECT_EQ(0, protocol_->url_read(&context, buffer, 0));
   EXPECT_EQ(kBufferSize, protocol_->url_read(&context, buffer, kBufferSize));
-  EXPECT_EQ(AVERROR_IO, protocol_->url_read(&context, buffer, kBufferSize));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_read(&context, buffer, kBufferSize));
 
   // Destroy the protocol.
   protocol_->url_close(&context);
@@ -241,7 +241,7 @@
   EXPECT_CALL(*protocol, GetPosition(_))
       .WillOnce(DoAll(SetArgumentPointee<0>(8), Return(true)));
 
-  EXPECT_EQ(AVERROR_IO, protocol_->url_seek(&context, -16, SEEK_SET));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_seek(&context, -16, SEEK_SET));
   EXPECT_EQ(8, protocol_->url_seek(&context, 16, SEEK_SET));
 
   // SEEK_CUR should call GetPosition() first, and if it succeeds add the offset
@@ -261,8 +261,8 @@
   EXPECT_CALL(*protocol, GetPosition(_))
       .WillOnce(DoAll(SetArgumentPointee<0>(16), Return(true)));
 
-  EXPECT_EQ(AVERROR_IO, protocol_->url_seek(&context, 8, SEEK_CUR));
-  EXPECT_EQ(AVERROR_IO, protocol_->url_seek(&context, 8, SEEK_CUR));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_seek(&context, 8, SEEK_CUR));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_seek(&context, 8, SEEK_CUR));
   EXPECT_EQ(16, protocol_->url_seek(&context, 8, SEEK_CUR));
 
   // SEEK_END should call GetSize() first, and if it succeeds add the offset
@@ -282,8 +282,8 @@
   EXPECT_CALL(*protocol, GetPosition(_))
       .WillOnce(DoAll(SetArgumentPointee<0>(8), Return(true)));
 
-  EXPECT_EQ(AVERROR_IO, protocol_->url_seek(&context, -8, SEEK_END));
-  EXPECT_EQ(AVERROR_IO, protocol_->url_seek(&context, -8, SEEK_END));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_seek(&context, -8, SEEK_END));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_seek(&context, -8, SEEK_END));
   EXPECT_EQ(8, protocol_->url_seek(&context, -8, SEEK_END));
 
   // AVSEEK_SIZE should be a straight-through call to GetSize().
@@ -293,7 +293,7 @@
   EXPECT_CALL(*protocol, GetSize(_))
       .WillOnce(DoAll(SetArgumentPointee<0>(16), Return(true)));
 
-  EXPECT_EQ(AVERROR_IO, protocol_->url_seek(&context, 0, AVSEEK_SIZE));
+  EXPECT_EQ(AVERROR(EIO), protocol_->url_seek(&context, 0, AVSEEK_SIZE));
   EXPECT_EQ(16, protocol_->url_seek(&context, 0, AVSEEK_SIZE));
 
   // Destroy the protocol.


--- chromium-14.0.795.0/third_party/ffmpeg/avutil-50.sigs	2011-06-18 11:38:40.000000000 +0300
+++ chromium-14.0.795.0.patched/third_party/ffmpeg/avutil-50.sigs	2011-06-19 23:45:46.146666226 +0300
@@ -5,6 +5,6 @@
 # Functions from avutil used in chromium code.
 
 int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq);
-void *av_malloc(unsigned int size);
+void *av_malloc(size_t size);
 void av_free(void *ptr);
 void av_log_set_level(int level);

