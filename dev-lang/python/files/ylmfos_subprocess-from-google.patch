diff -ur python-2.6.7-ylmf1/Lib/subprocess.py python-2.6.7-ylmf1.new//Lib/subprocess.py
--- python-2.6.7-ylmf1/Lib/subprocess.py	2010-07-19 22:49:38.000000000 +0800
+++ python-2.6.7-ylmf1.new//Lib/subprocess.py	2012-03-20 13:37:16.683157580 +0800
@@ -2,8 +2,6 @@
 #
 # For more information about this module, see PEP 324.
 #
-# This module should remain compatible with Python 2.2, see PEP 291.
-#
 # Copyright (c) 2003-2005 by Peter Astrand <astrand@lysator.liu.se>
 #
 # Licensed to PSF under a Contributor Agreement.
@@ -17,9 +15,6 @@
 
 os.system
 os.spawn*
-os.popen*
-popen2.*
-commands.*
 
 Information about how the subprocess module can be used to replace these
 modules and functions can be found below.
@@ -107,7 +102,7 @@
 (Windows only)
 
 
-This module also defines two shortcut functions:
+This module also defines some shortcut functions:
 
 call(*popenargs, **kwargs):
     Run command with arguments.  Wait for command to complete, then
@@ -127,6 +122,45 @@
 
     check_call(["ls", "-l"])
 
+getstatusoutput(cmd):
+    Return (status, output) of executing cmd in a shell.
+
+    Execute the string 'cmd' in a shell with os.popen() and return a 2-tuple
+    (status, output).  cmd is actually run as '{ cmd ; } 2>&1', so that the
+    returned output will contain output or error messages. A trailing newline
+    is stripped from the output. The exit status for the command can be
+    interpreted according to the rules for the C function wait().  Example:
+
+    >>> import subprocess
+    >>> subprocess.getstatusoutput('ls /bin/ls')
+    (0, '/bin/ls')
+    >>> subprocess.getstatusoutput('cat /bin/junk')
+    (256, 'cat: /bin/junk: No such file or directory')
+    >>> subprocess.getstatusoutput('/bin/junk')
+    (256, 'sh: /bin/junk: not found')
+
+getoutput(cmd):
+    Return output (stdout or stderr) of executing cmd in a shell.
+
+    Like getstatusoutput(), except the exit status is ignored and the return
+    value is a string containing the command's output.  Example:
+
+    >>> import subprocess
+    >>> subprocess.getoutput('ls /bin/ls')
+    '/bin/ls'
+
+check_output(*popenargs, **kwargs):
+   Run command with arguments and return its output as a byte string.
+
+   If the exit code was non-zero it raises a CalledProcessError.  The
+   CalledProcessError object will have the return code in the returncode
+   attribute and output in the output attribute.
+
+   The arguments are the same as for the Popen constructor.  Example:
+
+      output = subprocess.check_output(["ls", "-l", "/dev/null"])
+
+
 Exceptions
 ----------
 Exceptions raised in the child process, before the new program has
@@ -141,8 +175,8 @@
 
 A ValueError will be raised if Popen is called with invalid arguments.
 
-check_call() will raise CalledProcessError, if the called process
-returns a non-zero return code.
+check_call() and check_output() will raise CalledProcessError, if the
+called process returns a non-zero return code.
 
 
 Security
@@ -248,11 +282,11 @@
 try:
     retcode = call("mycmd" + " myarg", shell=True)
     if retcode < 0:
-        print >>sys.stderr, "Child was terminated by signal", -retcode
+        print("Child was terminated by signal", -retcode, file=sys.stderr)
     else:
-        print >>sys.stderr, "Child returned", retcode
-except OSError, e:
-    print >>sys.stderr, "Execution failed:", e
+        print("Child returned", retcode, file=sys.stderr)
+except OSError as e:
+    print("Execution failed:", e, file=sys.stderr)
 
 
 Replacing os.spawn*
@@ -283,160 +317,89 @@
 os.spawnlpe(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg", env)
 ==>
 Popen(["/bin/mycmd", "myarg"], env={"PATH": "/usr/bin"})
-
-
-Replacing os.popen*
--------------------
-pipe = os.popen("cmd", mode='r', bufsize)
-==>
-pipe = Popen("cmd", shell=True, bufsize=bufsize, stdout=PIPE).stdout
-
-pipe = os.popen("cmd", mode='w', bufsize)
-==>
-pipe = Popen("cmd", shell=True, bufsize=bufsize, stdin=PIPE).stdin
-
-
-(child_stdin, child_stdout) = os.popen2("cmd", mode, bufsize)
-==>
-p = Popen("cmd", shell=True, bufsize=bufsize,
-          stdin=PIPE, stdout=PIPE, close_fds=True)
-(child_stdin, child_stdout) = (p.stdin, p.stdout)
-
-
-(child_stdin,
- child_stdout,
- child_stderr) = os.popen3("cmd", mode, bufsize)
-==>
-p = Popen("cmd", shell=True, bufsize=bufsize,
-          stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)
-(child_stdin,
- child_stdout,
- child_stderr) = (p.stdin, p.stdout, p.stderr)
-
-
-(child_stdin, child_stdout_and_stderr) = os.popen4("cmd", mode,
-                                                   bufsize)
-==>
-p = Popen("cmd", shell=True, bufsize=bufsize,
-          stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
-(child_stdin, child_stdout_and_stderr) = (p.stdin, p.stdout)
-
-On Unix, os.popen2, os.popen3 and os.popen4 also accept a sequence as
-the command to execute, in which case arguments will be passed
-directly to the program without shell intervention.  This usage can be
-replaced as follows:
-
-(child_stdin, child_stdout) = os.popen2(["/bin/ls", "-l"], mode,
-                                        bufsize)
-==>
-p = Popen(["/bin/ls", "-l"], bufsize=bufsize, stdin=PIPE, stdout=PIPE)
-(child_stdin, child_stdout) = (p.stdin, p.stdout)
-
-Return code handling translates as follows:
-
-pipe = os.popen("cmd", 'w')
-...
-rc = pipe.close()
-if rc != None and rc % 256:
-    print "There were some errors"
-==>
-process = Popen("cmd", 'w', shell=True, stdin=PIPE)
-...
-process.stdin.close()
-if process.wait() != 0:
-    print "There were some errors"
-
-
-Replacing popen2.*
-------------------
-(child_stdout, child_stdin) = popen2.popen2("somestring", bufsize, mode)
-==>
-p = Popen(["somestring"], shell=True, bufsize=bufsize
-          stdin=PIPE, stdout=PIPE, close_fds=True)
-(child_stdout, child_stdin) = (p.stdout, p.stdin)
-
-On Unix, popen2 also accepts a sequence as the command to execute, in
-which case arguments will be passed directly to the program without
-shell intervention.  This usage can be replaced as follows:
-
-(child_stdout, child_stdin) = popen2.popen2(["mycmd", "myarg"], bufsize,
-                                            mode)
-==>
-p = Popen(["mycmd", "myarg"], bufsize=bufsize,
-          stdin=PIPE, stdout=PIPE, close_fds=True)
-(child_stdout, child_stdin) = (p.stdout, p.stdin)
-
-The popen2.Popen3 and popen2.Popen4 basically works as subprocess.Popen,
-except that:
-
-* subprocess.Popen raises an exception if the execution fails
-* the capturestderr argument is replaced with the stderr argument.
-* stdin=PIPE and stdout=PIPE must be specified.
-* popen2 closes all filedescriptors by default, but you have to specify
-  close_fds=True with subprocess.Popen.
 """
 
 import sys
 mswindows = (sys.platform == "win32")
 
+import io
 import os
-import types
 import traceback
 import gc
 import signal
+import errno
+import time
+import sys
+
+if mswindows:
+    from win32file import ReadFile, WriteFile
+    from win32pipe import PeekNamedPipe
+    import msvcrt
+else:
+    import select
+    import fcntl
+
 
 # Exception classes used by this module.
 class CalledProcessError(Exception):
-    """This exception is raised when a process run by check_call() returns
-    a non-zero exit status.  The exit status will be stored in the
-    returncode attribute."""
-    def __init__(self, returncode, cmd):
+    """This exception is raised when a process run by check_call() or
+    check_output() returns a non-zero exit status.
+    The exit status will be stored in the returncode attribute;
+    check_output() will also store the output in the output attribute.
+    """
+    def __init__(self, returncode, cmd, output=None):
         self.returncode = returncode
         self.cmd = cmd
+        self.output = output
     def __str__(self):
         return "Command '%s' returned non-zero exit status %d" % (self.cmd, self.returncode)
 
 
 if mswindows:
-    from _subprocess import CREATE_NEW_CONSOLE
     import threading
     import msvcrt
-    import _subprocess
-    class STARTUPINFO:
-        dwFlags = 0
-        hStdInput = None
-        hStdOutput = None
-        hStdError = None
-        wShowWindow = 0
-    class pywintypes:
-        error = IOError
+    if 0: # <-- change this to use pywin32 instead of the _subprocess driver
+        import pywintypes
+        from win32api import GetStdHandle, STD_INPUT_HANDLE, \
+                             STD_OUTPUT_HANDLE, STD_ERROR_HANDLE
+        from win32api import GetCurrentProcess, DuplicateHandle, \
+                             GetModuleFileName, GetVersion
+        from win32con import DUPLICATE_SAME_ACCESS, SW_HIDE
+        from win32pipe import CreatePipe
+        from win32process import CreateProcess, STARTUPINFO, \
+                                 GetExitCodeProcess, STARTF_USESTDHANDLES, \
+                                 STARTF_USESHOWWINDOW, CREATE_NEW_CONSOLE
+        from win32process import TerminateProcess
+        from win32event import WaitForSingleObject, INFINITE, WAIT_OBJECT_0
+    else:
+        from _subprocess import *
+        class STARTUPINFO:
+            dwFlags = 0
+            hStdInput = None
+            hStdOutput = None
+            hStdError = None
+            wShowWindow = 0
+        class pywintypes:
+            error = IOError
 else:
     import select
     import errno
     import fcntl
     import pickle
 
-__all__ = ["Popen", "PIPE", "STDOUT", "call", "check_call", "CalledProcessError"]
+__all__ = ["Popen", "PIPE", "STDOUT", "call", "check_call", "getstatusoutput",
+           "getoutput", "check_output", "CalledProcessError"]
 
-if mswindows:
-    __all__.append("CREATE_NEW_CONSOLE")
 try:
     MAXFD = os.sysconf("SC_OPEN_MAX")
 except:
     MAXFD = 256
 
-# True/False does not exist on 2.2.0
-#try:
-#    False
-#except NameError:
-#    False = 0
-#    True = 1
-
 _active = []
 
 def _cleanup():
     for inst in _active[:]:
-        res = inst._internal_poll(_deadstate=sys.maxint)
+        res = inst._internal_poll(_deadstate=sys.maxsize)
         if res is not None and res >= 0:
             try:
                 _active.remove(inst)
@@ -449,16 +412,6 @@
 STDOUT = -2
 
 
-def _eintr_retry_call(func, *args):
-    while True:
-        try:
-            return func(*args)
-        except OSError, e:
-            if e.errno == errno.EINTR:
-                continue
-            raise
-
-
 def call(*popenargs, **kwargs):
     """Run command with arguments.  Wait for command to complete, then
     return the returncode attribute.
@@ -481,12 +434,45 @@
     check_call(["ls", "-l"])
     """
     retcode = call(*popenargs, **kwargs)
-    cmd = kwargs.get("args")
-    if cmd is None:
-        cmd = popenargs[0]
     if retcode:
+        cmd = kwargs.get("args")
+        if cmd is None:
+            cmd = popenargs[0]
         raise CalledProcessError(retcode, cmd)
-    return retcode
+    return 0
+
+
+def check_output(*popenargs, **kwargs):
+    """Run command with arguments and return its output as a byte string.
+
+    If the exit code was non-zero it raises a CalledProcessError.  The
+    CalledProcessError object will have the return code in the returncode
+    attribute and output in the output attribute.
+
+    The arguments are the same as for the Popen constructor.  Example:
+
+    >>> check_output(["ls", "-l", "/dev/null"])
+    'crw-rw-rw- 1 root root 1, 3 Oct 18  2007 /dev/null\n'
+
+    The stdout argument is not allowed as it is used internally.
+    To capture standard error in the result, use stderr=subprocess.STDOUT.
+
+    >>> check_output(["/bin/sh", "-c",
+                      "ls -l non_existent_file ; exit 0"],
+                     stderr=subprocess.STDOUT)
+    'ls: non_existent_file: No such file or directory\n'
+    """
+    if 'stdout' in kwargs:
+        raise ValueError('stdout argument not allowed, it will be overridden.')
+    process = Popen(*popenargs, stdout=PIPE, **kwargs)
+    output, unused_err = process.communicate()
+    retcode = process.poll()
+    if retcode:
+        cmd = kwargs.get("args")
+        if cmd is None:
+            cmd = popenargs[0]
+        raise CalledProcessError(retcode, cmd, output=output)
+    return output
 
 
 def list2cmdline(seq):
@@ -499,8 +485,8 @@
 
     2) A string surrounded by double quotation marks is
        interpreted as a single argument, regardless of white space
-       contained within.  A quoted string can be embedded in an
-       argument.
+       or pipe characters contained within.  A quoted string can be
+       embedded in an argument.
 
     3) A double quotation mark preceded by a backslash is
        interpreted as a literal double quotation mark.
@@ -516,9 +502,7 @@
     """
 
     # See
-    # http://msdn.microsoft.com/en-us/library/17w5ykft.aspx
-    # or search http://msdn.microsoft.com for
-    # "Parsing C++ Command-Line Arguments"
+    # http://msdn.microsoft.com/library/en-us/vccelng/htm/progs_12.asp
     result = []
     needquote = False
     for arg in seq:
@@ -528,7 +512,7 @@
         if result:
             result.append(' ')
 
-        needquote = (" " in arg) or ("\t" in arg) or not arg
+        needquote = (" " in arg) or ("\t" in arg) or ("|" in arg) or not arg
         if needquote:
             result.append('"')
 
@@ -559,6 +543,185 @@
     return ''.join(result)
 
 
+# Various tools for executing commands and looking at their output and status.
+#
+# NB This only works (and is only relevant) for UNIX.
+
+def getstatusoutput(cmd):
+    """Return (status, output) of executing cmd in a shell.
+
+    Execute the string 'cmd' in a shell with os.popen() and return a 2-tuple
+    (status, output).  cmd is actually run as '{ cmd ; } 2>&1', so that the
+    returned output will contain output or error messages.  A trailing newline
+    is stripped from the output.  The exit status for the command can be
+    interpreted according to the rules for the C function wait().  Example:
+
+    >>> import subprocess
+    >>> subprocess.getstatusoutput('ls /bin/ls')
+    (0, '/bin/ls')
+    >>> subprocess.getstatusoutput('cat /bin/junk')
+    (256, 'cat: /bin/junk: No such file or directory')
+    >>> subprocess.getstatusoutput('/bin/junk')
+    (256, 'sh: /bin/junk: not found')
+    """
+    pipe = os.popen('{ ' + cmd + '; } 2>&1', 'r')
+    text = pipe.read()
+    sts = pipe.close()
+    if sts is None: sts = 0
+    if text[-1:] == '\n': text = text[:-1]
+    return sts, text
+
+
+def getoutput(cmd):
+    """Return output (stdout or stderr) of executing cmd in a shell.
+
+    Like getstatusoutput(), except the exit status is ignored and the return
+    value is a string containing the command's output.  Example:
+
+    >>> import subprocess
+    >>> subprocess.getoutput('ls /bin/ls')
+    '/bin/ls'
+    """
+    return getstatusoutput(cmd)[1]
+
+def FileWrapper(command, mode = 'r+', buffering = 1024, newlines = None):
+    return TextIOWrapper(command, mode, buffering)
+
+class TextIOWrapper(object):
+    """
+    This class allows a program to act as a stand-in for a file object. 
+    """
+    validnewlines = ['\n', '\r\n','\r'] #Order is significant.
+    def __init__(self, command, mode = 'r+', buffering = 1024):
+        self.cursor = 0
+        self.buffereddata = ''
+        self.newlines = ('\n',)
+        self.unewlines = 'U' in mode
+        self.popenobject = Popen(command, stdout = PIPE, stdin = PIPE)#, universal_newlines = self.unewlines)
+    
+    def __del__(self):
+        self.close()
+    
+    def flush(self):
+        """
+        Calls self.__closecheck() to emulate the error that a file would
+        return if it were closed upon calling flush.
+        """
+        self.__closecheck()
+    
+    def __closecheck(self):
+        """Raise an error if the pipe has been terminated and I/O closed."""
+        # Check to see if the pipe is closed.
+        if self.cursor == -1:
+            raise ValueError( "I/O operation on a closed file.")  
+            
+    def close(self):
+        """Terminate the child process."""
+        if self.cursor != -1:
+            self.popenobject.terminate()
+            self.cursor = -1
+    
+    def seek(self, pos, whence = 0):
+        """
+        Skip a specified number of bytes. Whence can only be 0 or 1 and only
+        seeking forward is allowed which means if whence is 0, pos must be
+        greater than or equal to the current cursor position. If whence is 1,
+        pos must be a postive number.
+        """
+        if (whence == 0 and pos < self.cursor) or \
+           (whence == 1 and pos < 0) or whence > 1 or whence < 0:
+            raise IOError( "Invalid seek position." )
+        if pos == 0:
+            return
+        elif whence == 0:
+            # Calculate distance to that seek point and skip data
+            rdata = self.read(size = pos - self.cursor)
+        elif whence == 1:
+            # Skip amount of data passed
+            rdata = self.read(size = pos)
+        else:
+            raise IOError( "Invalid seek position" )
+        # Only move cursor as far as data was read instead of assuming
+    
+    def tell(self):
+        """
+        Returns the number of bytes read / the position in the data stream.
+        """
+        self.__closecheck()
+        return self.cursor
+            
+    def write(self, data):
+        """
+        Write data to the child process.
+        """
+        self.__closecheck()
+        self.popenobject.send(data)
+
+    def readlines(self, sizehint = -1):
+        """
+        Reads approximately sizehint bytes and returns the data broken into
+        lines. If sizehint is left at its default value, lines will be
+        returned until no more data is returned by the child process.
+        """
+        return list(self.__iter__(sizehint = sizehint))
+
+    def __iter__(self, sizehint = -1):
+        linebuffer, bytesread = 'x', 0
+        while True:
+            linebuffer = self.readline()
+            bytesread += len(linebuffer)
+            yield linebuffer
+            if not self.buffereddata or (bytesread >= sizehint and sizehint > 0):
+                break
+
+    def _newlinesearch(self, searchable):
+        best = len(searchable) + 1
+        bestnewline = None
+        for newlinetype in self.validnewlines:
+            marker = searchable.find(newlinetype)
+            if marker >= 0 and marker < best:
+                best = marker
+                bestnewline = newlinetype
+        if bestnewline not in self.newlines and bestnewline is not None:
+            self.newlines = tuple(list(self.newlines) + [bestnewline])
+        elif best == len(searchable) + 1:
+            best = -1
+        return (best, bestnewline)
+
+    def readline(self):
+        readdata = self.read()
+        marker, nltype = self._newlinesearch(readdata)
+        if marker >= 0:
+            eol = len(nltype) + marker
+            linecontent = readdata[:eol]
+            rebuffer = readdata[eol:]
+            self.cursor -= len(rebuffer)
+            self.buffereddata = rebuffer
+        else:
+            linecontent = readdata
+        return linecontent
+
+    def read(self, size = None, updatecursor = True):
+        """
+        Reads size bytes if it is specified, otherwise data is read from the
+        child process until no more data is returned.
+        """
+        self.__closecheck()
+        rdata = self.buffereddata + self.popenobject.asyncread(timeout = 1.25, maxsize = size)
+        if self.unewlines:
+            if '\r\n' in rdata:
+                rdata = rdata.replace('\r\n','\n')
+                if '\r\n' not in self.newlines:
+                    self.newlines = tuple(list(self.newlines) + ['\r\n'])
+            if '\r' in rdata:
+                rdata = rdata.replace('\r','\n')
+                if '\r' not in self.newlines:
+                    self.newlines = tuple(list(self.newlines) + ['\r'])
+        self.buffereddata = ''
+        if updatecursor:
+            self.cursor += len(rdata)
+        return rdata
+
 class Popen(object):
     def __init__(self, args, bufsize=0, executable=None,
                  stdin=None, stdout=None, stderr=None,
@@ -569,7 +732,9 @@
         _cleanup()
 
         self._child_created = False
-        if not isinstance(bufsize, (int, long)):
+        if bufsize is None:
+            bufsize = 0  # Restore default
+        if not isinstance(bufsize, int):
             raise TypeError("bufsize must be an integer")
 
         if mswindows:
@@ -630,36 +795,215 @@
             if errread is not None:
                 errread = msvcrt.open_osfhandle(errread.Detach(), 0)
 
+        if bufsize == 0:
+            bufsize = 1  # Nearly unbuffered (XXX for now)
         if p2cwrite is not None:
-            self.stdin = os.fdopen(p2cwrite, 'wb', bufsize)
+            self.stdin = io.open(p2cwrite, 'wb', bufsize)
+            if self.universal_newlines:
+                self.stdin = io.TextIOWrapper(self.stdin)
         if c2pread is not None:
+            self.stdout = io.open(c2pread, 'rb', bufsize)
             if universal_newlines:
-                self.stdout = os.fdopen(c2pread, 'rU', bufsize)
-            else:
-                self.stdout = os.fdopen(c2pread, 'rb', bufsize)
+                self.stdout = io.TextIOWrapper(self.stdout)
         if errread is not None:
+            self.stderr = io.open(errread, 'rb', bufsize)
             if universal_newlines:
-                self.stderr = os.fdopen(errread, 'rU', bufsize)
-            else:
-                self.stderr = os.fdopen(errread, 'rb', bufsize)
+                self.stderr = io.TextIOWrapper(self.stderr)
 
 
-    def _translate_newlines(self, data):
-        data = data.replace("\r\n", "\n")
-        data = data.replace("\r", "\n")
-        return data
+    def _translate_newlines(self, data, encoding):
+        data = data.replace(b"\r\n", b"\n").replace(b"\r", b"\n")
+        return data.decode(encoding)
 
 
-    def __del__(self, _maxint=sys.maxint, _active=_active):
+    def __del__(self, sys=sys):
         if not self._child_created:
             # We didn't get to successfully create a child process.
             return
         # In case the child hasn't been waited on, check if it's done.
-        self._internal_poll(_deadstate=_maxint)
+        self._internal_poll(_deadstate=sys.maxsize)
         if self.returncode is None and _active is not None:
             # Child is still running, keep us alive until we can wait on it.
             _active.append(self)
 
+    def recv(self, maxsize=None):
+        """
+        Non-blocking reading of stdout from the child process. It is
+        recommended that you use subprocess.Popen.asyncread instead of this
+        method.
+        """
+        return self._recv('stdout', maxsize)
+    
+    def recv_err(self, maxsize=None):
+        """
+        Non-blocking reading of stderr from the child process. It is
+        recommended that you use subprocess.Popen.asyncread with the stderr
+        keyword specified as True.
+        """
+        return self._recv('stderr', maxsize)
+
+    def listen(self, input='', maxsize=None):
+        """
+        Sends input, if specified, and returns a tuple containing the number
+        of bytes written to the child process, and the output of the child
+        process. maxsize represents the number of bytes to read from the
+        child process. If it is None, data will be read until a specified
+        timeout is reached or no more data can be read.
+        """
+        bytes_sent = self.send(input)
+        out = self.asyncread(timeout=.25, stderr=False, maxsize=maxsize)
+        err = self.asyncread(timeout=.25, stderr=True, maxsize=maxsize)
+        return bytes_sent, out, err
+
+    def get_conn_maxsize(self, which, maxsize):
+        # Not 100% certain if I get how this works yet.
+        if maxsize is None:
+            maxsize = 1024
+        elif maxsize < 1:
+            maxsize = 1
+        return getattr(self, which), maxsize
+    
+    def _close(self, which):
+        getattr(self, which).close()
+        setattr(self, which, None)
+
+    def asyncread(self, timeout=.1, raiseonnone = False, timeresolution=5, stderr = None, maxsize=None, chunksize=None):
+        """Non-blocking asynchronous reading of the child process.
+        
+        Read maxsize bytes asynchronously from the process in chunks of
+        chunksize bytes. If chunksize is None, the largest possible chunksize,
+        generally 1024 bytes, is used. If maxsize is none, this method will
+        attempt to read data until the specified timeout in seconds. To make
+        me the specified timeout more accurate or less accurate,
+        timeresolution can be increased or decreased respectively.
+        
+        If raiseonnone is True, the method will raise an exception if the
+        process appears to be disconnected.
+        """
+        if chunksize is None and maxsize > 0:
+            chunksize = maxsize
+        if timeresolution < 1:
+            timeresolution = 1
+        limit = time.time()+timeout
+        chunks = []
+        dataread = ''
+        method = self.recv
+        if stderr:
+            method = self.recv_err
+        while maxsize != 0 and (time.time() < limit or dataread):
+            dataread = method(chunksize)
+            if dataread is None:
+                if raiseonnone:
+                    raise Exception("Disconnected")
+                else:
+                    break
+            elif dataread:
+                if maxsize is not None:
+                    maxsize -= len(dataread)
+                    if (chunksize > maxsize):
+                        chunksize = maxsize
+                chunks.append(dataread)
+            else:
+                if maxsize <= 0 and maxsize is not None:
+                    break
+                time.sleep(max((limit-time.time())/timeresolution, 0))
+        return ''.join(chunks)
+
+    def asyncwrite(self, data):
+        while len(data):
+            sent = self.send(data)
+            if sent is None:
+                raise Exception(message)
+            data = buffer(data, sent)
+
+    if mswindows:
+        def send(self, input):
+            """
+            Sends data to the child process in a non-blocking manner. Returns
+            the number of bytes written.
+            """
+            if not self.stdin:
+                return None
+
+            try:
+                x = msvcrt.get_osfhandle(self.stdin.fileno())
+                (errCode, written) = WriteFile(x, input)
+            except ValueError:
+                return self._close('stdin')
+            except (pywintypes.error, Exception) as why:
+                if why[0] in (109, errno.ESHUTDOWN):
+                    return self._close('stdin')
+                raise
+
+            return written
+
+        def _recv(self, which, maxsize):
+            conn, maxsize = self.get_conn_maxsize(which, maxsize)
+            if conn is None:
+                return None
+            
+            try:
+                x = msvcrt.get_osfhandle(conn.fileno())
+                (read, nAvail, nMessage) = PeekNamedPipe(x, 0)
+                if maxsize < nAvail:
+                    nAvail = maxsize
+                if nAvail > 0:
+                    (errCode, read) = ReadFile(x, nAvail, None)
+            except ValueError:
+                return self._close(which)
+            except (pywintypes.error, Exception) as why:
+                if why[0] in (109, errno.ESHUTDOWN):
+                    return self._close(which)
+                raise
+            
+            if self.universal_newlines:
+                read = self._translate_newlines(read)
+            return read
+
+    else:
+        def send(self, input):
+            """
+            Sends data to the child process in a non-blocking manner. Returns
+            the number of bytes written.
+            """
+            if not self.stdin:
+                return None
+
+            if not select.select([], [self.stdin], [], 0)[1]:
+                return 0
+
+            try:
+                written = os.write(self.stdin.fileno(), input)
+            except OSError as why:
+                if why[0] == errno.EPIPE: #broken pipe
+                    return self._close('stdin')
+                raise
+
+            return written
+
+        def _recv(self, which, maxsize):
+            conn, maxsize = self.get_conn_maxsize(which, maxsize)
+            if conn is None:
+                return None
+            
+            flags = fcntl.fcntl(conn, fcntl.F_GETFL)
+            if not conn.closed:
+                fcntl.fcntl(conn, fcntl.F_SETFL, flags| os.O_NONBLOCK)
+            
+            try:
+                if not select.select([conn], [], [], 0)[0]:
+                    return ''
+                
+                r = conn.read(maxsize)
+                if not r:
+                    return self._close(which)
+    
+                if self.universal_newlines:
+                    r = self._translate_newlines(r)
+                return r
+            finally:
+                if not conn.closed:
+                    fcntl.fcntl(conn, fcntl.F_SETFL, flags)
 
     def communicate(self, input=None):
         """Interact with process: Send data to stdin.  Read data from
@@ -711,11 +1055,11 @@
             errread, errwrite = None, None
 
             if stdin is None:
-                p2cread = _subprocess.GetStdHandle(_subprocess.STD_INPUT_HANDLE)
+                p2cread = GetStdHandle(STD_INPUT_HANDLE)
                 if p2cread is None:
-                    p2cread, _ = _subprocess.CreatePipe(None, 0)
+                    p2cread, _ = CreatePipe(None, 0)
             elif stdin == PIPE:
-                p2cread, p2cwrite = _subprocess.CreatePipe(None, 0)
+                p2cread, p2cwrite = CreatePipe(None, 0)
             elif isinstance(stdin, int):
                 p2cread = msvcrt.get_osfhandle(stdin)
             else:
@@ -724,11 +1068,11 @@
             p2cread = self._make_inheritable(p2cread)
 
             if stdout is None:
-                c2pwrite = _subprocess.GetStdHandle(_subprocess.STD_OUTPUT_HANDLE)
+                c2pwrite = GetStdHandle(STD_OUTPUT_HANDLE)
                 if c2pwrite is None:
-                    _, c2pwrite = _subprocess.CreatePipe(None, 0)
+                    _, c2pwrite = CreatePipe(None, 0)
             elif stdout == PIPE:
-                c2pread, c2pwrite = _subprocess.CreatePipe(None, 0)
+                c2pread, c2pwrite = CreatePipe(None, 0)
             elif isinstance(stdout, int):
                 c2pwrite = msvcrt.get_osfhandle(stdout)
             else:
@@ -737,11 +1081,11 @@
             c2pwrite = self._make_inheritable(c2pwrite)
 
             if stderr is None:
-                errwrite = _subprocess.GetStdHandle(_subprocess.STD_ERROR_HANDLE)
+                errwrite = GetStdHandle(STD_ERROR_HANDLE)
                 if errwrite is None:
-                    _, errwrite = _subprocess.CreatePipe(None, 0)
+                    _, errwrite = CreatePipe(None, 0)
             elif stderr == PIPE:
-                errread, errwrite = _subprocess.CreatePipe(None, 0)
+                errread, errwrite = CreatePipe(None, 0)
             elif stderr == STDOUT:
                 errwrite = c2pwrite
             elif isinstance(stderr, int):
@@ -758,15 +1102,14 @@
 
         def _make_inheritable(self, handle):
             """Return a duplicate of handle, which is inheritable"""
-            return _subprocess.DuplicateHandle(_subprocess.GetCurrentProcess(),
-                                handle, _subprocess.GetCurrentProcess(), 0, 1,
-                                _subprocess.DUPLICATE_SAME_ACCESS)
+            return DuplicateHandle(GetCurrentProcess(), handle,
+                                   GetCurrentProcess(), 0, 1,
+                                   DUPLICATE_SAME_ACCESS)
 
 
         def _find_w9xpopen(self):
             """Find and return absolut path to w9xpopen.exe"""
-            w9xpopen = os.path.join(
-                            os.path.dirname(_subprocess.GetModuleFileName(0)),
+            w9xpopen = os.path.join(os.path.dirname(GetModuleFileName(0)),
                                     "w9xpopen.exe")
             if not os.path.exists(w9xpopen):
                 # Eeek - file-not-found - possibly an embedding
@@ -788,24 +1131,24 @@
                            errread, errwrite):
             """Execute program (MS Windows version)"""
 
-            if not isinstance(args, types.StringTypes):
+            if not isinstance(args, str):
                 args = list2cmdline(args)
 
             # Process startup details
             if startupinfo is None:
                 startupinfo = STARTUPINFO()
             if None not in (p2cread, c2pwrite, errwrite):
-                startupinfo.dwFlags |= _subprocess.STARTF_USESTDHANDLES
+                startupinfo.dwFlags |= STARTF_USESTDHANDLES
                 startupinfo.hStdInput = p2cread
                 startupinfo.hStdOutput = c2pwrite
                 startupinfo.hStdError = errwrite
 
             if shell:
-                startupinfo.dwFlags |= _subprocess.STARTF_USESHOWWINDOW
-                startupinfo.wShowWindow = _subprocess.SW_HIDE
+                startupinfo.dwFlags |= STARTF_USESHOWWINDOW
+                startupinfo.wShowWindow = SW_HIDE
                 comspec = os.environ.get("COMSPEC", "cmd.exe")
                 args = comspec + " /c " + args
-                if (_subprocess.GetVersion() >= 0x80000000L or
+                if (GetVersion() >= 0x80000000 or
                         os.path.basename(comspec).lower() == "command.com"):
                     # Win9x, or using command.com on NT. We need to
                     # use the w9xpopen intermediate program. For more
@@ -817,13 +1160,13 @@
                     # cause random failures on win9x.  Specifically a
                     # dialog: "Your program accessed mem currently in
                     # use at xxx" and a hopeful warning about the
-                    # stability of your system.  Cost is Ctrl+C wont
+                    # stability of your system.  Cost is Ctrl+C won't
                     # kill children.
-                    creationflags |= _subprocess.CREATE_NEW_CONSOLE
+                    creationflags |= CREATE_NEW_CONSOLE
 
             # Start the process
             try:
-                hp, ht, pid, tid = _subprocess.CreateProcess(executable, args,
+                hp, ht, pid, tid = CreateProcess(executable, args,
                                          # no special security
                                          None, None,
                                          int(not close_fds),
@@ -831,7 +1174,7 @@
                                          env,
                                          cwd,
                                          startupinfo)
-            except pywintypes.error, e:
+            except pywintypes.error as e:
                 # Translate pywintypes.error to WindowsError, which is
                 # a subclass of OSError.  FIXME: We should really
                 # translate errno using _sys_errlist (or simliar), but
@@ -858,20 +1201,12 @@
                 errwrite.Close()
 
 
-        def _internal_poll(self, _deadstate=None,
-                _WaitForSingleObject=_subprocess.WaitForSingleObject,
-                _WAIT_OBJECT_0=_subprocess.WAIT_OBJECT_0,
-                _GetExitCodeProcess=_subprocess.GetExitCodeProcess):
+        def _internal_poll(self, _deadstate=None):
             """Check if child process has terminated.  Returns returncode
-            attribute.
-
-            This method is called by __del__, so it can only refer to objects
-            in its local scope.
-
-            """
+            attribute."""
             if self.returncode is None:
-                if _WaitForSingleObject(self._handle, 0) == _WAIT_OBJECT_0:
-                    self.returncode = _GetExitCodeProcess(self._handle)
+                if WaitForSingleObject(self._handle, 0) == WAIT_OBJECT_0:
+                    self.returncode = GetExitCodeProcess(self._handle)
             return self.returncode
 
 
@@ -879,9 +1214,8 @@
             """Wait for child process to terminate.  Returns returncode
             attribute."""
             if self.returncode is None:
-                _subprocess.WaitForSingleObject(self._handle,
-                                                _subprocess.INFINITE)
-                self.returncode = _subprocess.GetExitCodeProcess(self._handle)
+                obj = WaitForSingleObject(self._handle, INFINITE)
+                self.returncode = GetExitCodeProcess(self._handle)
             return self.returncode
 
 
@@ -897,13 +1231,13 @@
                 stdout = []
                 stdout_thread = threading.Thread(target=self._readerthread,
                                                  args=(self.stdout, stdout))
-                stdout_thread.setDaemon(True)
+                stdout_thread.daemon = True
                 stdout_thread.start()
             if self.stderr:
                 stderr = []
                 stderr_thread = threading.Thread(target=self._readerthread,
                                                  args=(self.stderr, stderr))
-                stderr_thread.setDaemon(True)
+                stderr_thread.daemon = True
                 stderr_thread.start()
 
             if self.stdin:
@@ -922,16 +1256,6 @@
             if stderr is not None:
                 stderr = stderr[0]
 
-            # Translate newlines, if requested.  We cannot let the file
-            # object do the translation: It is based on stdio, which is
-            # impossible to combine with select (unless forcing no
-            # buffering).
-            if self.universal_newlines and hasattr(file, 'newlines'):
-                if stdout:
-                    stdout = self._translate_newlines(stdout)
-                if stderr:
-                    stderr = self._translate_newlines(stderr)
-
             self.wait()
             return (stdout, stderr)
 
@@ -946,7 +1270,7 @@
         def terminate(self):
             """Terminates the process
             """
-            _subprocess.TerminateProcess(self._handle, 1)
+            TerminateProcess(self._handle, 1)
 
         kill = terminate
 
@@ -1022,15 +1346,13 @@
                            errread, errwrite):
             """Execute program (POSIX version)"""
 
-            if isinstance(args, types.StringTypes):
+            if isinstance(args, str):
                 args = [args]
             else:
                 args = list(args)
 
             if shell:
                 args = ["/bin/sh", "-c"] + args
-                if executable:
-                    args[0] = executable
 
             if executable is None:
                 executable = args[0]
@@ -1039,101 +1361,93 @@
             # The first char specifies the exception type: 0 means
             # OSError, 1 means some other error.
             errpipe_read, errpipe_write = os.pipe()
+            self._set_cloexec_flag(errpipe_write)
+
+            gc_was_enabled = gc.isenabled()
+            # Disable gc to avoid bug where gc -> file_dealloc ->
+            # write to stderr -> hang.  http://bugs.python.org/issue1336
+            gc.disable()
             try:
+                self.pid = os.fork()
+            except:
+                if gc_was_enabled:
+                    gc.enable()
+                raise
+            self._child_created = True
+            if self.pid == 0:
+                # Child
                 try:
-                    self._set_cloexec_flag(errpipe_write)
-
-                    gc_was_enabled = gc.isenabled()
-                    # Disable gc to avoid bug where gc -> file_dealloc ->
-                    # write to stderr -> hang.  http://bugs.python.org/issue1336
-                    gc.disable()
-                    try:
-                        self.pid = os.fork()
-                    except:
-                        if gc_was_enabled:
-                            gc.enable()
-                        raise
-                    self._child_created = True
-                    if self.pid == 0:
-                        # Child
-                        try:
-                            # Close parent's pipe ends
-                            if p2cwrite is not None:
-                                os.close(p2cwrite)
-                            if c2pread is not None:
-                                os.close(c2pread)
-                            if errread is not None:
-                                os.close(errread)
-                            os.close(errpipe_read)
-
-                            # Dup fds for child
-                            if p2cread is not None:
-                                os.dup2(p2cread, 0)
-                            if c2pwrite is not None:
-                                os.dup2(c2pwrite, 1)
-                            if errwrite is not None:
-                                os.dup2(errwrite, 2)
-
-                            # Close pipe fds.  Make sure we don't close the same
-                            # fd more than once, or standard fds.
-                            if p2cread is not None and p2cread not in (0,):
-                                os.close(p2cread)
-                            if c2pwrite is not None and c2pwrite not in (p2cread, 1):
-                                os.close(c2pwrite)
-                            if errwrite is not None and errwrite not in (p2cread, c2pwrite, 2):
-                                os.close(errwrite)
-
-                            # Close all other fds, if asked for
-                            if close_fds:
-                                self._close_fds(but=errpipe_write)
-
-                            if cwd is not None:
-                                os.chdir(cwd)
-
-                            if preexec_fn:
-                                preexec_fn()
-
-                            if env is None:
-                                os.execvp(executable, args)
-                            else:
-                                os.execvpe(executable, args, env)
-
-                        except:
-                            exc_type, exc_value, tb = sys.exc_info()
-                            # Save the traceback and attach it to the exception object
-                            exc_lines = traceback.format_exception(exc_type,
-                                                                   exc_value,
-                                                                   tb)
-                            exc_value.child_traceback = ''.join(exc_lines)
-                            os.write(errpipe_write, pickle.dumps(exc_value))
-
-                        # This exitcode won't be reported to applications, so it
-                        # really doesn't matter what we return.
-                        os._exit(255)
-
-                    # Parent
-                    if gc_was_enabled:
-                        gc.enable()
-                finally:
-                    # be sure the FD is closed no matter what
-                    os.close(errpipe_write)
-
-                if p2cread is not None and p2cwrite is not None:
-                    os.close(p2cread)
-                if c2pwrite is not None and c2pread is not None:
-                    os.close(c2pwrite)
-                if errwrite is not None and errread is not None:
-                    os.close(errwrite)
-
-                # Wait for exec to fail or succeed; possibly raising exception
-                # Exception limited to 1M
-                data = _eintr_retry_call(os.read, errpipe_read, 1048576)
-            finally:
-                # be sure the FD is closed no matter what
-                os.close(errpipe_read)
-
-            if data != "":
-                _eintr_retry_call(os.waitpid, self.pid, 0)
+                    # Close parent's pipe ends
+                    if p2cwrite is not None:
+                        os.close(p2cwrite)
+                    if c2pread is not None:
+                        os.close(c2pread)
+                    if errread is not None:
+                        os.close(errread)
+                    os.close(errpipe_read)
+
+                    # Dup fds for child
+                    if p2cread is not None:
+                        os.dup2(p2cread, 0)
+                    if c2pwrite is not None:
+                        os.dup2(c2pwrite, 1)
+                    if errwrite is not None:
+                        os.dup2(errwrite, 2)
+
+                    # Close pipe fds.  Make sure we don't close the same
+                    # fd more than once, or standard fds.
+                    if p2cread is not None and p2cread not in (0,):
+                        os.close(p2cread)
+                    if c2pwrite is not None and c2pwrite not in (p2cread, 1):
+                        os.close(c2pwrite)
+                    if (errwrite is not None and
+                        errwrite not in (p2cread, c2pwrite, 2)):
+                        os.close(errwrite)
+
+                    # Close all other fds, if asked for
+                    if close_fds:
+                        self._close_fds(but=errpipe_write)
+
+                    if cwd is not None:
+                        os.chdir(cwd)
+
+                    if preexec_fn:
+                        preexec_fn()
+
+                    if env is None:
+                        os.execvp(executable, args)
+                    else:
+                        os.execvpe(executable, args, env)
+
+                except:
+                    exc_type, exc_value, tb = sys.exc_info()
+                    # Save the traceback and attach it to the exception object
+                    exc_lines = traceback.format_exception(exc_type,
+                                                           exc_value,
+                                                           tb)
+                    exc_value.child_traceback = ''.join(exc_lines)
+                    os.write(errpipe_write, pickle.dumps(exc_value))
+
+                # This exitcode won't be reported to applications, so it
+                # really doesn't matter what we return.
+                os._exit(255)
+
+            # Parent
+            if gc_was_enabled:
+                gc.enable()
+            os.close(errpipe_write)
+            if p2cread is not None and p2cwrite is not None:
+                os.close(p2cread)
+            if c2pwrite is not None and c2pread is not None:
+                os.close(c2pwrite)
+            if errwrite is not None and errread is not None:
+                os.close(errwrite)
+
+            # Wait for exec to fail or succeed; possibly raising exception
+            data = os.read(errpipe_read, 1048576) # Exceptions limited to 1 MB
+            os.close(errpipe_read)
+            if data:
+                os.waitpid(self.pid, 0)
                 child_exception = pickle.loads(data)
                 for fd in (p2cwrite, c2pread, errread):
                     if fd is not None:
@@ -1141,35 +1455,25 @@
                 raise child_exception
 
 
-        def _handle_exitstatus(self, sts, _WIFSIGNALED=os.WIFSIGNALED,
-                _WTERMSIG=os.WTERMSIG, _WIFEXITED=os.WIFEXITED,
-                _WEXITSTATUS=os.WEXITSTATUS):
-            # This method is called (indirectly) by __del__, so it cannot
-            # refer to anything outside of its local scope."""
-            if _WIFSIGNALED(sts):
-                self.returncode = -_WTERMSIG(sts)
-            elif _WIFEXITED(sts):
-                self.returncode = _WEXITSTATUS(sts)
+        def _handle_exitstatus(self, sts):
+            if os.WIFSIGNALED(sts):
+                self.returncode = -os.WTERMSIG(sts)
+            elif os.WIFEXITED(sts):
+                self.returncode = os.WEXITSTATUS(sts)
             else:
                 # Should never happen
                 raise RuntimeError("Unknown child exit status!")
 
 
-        def _internal_poll(self, _deadstate=None, _waitpid=os.waitpid,
-                _WNOHANG=os.WNOHANG, _os_error=os.error):
+        def _internal_poll(self, _deadstate=None):
             """Check if child process has terminated.  Returns returncode
-            attribute.
-
-            This method is called by __del__, so it cannot reference anything
-            outside of the local scope (nor can any methods it calls).
-
-            """
+            attribute."""
             if self.returncode is None:
                 try:
-                    pid, sts = _waitpid(self.pid, _WNOHANG)
+                    pid, sts = os.waitpid(self.pid, os.WNOHANG)
                     if pid == self.pid:
                         self._handle_exitstatus(sts)
-                except _os_error:
+                except os.error:
                     if _deadstate is not None:
                         self.returncode = _deadstate
             return self.returncode
@@ -1179,7 +1483,7 @@
             """Wait for child process to terminate.  Returns returncode
             attribute."""
             if self.returncode is None:
-                pid, sts = _eintr_retry_call(os.waitpid, self.pid, 0)
+                pid, sts = os.waitpid(self.pid, 0)
                 self._handle_exitstatus(sts)
             return self.returncode
 
@@ -1209,11 +1513,14 @@
             while read_set or write_set:
                 try:
                     rlist, wlist, xlist = select.select(read_set, write_set, [])
-                except select.error, e:
+                except select.error as e:
                     if e.args[0] == errno.EINTR:
                         continue
                     raise
 
+                # XXX Rewrite these to use non-blocking I/O on the
+                # file objects; they are no longer using C stdio!
+
                 if self.stdin in wlist:
                     # When select has indicated that the file is writable,
                     # we can write up to PIPE_BUF bytes without risk
@@ -1227,33 +1534,33 @@
 
                 if self.stdout in rlist:
                     data = os.read(self.stdout.fileno(), 1024)
-                    if data == "":
+                    if not data:
                         self.stdout.close()
                         read_set.remove(self.stdout)
                     stdout.append(data)
 
                 if self.stderr in rlist:
                     data = os.read(self.stderr.fileno(), 1024)
-                    if data == "":
+                    if not data:
                         self.stderr.close()
                         read_set.remove(self.stderr)
                     stderr.append(data)
 
             # All data exchanged.  Translate lists into strings.
             if stdout is not None:
-                stdout = ''.join(stdout)
+                stdout = b"".join(stdout)
             if stderr is not None:
-                stderr = ''.join(stderr)
+                stderr = b"".join(stderr)
 
-            # Translate newlines, if requested.  We cannot let the file
-            # object do the translation: It is based on stdio, which is
-            # impossible to combine with select (unless forcing no
-            # buffering).
-            if self.universal_newlines and hasattr(file, 'newlines'):
-                if stdout:
-                    stdout = self._translate_newlines(stdout)
-                if stderr:
-                    stderr = self._translate_newlines(stderr)
+            # Translate newlines, if requested.
+            # This also turns bytes into strings.
+            if self.universal_newlines:
+                if stdout is not None:
+                    stdout = self._translate_newlines(stdout,
+                                                      self.stdout.encoding)
+                if stderr is not None:
+                    stderr = self._translate_newlines(stderr,
+                                                      self.stderr.encoding)
 
             self.wait()
             return (stdout, stderr)
@@ -1272,68 +1579,3 @@
             """Kill the process with SIGKILL
             """
             self.send_signal(signal.SIGKILL)
-
-
-def _demo_posix():
-    #
-    # Example 1: Simple redirection: Get process list
-    #
-    plist = Popen(["ps"], stdout=PIPE).communicate()[0]
-    print "Process list:"
-    print plist
-
-    #
-    # Example 2: Change uid before executing child
-    #
-    if os.getuid() == 0:
-        p = Popen(["id"], preexec_fn=lambda: os.setuid(100))
-        p.wait()
-
-    #
-    # Example 3: Connecting several subprocesses
-    #
-    print "Looking for 'hda'..."
-    p1 = Popen(["dmesg"], stdout=PIPE)
-    p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
-    print repr(p2.communicate()[0])
-
-    #
-    # Example 4: Catch execution error
-    #
-    print
-    print "Trying a weird file..."
-    try:
-        print Popen(["/this/path/does/not/exist"]).communicate()
-    except OSError, e:
-        if e.errno == errno.ENOENT:
-            print "The file didn't exist.  I thought so..."
-            print "Child traceback:"
-            print e.child_traceback
-        else:
-            print "Error", e.errno
-    else:
-        print >>sys.stderr, "Gosh.  No error."
-
-
-def _demo_windows():
-    #
-    # Example 1: Connecting several subprocesses
-    #
-    print "Looking for 'PROMPT' in set output..."
-    p1 = Popen("set", stdout=PIPE, shell=True)
-    p2 = Popen('find "PROMPT"', stdin=p1.stdout, stdout=PIPE)
-    print repr(p2.communicate()[0])
-
-    #
-    # Example 2: Simple execution of program
-    #
-    print "Executing calc..."
-    p = Popen("calc")
-    p.wait()
-
-
-if __name__ == "__main__":
-    if mswindows:
-        _demo_windows()
-    else:
-        _demo_posix()
diff -ur python-2.6.7-ylmf1/Lib/test/test_subprocess.py python-2.6.7-ylmf1.new//Lib/test/test_subprocess.py
--- python-2.6.7-ylmf1/Lib/test/test_subprocess.py	2010-08-11 08:19:53.000000000 +0800
+++ python-2.6.7-ylmf1.new//Lib/test/test_subprocess.py	2012-03-20 13:30:51.376115004 +0800
@@ -1,10 +1,9 @@
 import unittest
-from test import test_support
+from test import support
 import subprocess
 import sys
 import signal
 import os
-import errno
 import tempfile
 import time
 import re
@@ -25,20 +24,21 @@
 # shutdown time.  That frustrates tests trying to check stderr produced
 # from a spawned Python process.
 def remove_stderr_debug_decorations(stderr):
-    return re.sub(r"\[\d+ refs\]\r?\n?$", "", stderr)
+    return re.sub("\[\d+ refs\]\r?\n?$", "", stderr.decode()).encode()
+    #return re.sub(r"\[\d+ refs\]\r?\n?$", "", stderr)
 
 class ProcessTestCase(unittest.TestCase):
     def setUp(self):
         # Try to minimize the number of children we have so this test
         # doesn't crash on some buildbots (Alphas in particular).
-        if hasattr(test_support, "reap_children"):
-            test_support.reap_children()
+        if hasattr(support, "reap_children"):
+            support.reap_children()
 
     def tearDown(self):
         # Try to minimize the number of children we have so this test
         # doesn't crash on some buildbots (Alphas in particular).
-        if hasattr(test_support, "reap_children"):
-            test_support.reap_children()
+        if hasattr(support, "reap_children"):
+            support.reap_children()
 
     def mkstemp(self):
         """wrapper for mkstemp, calling mktemp if mkstemp is not available"""
@@ -68,24 +68,58 @@
         try:
             subprocess.check_call([sys.executable, "-c",
                                    "import sys; sys.exit(47)"])
-        except subprocess.CalledProcessError, e:
+        except subprocess.CalledProcessError as e:
             self.assertEqual(e.returncode, 47)
         else:
             self.fail("Expected CalledProcessError")
 
+    def test_check_output(self):
+        # check_output() function with zero return code
+        output = subprocess.check_output(
+                [sys.executable, "-c", "print('BDFL')"])
+        self.assertTrue(b'BDFL' in output)
+
+    def test_check_output_nonzero(self):
+        # check_call() function with non-zero return code
+        try:
+            subprocess.check_output(
+                    [sys.executable, "-c", "import sys; sys.exit(5)"])
+        except subprocess.CalledProcessError as e:
+            self.assertEqual(e.returncode, 5)
+        else:
+            self.fail("Expected CalledProcessError")
+
+    def test_check_output_stderr(self):
+        # check_output() function stderr redirected to stdout
+        output = subprocess.check_output(
+                [sys.executable, "-c", "import sys; sys.stderr.write('BDFL')"],
+                stderr=subprocess.STDOUT)
+        self.assertTrue(b'BDFL' in output)
+
+    def test_check_output_stdout_arg(self):
+        # check_output() function stderr redirected to stdout
+        try:
+            output = subprocess.check_output(
+                    [sys.executable, "-c", "print('will not be run')"],
+                    stdout=sys.stdout)
+        except ValueError as e:
+            self.assertTrue('stdout' in e.args[0])
+        else:
+            self.fail("Expected ValueError when stdout arg supplied.")
+
     def test_call_kwargs(self):
         # call() function with keyword args
         newenv = os.environ.copy()
         newenv["FRUIT"] = "banana"
         rc = subprocess.call([sys.executable, "-c",
-                          'import sys, os;' \
-                          'sys.exit(os.getenv("FRUIT")=="banana")'],
-                        env=newenv)
+                              'import sys, os;'
+                              'sys.exit(os.getenv("FRUIT")=="banana")'],
+                             env=newenv)
         self.assertEqual(rc, 1)
 
     def test_stdin_none(self):
         # .stdin is None when not redirected
-        p = subprocess.Popen([sys.executable, "-c", 'print "banana"'],
+        p = subprocess.Popen([sys.executable, "-c", 'print("banana")'],
                          stdout=subprocess.PIPE, stderr=subprocess.PIPE)
         p.wait()
         self.assertEqual(p.stdin, None)
@@ -93,23 +127,24 @@
     def test_stdout_none(self):
         # .stdout is None when not redirected
         p = subprocess.Popen([sys.executable, "-c",
-                             'print "    this bit of output is from a '
+                             'print("    this bit of output is from a '
                              'test of stdout in a different '
-                             'process ..."'],
+                             'process ...")'],
                              stdin=subprocess.PIPE, stderr=subprocess.PIPE)
         p.wait()
         self.assertEqual(p.stdout, None)
 
     def test_stderr_none(self):
         # .stderr is None when not redirected
-        p = subprocess.Popen([sys.executable, "-c", 'print "banana"'],
+        p = subprocess.Popen([sys.executable, "-c", 'print("banana")'],
                          stdin=subprocess.PIPE, stdout=subprocess.PIPE)
         p.wait()
         self.assertEqual(p.stderr, None)
 
     def test_executable(self):
-        p = subprocess.Popen(["somethingyoudonthave",
-                              "-c", "import sys; sys.exit(47)"],
+        arg0 = os.path.join(os.path.dirname(sys.executable),
+                            "somethingyoudonthave")
+        p = subprocess.Popen([arg0, "-c", "import sys; sys.exit(47)"],
                              executable=sys.executable)
         p.wait()
         self.assertEqual(p.returncode, 47)
@@ -119,7 +154,7 @@
         p = subprocess.Popen([sys.executable, "-c",
                          'import sys; sys.exit(sys.stdin.read() == "pear")'],
                         stdin=subprocess.PIPE)
-        p.stdin.write("pear")
+        p.stdin.write(b"pear")
         p.stdin.close()
         p.wait()
         self.assertEqual(p.returncode, 1)
@@ -128,7 +163,7 @@
         # stdin is set to open file descriptor
         tf = tempfile.TemporaryFile()
         d = tf.fileno()
-        os.write(d, "pear")
+        os.write(d, b"pear")
         os.lseek(d, 0, 0)
         p = subprocess.Popen([sys.executable, "-c",
                          'import sys; sys.exit(sys.stdin.read() == "pear")'],
@@ -139,7 +174,7 @@
     def test_stdin_fileobj(self):
         # stdin is set to open file object
         tf = tempfile.TemporaryFile()
-        tf.write("pear")
+        tf.write(b"pear")
         tf.seek(0)
         p = subprocess.Popen([sys.executable, "-c",
                          'import sys; sys.exit(sys.stdin.read() == "pear")'],
@@ -152,7 +187,7 @@
         p = subprocess.Popen([sys.executable, "-c",
                           'import sys; sys.stdout.write("orange")'],
                          stdout=subprocess.PIPE)
-        self.assertEqual(p.stdout.read(), "orange")
+        self.assertEqual(p.stdout.read(), b"orange")
 
     def test_stdout_filedes(self):
         # stdout is set to open file descriptor
@@ -163,7 +198,7 @@
                          stdout=d)
         p.wait()
         os.lseek(d, 0, 0)
-        self.assertEqual(os.read(d, 1024), "orange")
+        self.assertEqual(os.read(d, 1024), b"orange")
 
     def test_stdout_fileobj(self):
         # stdout is set to open file object
@@ -173,7 +208,7 @@
                          stdout=tf)
         p.wait()
         tf.seek(0)
-        self.assertEqual(tf.read(), "orange")
+        self.assertEqual(tf.read(), b"orange")
 
     def test_stderr_pipe(self):
         # stderr redirection
@@ -181,7 +216,7 @@
                           'import sys; sys.stderr.write("strawberry")'],
                          stderr=subprocess.PIPE)
         self.assertEqual(remove_stderr_debug_decorations(p.stderr.read()),
-                         "strawberry")
+                         b"strawberry")
 
     def test_stderr_filedes(self):
         # stderr is set to open file descriptor
@@ -193,7 +228,7 @@
         p.wait()
         os.lseek(d, 0, 0)
         self.assertEqual(remove_stderr_debug_decorations(os.read(d, 1024)),
-                         "strawberry")
+                         b"strawberry")
 
     def test_stderr_fileobj(self):
         # stderr is set to open file object
@@ -204,40 +239,40 @@
         p.wait()
         tf.seek(0)
         self.assertEqual(remove_stderr_debug_decorations(tf.read()),
-                         "strawberry")
+                         b"strawberry")
 
     def test_stdout_stderr_pipe(self):
         # capture stdout and stderr to the same pipe
         p = subprocess.Popen([sys.executable, "-c",
-                          'import sys;' \
-                          'sys.stdout.write("apple");' \
-                          'sys.stdout.flush();' \
-                          'sys.stderr.write("orange")'],
-                         stdout=subprocess.PIPE,
-                         stderr=subprocess.STDOUT)
+                              'import sys;'
+                              'sys.stdout.write("apple");'
+                              'sys.stdout.flush();'
+                              'sys.stderr.write("orange")'],
+                             stdout=subprocess.PIPE,
+                             stderr=subprocess.STDOUT)
         output = p.stdout.read()
         stripped = remove_stderr_debug_decorations(output)
-        self.assertEqual(stripped, "appleorange")
+        self.assertEqual(stripped, b"appleorange")
 
     def test_stdout_stderr_file(self):
         # capture stdout and stderr to the same open file
         tf = tempfile.TemporaryFile()
         p = subprocess.Popen([sys.executable, "-c",
-                          'import sys;' \
-                          'sys.stdout.write("apple");' \
-                          'sys.stdout.flush();' \
-                          'sys.stderr.write("orange")'],
-                         stdout=tf,
-                         stderr=tf)
+                              'import sys;'
+                              'sys.stdout.write("apple");'
+                              'sys.stdout.flush();'
+                              'sys.stderr.write("orange")'],
+                             stdout=tf,
+                             stderr=tf)
         p.wait()
         tf.seek(0)
         output = tf.read()
         stripped = remove_stderr_debug_decorations(output)
-        self.assertEqual(stripped, "appleorange")
+        self.assertEqual(stripped, b"appleorange")
 
     def test_stdout_filedes_of_stdout(self):
         # stdout is set to 1 (#1531862).
-        cmd = r"import sys, os; sys.exit(os.write(sys.stdout.fileno(), '.\n'))"
+        cmd = r"import sys, os; sys.exit(os.write(sys.stdout.fileno(), b'.\n'))"
         rc = subprocess.call([sys.executable, "-c", cmd], stdout=1)
         self.assertEquals(rc, 2)
 
@@ -250,28 +285,30 @@
         tmpdir = os.getcwd()
         os.chdir(cwd)
         p = subprocess.Popen([sys.executable, "-c",
-                          'import sys,os;' \
-                          'sys.stdout.write(os.getcwd())'],
-                         stdout=subprocess.PIPE,
-                         cwd=tmpdir)
+                              'import sys,os;'
+                              'sys.stdout.write(os.getcwd())'],
+                             stdout=subprocess.PIPE,
+                             cwd=tmpdir)
         normcase = os.path.normcase
-        self.assertEqual(normcase(p.stdout.read()), normcase(tmpdir))
+        self.assertEqual(normcase(p.stdout.read().decode("utf-8")),
+                         normcase(tmpdir))
 
     def test_env(self):
         newenv = os.environ.copy()
         newenv["FRUIT"] = "orange"
         p = subprocess.Popen([sys.executable, "-c",
-                          'import sys,os;' \
-                          'sys.stdout.write(os.getenv("FRUIT"))'],
-                         stdout=subprocess.PIPE,
-                         env=newenv)
-        self.assertEqual(p.stdout.read(), "orange")
+                              'import sys,os;'
+                              'sys.stdout.write(os.getenv("FRUIT"))'],
+                             stdout=subprocess.PIPE,
+                             env=newenv)
+        self.assertEqual(p.stdout.read(), b"orange")
 
     def test_communicate_stdin(self):
         p = subprocess.Popen([sys.executable, "-c",
-                              'import sys; sys.exit(sys.stdin.read() == "pear")'],
+                              'import sys;'
+                              'sys.exit(sys.stdin.read() == "pear")'],
                              stdin=subprocess.PIPE)
-        p.communicate("pear")
+        p.communicate(b"pear")
         self.assertEqual(p.returncode, 1)
 
     def test_communicate_stdout(self):
@@ -279,7 +316,7 @@
                               'import sys; sys.stdout.write("pineapple")'],
                              stdout=subprocess.PIPE)
         (stdout, stderr) = p.communicate()
-        self.assertEqual(stdout, "pineapple")
+        self.assertEqual(stdout, b"pineapple")
         self.assertEqual(stderr, None)
 
     def test_communicate_stderr(self):
@@ -288,20 +325,22 @@
                              stderr=subprocess.PIPE)
         (stdout, stderr) = p.communicate()
         self.assertEqual(stdout, None)
-        self.assertEqual(remove_stderr_debug_decorations(stderr), "pineapple")
+        # When running with a pydebug build, the # of references is outputted
+        # to stderr, so just check if stderr at least started with "pinapple"
+        self.assertEqual(remove_stderr_debug_decorations(stderr), b"pineapple")
 
     def test_communicate(self):
         p = subprocess.Popen([sys.executable, "-c",
-                          'import sys,os;'
-                          'sys.stderr.write("pineapple");'
-                          'sys.stdout.write(sys.stdin.read())'],
-                         stdin=subprocess.PIPE,
-                         stdout=subprocess.PIPE,
-                         stderr=subprocess.PIPE)
-        (stdout, stderr) = p.communicate("banana")
-        self.assertEqual(stdout, "banana")
+                              'import sys,os;'
+                              'sys.stderr.write("pineapple");'
+                              'sys.stdout.write(sys.stdin.read())'],
+                             stdin=subprocess.PIPE,
+                             stdout=subprocess.PIPE,
+                             stderr=subprocess.PIPE)
+        (stdout, stderr) = p.communicate(b"banana")
+        self.assertEqual(stdout, b"banana")
         self.assertEqual(remove_stderr_debug_decorations(stderr),
-                         "pineapple")
+                         b"pineapple")
 
     # This test is Linux specific for simplicity to at least have
     # some coverage.  It is not a platform specific bug.
@@ -339,97 +378,85 @@
         os.close(x)
         os.close(y)
         p = subprocess.Popen([sys.executable, "-c",
-                          'import sys,os;'
-                          'sys.stdout.write(sys.stdin.read(47));' \
-                          'sys.stderr.write("xyz"*%d);' \
-                          'sys.stdout.write(sys.stdin.read())' % pipe_buf],
-                         stdin=subprocess.PIPE,
-                         stdout=subprocess.PIPE,
-                         stderr=subprocess.PIPE)
-        string_to_write = "abc"*pipe_buf
+                              'import sys,os;'
+                              'sys.stdout.write(sys.stdin.read(47));'
+                              'sys.stderr.write("xyz"*%d);'
+                              'sys.stdout.write(sys.stdin.read())' % pipe_buf],
+                             stdin=subprocess.PIPE,
+                             stdout=subprocess.PIPE,
+                             stderr=subprocess.PIPE)
+        string_to_write = b"abc"*pipe_buf
         (stdout, stderr) = p.communicate(string_to_write)
         self.assertEqual(stdout, string_to_write)
 
     def test_writes_before_communicate(self):
         # stdin.write before communicate()
         p = subprocess.Popen([sys.executable, "-c",
-                          'import sys,os;' \
-                          'sys.stdout.write(sys.stdin.read())'],
-                         stdin=subprocess.PIPE,
-                         stdout=subprocess.PIPE,
-                         stderr=subprocess.PIPE)
-        p.stdin.write("banana")
-        (stdout, stderr) = p.communicate("split")
-        self.assertEqual(stdout, "bananasplit")
-        self.assertEqual(remove_stderr_debug_decorations(stderr), "")
+                              'import sys,os;'
+                              'sys.stdout.write(sys.stdin.read())'],
+                             stdin=subprocess.PIPE,
+                             stdout=subprocess.PIPE,
+                             stderr=subprocess.PIPE)
+        p.stdin.write(b"banana")
+        (stdout, stderr) = p.communicate(b"split")
+        self.assertEqual(stdout, b"bananasplit")
+        self.assertEqual(remove_stderr_debug_decorations(stderr), b"")
 
     def test_universal_newlines(self):
         p = subprocess.Popen([sys.executable, "-c",
-                          'import sys,os;' + SETBINARY +
-                          'sys.stdout.write("line1\\n");'
-                          'sys.stdout.flush();'
-                          'sys.stdout.write("line2\\r");'
-                          'sys.stdout.flush();'
-                          'sys.stdout.write("line3\\r\\n");'
-                          'sys.stdout.flush();'
-                          'sys.stdout.write("line4\\r");'
-                          'sys.stdout.flush();'
-                          'sys.stdout.write("\\nline5");'
-                          'sys.stdout.flush();'
-                          'sys.stdout.write("\\nline6");'],
-                         stdout=subprocess.PIPE,
-                         universal_newlines=1)
+                              'import sys,os;' + SETBINARY +
+                              'sys.stdout.write("line1\\n");'
+                              'sys.stdout.flush();'
+                              'sys.stdout.write("line2\\n");'
+                              'sys.stdout.flush();'
+                              'sys.stdout.write("line3\\r\\n");'
+                              'sys.stdout.flush();'
+                              'sys.stdout.write("line4\\r");'
+                              'sys.stdout.flush();'
+                              'sys.stdout.write("\\nline5");'
+                              'sys.stdout.flush();'
+                              'sys.stdout.write("\\nline6");'],
+                             stdout=subprocess.PIPE,
+                             universal_newlines=1)
         stdout = p.stdout.read()
-        if hasattr(file, 'newlines'):
-            # Interpreter with universal newline support
-            self.assertEqual(stdout,
-                             "line1\nline2\nline3\nline4\nline5\nline6")
-        else:
-            # Interpreter without universal newline support
-            self.assertEqual(stdout,
-                             "line1\nline2\rline3\r\nline4\r\nline5\nline6")
+        self.assertEqual(stdout, "line1\nline2\nline3\nline4\nline5\nline6")
 
     def test_universal_newlines_communicate(self):
         # universal newlines through communicate()
         p = subprocess.Popen([sys.executable, "-c",
-                          'import sys,os;' + SETBINARY +
-                          'sys.stdout.write("line1\\n");'
-                          'sys.stdout.flush();'
-                          'sys.stdout.write("line2\\r");'
-                          'sys.stdout.flush();'
-                          'sys.stdout.write("line3\\r\\n");'
-                          'sys.stdout.flush();'
-                          'sys.stdout.write("line4\\r");'
-                          'sys.stdout.flush();'
-                          'sys.stdout.write("\\nline5");'
-                          'sys.stdout.flush();'
-                          'sys.stdout.write("\\nline6");'],
-                         stdout=subprocess.PIPE, stderr=subprocess.PIPE,
-                         universal_newlines=1)
+                              'import sys,os;' + SETBINARY +
+                              'sys.stdout.write("line1\\n");'
+                              'sys.stdout.flush();'
+                              'sys.stdout.write("line2\\n");'
+                              'sys.stdout.flush();'
+                              'sys.stdout.write("line3\\r\\n");'
+                              'sys.stdout.flush();'
+                              'sys.stdout.write("line4\\r");'
+                              'sys.stdout.flush();'
+                              'sys.stdout.write("\\nline5");'
+                              'sys.stdout.flush();'
+                              'sys.stdout.write("\\nline6");'],
+                             stdout=subprocess.PIPE, stderr=subprocess.PIPE,
+                             universal_newlines=1)
         (stdout, stderr) = p.communicate()
-        if hasattr(file, 'newlines'):
-            # Interpreter with universal newline support
-            self.assertEqual(stdout,
-                             "line1\nline2\nline3\nline4\nline5\nline6")
-        else:
-            # Interpreter without universal newline support
-            self.assertEqual(stdout, "line1\nline2\rline3\r\nline4\r\nline5\nline6")
+        self.assertEqual(stdout, "line1\nline2\nline3\nline4\nline5\nline6")
 
     def test_no_leaking(self):
         # Make sure we leak no resources
-        if not hasattr(test_support, "is_resource_enabled") \
-               or test_support.is_resource_enabled("subprocess") and not mswindows:
+        if (not hasattr(support, "is_resource_enabled") or
+            support.is_resource_enabled("subprocess") and not mswindows):
             max_handles = 1026 # too much for most UNIX systems
         else:
             max_handles = 65
         for i in range(max_handles):
             p = subprocess.Popen([sys.executable, "-c",
-                    "import sys;sys.stdout.write(sys.stdin.read())"],
-                    stdin=subprocess.PIPE,
-                    stdout=subprocess.PIPE,
-                    stderr=subprocess.PIPE)
-            data = p.communicate("lime")[0]
-            self.assertEqual(data, "lime")
+                                  "import sys;"
+                                  "sys.stdout.write(sys.stdin.read())"],
+                                 stdin=subprocess.PIPE,
+                                 stdout=subprocess.PIPE,
+                                 stderr=subprocess.PIPE)
+            data = p.communicate(b"lime")[0]
+            self.assertEqual(data, b"lime")
 
 
     def test_list2cmdline(self):
@@ -449,6 +476,8 @@
                          '"a\\\\b\\ c" d e')
         self.assertEqual(subprocess.list2cmdline(['ab', '']),
                          'ab ""')
+        self.assertEqual(subprocess.list2cmdline(['echo', 'foo|bar']),
+                         'echo "foo|bar"')
 
 
     def test_poll(self):
@@ -485,6 +514,14 @@
         else:
             self.fail("Expected TypeError")
 
+    def test_bufsize_is_none(self):
+        # bufsize=None should be the same as bufsize=0.
+        p = subprocess.Popen([sys.executable, "-c", "pass"], None)
+        self.assertEqual(p.wait(), 0)
+        # Again with keyword arg
+        p = subprocess.Popen([sys.executable, "-c", "pass"], bufsize=None)
+        self.assertEqual(p.wait(), 0)
+
     def test_leaking_fds_on_error(self):
         # see bug #5179: Popen leaks file descriptors to PIPEs if
         # the child fails to execute; this will eventually exhaust
@@ -497,7 +534,7 @@
                                  stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE)
             # Windows raises IOError
-            except (IOError, OSError), err:
+            except (IOError, OSError) as err:
                 if err.errno != 2:  # ignore "no such file"
                     raise
 
@@ -506,11 +543,11 @@
     #
     if not mswindows:
         def test_exceptions(self):
-            # catched & re-raised exceptions
+            # caught & re-raised exceptions
             try:
                 p = subprocess.Popen([sys.executable, "-c", ""],
-                                 cwd="/this/path/does/not/exist")
-            except OSError, e:
+                                     cwd="/this/path/does/not/exist")
+            except OSError as e:
                 # The attribute child_traceback should contain "os.chdir"
                 # somewhere.
                 self.assertNotEqual(e.child_traceback.find("os.chdir"), -1)
@@ -521,20 +558,6 @@
             """Try to prevent core files from being created.
             Returns previous ulimit if successful, else None.
             """
-            if sys.platform == 'darwin':
-                # Check if the 'Crash Reporter' on OSX was configured
-                # in 'Developer' mode and warn that it will get triggered
-                # when it is.
-                #
-                # This assumes that this context manager is used in tests
-                # that might trigger the next manager.
-                value = subprocess.Popen(['/usr/bin/defaults', 'read',
-                    'com.apple.CrashReporter', 'DialogType'],
-                    stdout=subprocess.PIPE).communicate()[0]
-                if value.strip() == b'developer':
-                    print "this tests triggers the Crash Reporter, that is intentional"
-                    sys.stdout.flush()
-
             try:
                 import resource
                 old_limit = resource.getrlimit(resource.RLIMIT_CORE)
@@ -567,20 +590,22 @@
         def test_preexec(self):
             # preexec function
             p = subprocess.Popen([sys.executable, "-c",
-                              'import sys,os;' \
-                              'sys.stdout.write(os.getenv("FRUIT"))'],
-                             stdout=subprocess.PIPE,
-                             preexec_fn=lambda: os.putenv("FRUIT", "apple"))
-            self.assertEqual(p.stdout.read(), "apple")
+                                  'import sys,os;'
+                                  'sys.stdout.write(os.getenv("FRUIT"))'],
+                                 stdout=subprocess.PIPE,
+                                 preexec_fn=lambda: os.putenv("FRUIT",
+                                                              "apple"))
+            self.assertEqual(p.stdout.read(), b"apple")
 
         def test_args_string(self):
             # args is a string
-            f, fname = self.mkstemp()
-            os.write(f, "#!/bin/sh\n")
-            os.write(f, "exec '%s' -c 'import sys; sys.exit(47)'\n" %
-                        sys.executable)
-            os.close(f)
-            os.chmod(fname, 0700)
+            fd, fname = self.mkstemp()
+            # reopen in text mode
+            with open(fd, "w") as fobj:
+                fobj.write("#!/bin/sh\n")
+                fobj.write("exec '%s' -c 'import sys; sys.exit(47)'\n" %
+                            sys.executable)
+            os.chmod(fname, 0o700)
             p = subprocess.Popen(fname)
             p.wait()
             os.remove(fname)
@@ -604,7 +629,7 @@
             p = subprocess.Popen(["echo $FRUIT"], shell=1,
                                  stdout=subprocess.PIPE,
                                  env=newenv)
-            self.assertEqual(p.stdout.read().strip(), "apple")
+            self.assertEqual(p.stdout.read().strip(b" \t\r\n\f"), b"apple")
 
         def test_shell_string(self):
             # Run command through the shell (string)
@@ -613,39 +638,21 @@
             p = subprocess.Popen("echo $FRUIT", shell=1,
                                  stdout=subprocess.PIPE,
                                  env=newenv)
-            self.assertEqual(p.stdout.read().strip(), "apple")
+            self.assertEqual(p.stdout.read().strip(b" \t\r\n\f"), b"apple")
 
         def test_call_string(self):
             # call() function with string argument on UNIX
-            f, fname = self.mkstemp()
-            os.write(f, "#!/bin/sh\n")
-            os.write(f, "exec '%s' -c 'import sys; sys.exit(47)'\n" %
-                        sys.executable)
-            os.close(f)
-            os.chmod(fname, 0700)
+            fd, fname = self.mkstemp()
+            # reopen in text mode
+            with open(fd, "w") as fobj:
+                fobj.write("#!/bin/sh\n")
+                fobj.write("exec '%s' -c 'import sys; sys.exit(47)'\n" %
+                            sys.executable)
+            os.chmod(fname, 0o700)
             rc = subprocess.call(fname)
             os.remove(fname)
             self.assertEqual(rc, 47)
 
-        def test_specific_shell(self):
-            # Issue #9265: Incorrect name passed as arg[0].
-            shells = []
-            for prefix in ['/bin', '/usr/bin/', '/usr/local/bin']:
-                for name in ['bash', 'ksh']:
-                    sh = os.path.join(prefix, name)
-                    if os.path.isfile(sh):
-                        shells.append(sh)
-            if not shells:  # Will probably work for any shell but csh.
-                return  # skip test
-            sh = '/bin/sh'
-            if os.path.isfile(sh) and not os.path.islink(sh):
-                # Test will fail if /bin/sh is a symlink to csh.
-                shells.append(sh)
-            for sh in shells:
-                p = subprocess.Popen("echo $0", executable=sh, shell=True,
-                                     stdout=subprocess.PIPE)
-                self.assertEqual(p.stdout.read().strip(), sh)
-
         def DISABLED_test_send_signal(self):
             p = subprocess.Popen([sys.executable,
                               "-c", "input()"])
@@ -723,7 +730,7 @@
             p = subprocess.Popen(["set"], shell=1,
                                  stdout=subprocess.PIPE,
                                  env=newenv)
-            self.assertNotEqual(p.stdout.read().find("physalis"), -1)
+            self.assertNotEqual(p.stdout.read().find(b"physalis"), -1)
 
         def test_shell_string(self):
             # Run command through the shell (string)
@@ -732,7 +739,7 @@
             p = subprocess.Popen("set", shell=1,
                                  stdout=subprocess.PIPE,
                                  env=newenv)
-            self.assertNotEqual(p.stdout.read().find("physalis"), -1)
+            self.assertNotEqual(p.stdout.read().find(b"physalis"), -1)
 
         def test_call_string(self):
             # call() function with string argument on Windows
@@ -764,32 +771,36 @@
             p.terminate()
             self.assertNotEqual(p.wait(), 0)
 
-class HelperFunctionTests(unittest.TestCase):
-    def _test_eintr_retry_call(self):
-        record_calls = []
-        def fake_os_func(*args):
-            record_calls.append(args)
-            if len(record_calls) == 2:
-                raise OSError(errno.EINTR, "fake interrupted system call")
-            return tuple(reversed(args))
-
-        self.assertEqual((999, 256),
-                         subprocess._eintr_retry_call(fake_os_func, 256, 999))
-        self.assertEqual([(256, 999)], record_calls)
-        # This time there will be an EINTR so it will loop once.
-        self.assertEqual((666,),
-                         subprocess._eintr_retry_call(fake_os_func, 666))
-        self.assertEqual([(256, 999), (666,), (666,)], record_calls)
-
-    if not mswindows:
-        test_eintr_retry_call = _test_eintr_retry_call
+class CommandTests(unittest.TestCase):
+# The module says:
+#   "NB This only works (and is only relevant) for UNIX."
+#
+# Actually, getoutput should work on any platform with an os.popen, but
+# I'll take the comment as given, and skip this suite.
+    if os.name == 'posix':
+
+        def test_getoutput(self):
+            self.assertEquals(subprocess.getoutput('echo xyzzy'), 'xyzzy')
+            self.assertEquals(subprocess.getstatusoutput('echo xyzzy'),
+                              (0, 'xyzzy'))
+
+            # we use mkdtemp in the next line to create an empty directory
+            # under our exclusive control; from that, we can invent a pathname
+            # that we _know_ won't exist.  This is guaranteed to fail.
+            dir = None
+            try:
+                dir = tempfile.mkdtemp()
+                name = os.path.join(dir, "foo")
 
+                status, output = subprocess.getstatusoutput('cat ' + name)
+                self.assertNotEquals(status, 0)
+            finally:
+                if dir is not None:
+                    os.rmdir(dir)
 
 def test_main():
-    test_support.run_unittest(ProcessTestCase,
-                              HelperFunctionTests)
-    if hasattr(test_support, "reap_children"):
-        test_support.reap_children()
+    support.run_unittest(ProcessTestCase, CommandTests)
+    support.reap_children()
 
 if __name__ == "__main__":
     test_main()
