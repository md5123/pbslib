Submitted By: Jim Gifford (jim at cross-lfs dot org)
Date: 05-17-2011
Initial Package Version: 7.3
Origin: Upstream
Upstream Status: Applied
Description: Contains all upstream patches up to 7.3.189

diff -Naur vim73.orig/Filelist vim73/Filelist
--- vim73.orig/Filelist	2010-08-07 11:04:57.000000000 +0000
+++ vim73/Filelist	2011-05-17 09:39:33.887666519 +0000
@@ -39,6 +39,7 @@
 		src/mark.c \
 		src/mbyte.c \
 		src/memfile.c \
+		src/memfile_test.c \
 		src/memline.c \
 		src/menu.c \
 		src/message.c \
@@ -427,8 +428,6 @@
 		README_os390.txt \
 		src/Make_mint.mak \
 		src/Make_ro.mak \
-		src/gui_riscos.c \
-		src/gui_riscos.h \
 		src/if_sniff.c \
 		src/infplist.xml \
 		src/link.390 \
@@ -436,10 +435,6 @@
 		src/os_beos.h \
 		src/os_beos.rsrc \
 		src/os_mint.h \
-		src/os_riscos.c \
-		src/os_riscos.h \
-		src/proto/gui_riscos.pro \
-		src/proto/os_riscos.pro \
 		src/os_vms_fix.com \
 		src/toolbar.phi \
 
@@ -686,6 +681,8 @@
 		runtime/tutor/tutor.utf-8 \
 		runtime/tutor/tutor.?? \
 		runtime/tutor/tutor.??.* \
+		runtime/tutor/tutor.bar \
+		runtime/tutor/tutor.bar.* \
 		runtime/spell/README.txt \
 		runtime/spell/??/*.diff \
 		runtime/spell/??/main.aap \
diff -Naur vim73.orig/Makefile vim73/Makefile
--- vim73.orig/Makefile	2010-08-15 12:23:34.000000000 +0000
+++ vim73/Makefile	2011-05-17 09:36:59.428809420 +0000
@@ -23,6 +23,9 @@
 # has run can result in compiling with $(CC) empty.
 
 first:
+	@if test ! -f src/auto/config.mk; then \
+		cp src/config.mk.dist src/auto/config.mk; \
+	fi
 	@echo "Starting make in the src directory."
 	@echo "If there are problems, cd to the src directory and run make there"
 	cd src && $(MAKE) $@
@@ -30,6 +33,9 @@
 # Some make programs use the last target for the $@ default; put the other
 # targets separately to always let $@ expand to "first" by default.
 all install uninstall tools config configure reconfig proto depend lint tags types test testclean clean distclean:
+	@if test ! -f src/auto/config.mk; then \
+		cp src/config.mk.dist src/auto/config.mk; \
+	fi
 	@echo "Starting make in the src directory."
 	@echo "If there are problems, cd to the src directory and run make there"
 	cd src && $(MAKE) $@
diff -Naur vim73.orig/runtime/doc/change.txt vim73/runtime/doc/change.txt
--- vim73.orig/runtime/doc/change.txt	2010-08-15 12:23:19.000000000 +0000
+++ vim73/runtime/doc/change.txt	2011-05-17 09:38:53.176184912 +0000
@@ -916,8 +916,10 @@
 {Visual}["x]Y		Yank the highlighted lines [into register x] (for
 			{Visual} see |Visual-mode|).  {not in Vi}
 
-							*:y* *:yank*
-:[range]y[ank] [x]	Yank [range] lines [into register x].
+							*:y* *:yank* *E850*
+:[range]y[ank] [x]	Yank [range] lines [into register x]. Yanking to the
+			"* or "+ registers is possible only in GUI versions or
+			when the |+xterm_clipboard| feature is included.
 
 :[range]y[ank] [x] {count}
 			Yank {count} lines, starting with last line number
diff -Naur vim73.orig/runtime/doc/eval.txt vim73/runtime/doc/eval.txt
--- vim73.orig/runtime/doc/eval.txt	2010-08-15 12:23:20.000000000 +0000
+++ vim73/runtime/doc/eval.txt	2011-05-17 09:33:49.093934743 +0000
@@ -1657,6 +1657,15 @@
 					*v:warningmsg* *warningmsg-variable*
 v:warningmsg	Last given warning message.  It's allowed to set this variable.
 
+					*v:windowid* *windowid-variable*
+v:windowid	When any X11 based GUI is running or when running in a
+		terminal and Vim connects to the X server (|-X|) this will be
+		set to the window ID.
+		When an MS-Windows GUI is running this will be set to the
+		window handle.
+		Otherwise the value is zero.
+		Note: for windows inside Vim use |winnr()|.
+
 ==============================================================================
 4. Builtin Functions					*functions*
 
@@ -1822,7 +1831,7 @@
 log( {expr})			Float	natural logarithm (base e) of {expr}
 log10( {expr})			Float	logarithm of Float {expr} to base 10
 map( {expr}, {string})		List/Dict  change each item in {expr} to {expr}
-maparg( {name}[, {mode} [, {abbr}]])
+maparg( {name}[, {mode} [, {abbr} [, {dict}]]])
 				String	rhs of mapping {name} in mode {mode}
 mapcheck( {name}[, {mode} [, {abbr}]])
 				String	check for mappings matching {name}
@@ -3966,23 +3975,51 @@
 		further items in {expr} are processed.
 
 
-maparg({name}[, {mode} [, {abbr}]])			*maparg()*
-		Return the rhs of mapping {name} in mode {mode}.  When there
-		is no mapping for {name}, an empty String is returned.
+maparg({name}[, {mode} [, {abbr} [, {dict}]]])			*maparg()*
+		When {dict} is omitted or zero: Return the rhs of mapping
+		{name} in mode {mode}.  The returned String has special
+		characters translated like in the output of the ":map" command
+		listing.
+		
+		When there is no mapping for {name}, an empty String is
+		returned.
+
+		The {name} can have special key names, like in the ":map"
+		command.
+
 		{mode} can be one of these strings:
 			"n"	Normal
-			"v"	Visual
+			"v"	Visual (including Select)
 			"o"	Operator-pending
 			"i"	Insert
 			"c"	Cmd-line
+			"s"	Select
+			"x"	Visual
 			"l"	langmap |language-mapping|
 			""	Normal, Visual and Operator-pending
 		When {mode} is omitted, the modes for "" are used.
+
 		When {abbr} is there and it is non-zero use abbreviations
 		instead of mappings.
-		The {name} can have special key names, like in the ":map"
-		command.  The returned String has special characters
-		translated like in the output of the ":map" command listing.
+
+		When {dict} is there and it is non-zero return a dictionary
+		containing all the information of the mapping with the
+		following items:
+		  "lhs"	     The {lhs} of the mapping.
+		  "rhs"	     The {rhs} of the mapping as typed.
+		  "silent"   1 for a |:map-silent| mapping, else 0.
+		  "noremap"  1 if the {rhs} of the mapping is remappable.
+		  "expr"     1 for an expression mapping (|:map-<expr>|).
+		  "buffer"   1 for a buffer local mapping (|:map-local|).
+		  "mode"     Modes for which the mapping is defined. In
+			     addition to the modes mentioned above, these
+			     characters will be used:
+			     " "     Normal, Visual and Operator-pending
+			     "!"     Insert and Commandline mode
+				     (|mapmpde-ic|)
+		  "sid"	     the Script local ID, used for <sid> mappings
+			     (|<SID>|)
+
 		The mappings local to the current buffer are checked first,
 		then the global mappings.
 		This function can be used to map a key even when it's already
diff -Naur vim73.orig/runtime/doc/netbeans.txt vim73/runtime/doc/netbeans.txt
--- vim73.orig/runtime/doc/netbeans.txt	2010-08-15 12:23:21.000000000 +0000
+++ vim73/runtime/doc/netbeans.txt	2011-05-17 09:32:59.459443811 +0000
@@ -1,4 +1,4 @@
-*netbeans.txt*  For Vim version 7.3.  Last change: 2010 Jul 20
+*netbeans.txt*  For Vim version 7.3.  Last change: 2010 Aug 20
 
 
 		  VIM REFERENCE MANUAL    by Gordon Prieur et al.
@@ -118,7 +118,8 @@
 uncommenting a line with "--disable-netbeans" in the Makefile.
 
 Currently the NetBeans interface is supported by Vim running in a terminal and
-by GVim when it is run with one of the following GUIs: GTK, GNOME, and Motif.
+by GVim when it is run with one of the following GUIs: GTK, GNOME, Windows,
+Athena and Motif.
 
 If Motif support is required the user must supply XPM libraries.  See
 |workshop-xpm| for details on obtaining the latest version of XPM.
diff -Naur vim73.orig/runtime/doc/options.txt vim73/runtime/doc/options.txt
--- vim73.orig/runtime/doc/options.txt	2010-08-15 12:23:21.000000000 +0000
+++ vim73/runtime/doc/options.txt	2011-05-17 09:37:43.251945581 +0000
@@ -150,6 +150,18 @@
 (the ^[ is a real <Esc> here, use CTRL-V <Esc> to enter it)
 The advantage over a mapping is that it works in all situations.
 
+You can define any key codes, e.g.: >
+	:set t_xy=^[foo;
+There is no warning for using a name that isn't recognized.  You can map these
+codes as you like: >
+	:map <t_xy> something
+<								*E846*
+When a key code is not set, it's like it does not exist.  Trying to get its
+value will result in an error: >
+	:set t_kb=
+	:set t_kb
+	E846: Key code not set: t_kb
+
 The t_xx options cannot be set from a |modeline| or in the |sandbox|, for
 security reasons.
 
@@ -1434,6 +1446,15 @@
 			explicitly accessed using the "* notation.  Also see
 			|gui-clipboard|.
 
+	unnamedplus	A variant of "unnamed" flag which uses the clipboard
+			register '+' (|quoteplus|) instead of register '*' for
+			all operations except yank.  Yank shall copy the text
+			into register '+' and also into '*' when "unnamed" is
+			included.
+			Only available with the |+x11| feature.
+			Availability can be checked with: >
+				if has('unnamedplus')
+<
 	autoselect	Works like the 'a' flag in 'guioptions': If present,
 			then whenever Visual mode is started, or the Visual
 			area extended, Vim tries to become the owner of the
@@ -7530,8 +7551,9 @@
 	!	When included, save and restore global variables that start
 		with an uppercase letter, and don't contain a lowercase
 		letter.  Thus "KEEPTHIS and "K_L_M" are stored, but "KeepThis"
-		and "_K_L_M" are not.  Only String and Number types are
-		stored.
+		and "_K_L_M" are not.  Nested List and Dict items may not be
+		read back correctly, you end up with a string representation
+		instead.
 	"	Maximum number of lines saved for each register.  Old name of
 		the '<' item, with the disadvantage that you need to put a
 		backslash before the ", otherwise it will be recognized as the
@@ -7747,6 +7769,17 @@
 	a pattern from the list.  This avoids problems when a future version
 	uses another default.
 
+
+			*'wildignorecase* *'wic'* *'nowildignorecase* *'nowic'*
+'wildignorecase' 'wic'	boolean	(default off)
+			global
+			{not in Vi}
+	When set case is ignored when completing file names and directories.
+	Has no effect on systems where file name case is generally ignored.
+	Does not apply when the shell is used to expand wildcards, which
+	happens when there are special characters.
+
+
 				*'wildmenu'* *'wmnu'* *'nowildmenu'* *'nowmnu'*
 'wildmenu' 'wmnu'	boolean	(default off)
 			global
diff -Naur vim73.orig/runtime/doc/os_risc.txt vim73/runtime/doc/os_risc.txt
--- vim73.orig/runtime/doc/os_risc.txt	2010-08-15 12:23:21.000000000 +0000
+++ vim73/runtime/doc/os_risc.txt	2011-05-17 09:39:31.635916429 +0000
@@ -1,322 +1,12 @@
-*os_risc.txt*   For Vim version 7.3.  Last change: 2010 Aug 07
+*os_risc.txt*   For Vim version 7.3.  Last change: 2011 May 10
 
 
 		  VIM REFERENCE MANUAL    by Thomas Leonard
 
 
 						*riscos* *RISCOS* *RISC-OS*
-This file contains the particularities for the RISC OS version of Vim.
+The RISC OS support has been removed from Vim with patch 7.3.187.
+If you would like to use Vim on RISC OS get the files from before that patch.
 
-The RISC OS port is a completely new port and is not based on the old "archi"
-port.
 
-1.  File locations		|riscos-locations|
-2.  Filename munging		|riscos-munging|
-3.  Command-line use		|riscos-commandline|
-4.  Desktop (GUI) use		|riscos-gui|
-5.  Remote use (telnet)		|riscos-remote|
-6.  Temporary files		|riscos-temp-files|
-7.  Interrupting		|riscos-interrupt|
-8.  Memory usage		|riscos-memory|
-9.  Filetypes			|riscos-filetypes|
-10. The shell			|riscos-shell|
-11. Porting new releases	|riscos-porting|
-
-If I've missed anything, email me and I'll try to fix it.  In fact, even if I
-haven't missed anything then email me anyway to give me some confidence that it
-actually works!
-
-Thomas Leonard <tal197@ecs.soton.ac.uk>
-
-	[these URLs no longer work...]
- Port homepage:	http://www.ecs.soton.ac.uk/~tal197/
-	or try:	http://www.soton.ac.uk/~tal197/
-
-==============================================================================
-							*riscos-locations*
-1. File locations
-
-The Vim executable and shared resource files are all stored inside the !Vim
-application directory.
-
-When !Vim is first seen by the filer, it aliases the *vi and *ex commands to
-run the command-line versions of Vim (see |riscos-commandline|).
-
-!Vim.Resources and !Vim.Resources2 contain the files from the standard Vim
-distribution, but modified slightly to work within the limits of ADFS, plus
-some extra files such as the window templates.
-
-User choices are read from "Choices:*" and are saved to "<Choices$Write>.*".
-If you have the new !Boot structure then these should be set up already.  If
-not, set Choices$Path to a list of directories to search when looking for
-user configuration files.  Set Choices$Write to the directory you want files
-to be saved into (so your search patterns and marks can be remembered between
-sessions).
-
-==============================================================================
-							*riscos-munging*
-2. Filename munging
-
-All pathname munging is disabled by default, so Vim should behave like a
-normal RISC OS application now.  So, if you want to edit "doc/html" then you
-actually type "*vi doc/html".
-
-The only times munging is done is when:
-
-- Searching included files from C programs, since these are always munged.
-  See |[I|.
-  Note: make sure you are in the right directory when you use this
-	command (i.e. the one with subdirectories "c" and "h").
-
-- Sourcing files using |:so|.
-  Paths starting "$VIM/" are munged like this:
-
-  $VIM/syntax/help.vim  ->  Vim:syntax.help
-
-  Also, files ending in ".vim" have their extensions removed, and slashes
-  replaced with dots.
-
-Some tag files and script files may have to be edited to work under this port.
-
-==============================================================================
-							*riscos-commandline*
-3. Command-line use
-
-To use Vim from the command-line use the "*vi" command (or "*ex" for
-|Ex-mode|).
-
-Type "*vi -h" for a list of options.
-
-Running the command-line version of Vim in a large high-color mode may cause
-the scrolling to be very slow.  Either change to a mode with fewer colors or
-use the GUI version.
-
-Also, holding down Ctrl will slow it down even more, and Ctrl-Shift will
-freeze it, as usual for text programs.
-
-==============================================================================
-							*riscos-gui*
-4. Desktop use
-
-Limitations:
-
-- Left scrollbars don't work properly (right and bottom are fine).
-- Doesn't increase scroll speed if it gets behind.
-
-You can resize the window by dragging the lower-right corner, even though
-there is no icon shown there.
-
-You can use the --rows and --columns arguments to specify the initial size of
-the Vim window, like this: >
-
-  *Vi -g --rows 20 --columns 80
-
-The global clipboard is supported, so you can select some text and then
-paste it directly into another application (provided it supports the
-clipboard too).
-
-Clicking Menu now opens a menu like a normal RISC OS program.  Hold down Shift
-when clicking Menu to paste (from the global clipboard).
-
-Dragging a file to the window replaces the CURRENT buffer (the one with the
-cursor, NOT the one you dragged to) with the file.
-
-Dragging with Ctrl held down causes a new Vim window to be opened for the
-file (see |:sp|).
-
-Dragging a file in with Shift held down in insert mode inserts the pathname of
-the file.
-
-:browse :w opens a standard RISC OS save box.
-:browse :e opens a directory viewer.
-
-For fonts, you have the choice of the system font, an outline font, the system
-font via ZapRedraw and any of the Zap fonts via ZapRedraw: >
-
-  :set guifont=
-<			To use the system font via the VDU drivers.  Supports
-			bold and underline.
->
-  :set guifont=Corpus.Medium
-<			Use the named outline font.  You can use any font, but
-			only monospaced ones like Corpus look right.
->
-  :set guifont=Corpus.Medium:w8:h12:b:i
-<			As before, but with size of 8 point by 12 point, and
-			in bold italic.
-			If only one of width and height is given then that
-			value is used for both.  If neither is given then 10
-			point is used.
-
-Thanks to John Kortink, Vim can use the ZapRedraw module.  Start the font name
-with "!" (or "!!" for double height), like this: >
-
-  :set guifont=!!
-<			Use the system font, but via ZapRedraw.  This gives a
-			faster redraw on StrongARM processors, but you can't
-			get bold or italic text.  Double height.
->
-  :set guifont=!script
-<			Uses the named Zap font (a directory in VimFont$Path).
-			The redraw is the same speed as for "!!", but you get
-			a nicer looking font.
-			Only the "man+" and "script" fonts are supplied
-			currently, but you can use any of the Zap fonts if
-			they are in VimFont$Path.
-			Vim will try to load font files "0", "B", "I" and "IB"
-			from the named directory.  Only "0" (normal style) MUST
-			be present.  Link files are not currently supported.
-
-Note that when using ZapRedraw the edit bar is drawn in front of the character
-you are on rather than behind it.  Also redraw is incorrect for screen modes
-with eigen values of 0.  If the font includes control characters then you can
-get Vim to display them by changing the 'isprint' option.
-
-If you find the scrolling is too slow on your machine, try experimenting
-with the 'scrolljump' and 'ttyscroll' options.
-
-In particular, StrongARM users may find that: >
-
-  :set ttyscroll=0
-
-makes scrolling faster in high-color modes.
-
-=============================================================================
-							*riscos-remote*
-5. Remote use (telnet)
-
-I have included a built-in termcap entry, but you can edit the termcap file to
-allow other codes to be used if you want to use Vim from a remote terminal.
-
-Although I do not have an internet connection to my Acorn, I have managed to
-run Vim in a FreeTerm window using the loopback connection.
-
-It seems to work pretty well now, using "*vi -T ansi".
-
-==============================================================================
-							*riscos-temp-files*
-6. Temporary files
-
-If Vim crashes then the swap and backup files (if any) will be in the
-directories set with the 'directory' and 'bdir' options.  By default the swap
-files are in <Wimp$ScrapDir> (i.e. inside !Scrap) and backups are in the
-directory you were saving to.  Vim will allow you to try and recover the file
-when you next try to edit it.
-
-To see a list of swap files, press <F12> and type "*vi -r".
-
-Vim no longer brings up ATTENTION warnings if you try to edit two files with
-the same name in different directories.
-
-However, it also no longer warns if you try to edit the same file twice (with
-two copies of Vim), though you will still be warned when you save that the
-datestamp has changed.
-
-==============================================================================
-							*riscos-interrupt*
-7. Interrupting
-
-To break out of a looping macro, or similar, hold down Escape in the
-command-line version, or press CTRL-C in the GUI version.
-
-==============================================================================
-							*riscos-memory*
-8. Memory usage
-
-Vim will use dynamic areas on RISC OS 3.5 or later.  If you can use them on
-older machines then edit the !RunTxt and GVim files.  I don't know what UnixLib
-does by default on these machines so I'm playing safe.
-
-It doesn't work at all well without dynamic areas, since it can't change its
-memory allocation once running.  Hence you should edit "!Vim.GVim" and
-"!Vim.!RunTxt" to choose the best size for you.  You probably need at least
-about 1400K.
-
-==============================================================================
-							*riscos-filetypes*
-9. Filetypes
-
-You can now specify that autocommands are only executed for files of certain
-types.  The filetype is given in the form &xxx, when xxx is the filetype.
-
-Filetypes must be specified by number (e.g. &fff for Text).
-
-The system has changed from version 5.3.  The new sequence of events is:
-
-- A file is loaded. |'osfiletype'| is set to the RISC OS filetype.
-- Based on the filetype and pathname, Vim will try to set |'filetype'| to the
-  Vim-type of the file.
-- Setting this option may load syntax files and perform other actions.
-- Saving the file will give it a filetype of |'osfiletype'|.
-
-Some examples may make this clearer:
-
-  Kind of file loaded	osfiletype	filetype ~
-  C code "c.hellow"	Text (&fff)	C
-  LaTeX document	LaTeX (&2a8)	TeX
-  Draw document		DrawFile (&aff)	(not changed)
-
-==============================================================================
-							*riscos-shell*
-10. The shell
-
-- Bangs (!s) are only replaced if they are followed by a space or end-of-line,
-  since many pathnames contain them.
-
-- You can prefix the command with "~", which stops any output from being
-  displayed.  This also means that you don't have to press <Enter> afterwards,
-  and stops the screen from being redrawn. {only in the GUI version}
-
-==============================================================================
-							*riscos-porting*
-11. Porting new releases to RISC OS
-
-Downloading everything you need:
-
-- Get the latest source distribution (see www.vim.org)
-- Get the runtime environment files (e.g. these help files)
-- Get the RISC OS binary distribution (if possible)
-
-
-Unarchiving:
-
-- Create a raFS disk and put the archives on it
-- Un-gzip them
-- Un-tar them   (*tar xELf 50 archive/tar)
-
-
-Recompiling the sources:
-
-- Create c, s, and h directories.
-- Put all the header files in "h".	     \
-- Put all the C files in "c".		     | And lose the extensions
-- Put the assembler file ("swis/s") in "s".  /
-- Rename all the files in "proto" to "h", like this:
-    raFS::VimSrc.source.proto.file/pro
-	  becomes
-    raFS::VimSrc.source.h.file_pro
-- In the files "h.proto" and "c.termlib", search and replace
-    .pro"
-       with
-    _pro.h"
-- Create a simple Makefile if desired and do "*make -k".
-  Use "CC = gcc -DRISCOS -DUSE_GUI -O2 -x c" in the Makefile.
-- Save the binary as !Vim.Vim in the binary distribution.
-
-
-Updating the run-time environment:
-
-- Replace old or missing files inside !Vim.Resources with the
-  new files.
-- Remove files in "doc" not ending in "/txt", except for "tags".
-- Lose the extensions from the files in "doc".
-- Edit the "doc.tags" file.  Remove extensions from the second column: >
-	:%s/^\(.[^\t]*\t.*\)\.txt\t/\1\t/
-- Remove extensions from the syntax files.  Split them into two directories
-  to avoid the 77 entry limit on old ADFS filesystems.
-- Edit "Vim:FileType" to match "*.c.*" as well as "*/c" and so on.
-  Add filetype checking too.
-- Edit "Vim:Menu" and remove all the keys from the menus: >
-	:%s/<Tab>[^ \t]*//
-<
  vim:tw=78:ts=8:ft=help:norl:
diff -Naur vim73.orig/src/GvimExt/Make_ming.mak vim73/src/GvimExt/Make_ming.mak
--- vim73.orig/src/GvimExt/Make_ming.mak	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/GvimExt/Make_ming.mak	2011-05-17 09:35:53.956076175 +0000
@@ -17,6 +17,17 @@
 # check also the executables
 MINGWOLD = no
 
+# Link against the shared versions of libgcc/libstdc++ by default.  Set
+# STATIC_STDCPLUS to "yes" to link against static versions instead.
+STATIC_STDCPLUS=no
+#STATIC_STDCPLUS=yes
+
+# Note: -static-libstdc++ is not available until gcc 4.5.x.
+LDFLAGS += -shared
+ifeq (yes, $(STATIC_STDCPLUS))
+LDFLAGS += -static-libgcc -static-libstdc++
+endif
+
 ifeq ($(CROSS),yes)
 DEL = rm
 ifeq ($(MINGWOLD),yes)
@@ -34,6 +45,8 @@
 endif
 CXX := $(CROSS_COMPILE)g++
 WINDRES := $(CROSS_COMPILE)windres
+WINDRES_CXX = $(CXX)
+WINDRES_FLAGS = --preprocessor="$(WINDRES_CXX) -E -xc" -DRC_INVOKED
 LIBS :=  -luuid
 RES  := gvimext.res
 DEFFILE = gvimext_ming.def
@@ -46,7 +59,7 @@
 all: all-before $(DLL) all-after
 
 $(DLL): $(OBJ) $(RES) $(DEFFILE)
-	$(CXX) -shared $(CXXFLAGS) -s -o $@ \
+	$(CXX) $(LDFLAGS) $(CXXFLAGS) -s -o $@ \
 		-Wl,--enable-auto-image-base \
 		-Wl,--enable-auto-import \
 		-Wl,--whole-archive \
@@ -58,7 +71,7 @@
 	$(CXX) $(CXXFLAGS) -DFEAT_GETTEXT -c $? -o $@
 
 $(RES): gvimext_ming.rc
-	$(WINDRES) --input-format=rc --output-format=coff -DMING $? -o $@
+	$(WINDRES) $(WINDRES_FLAGS) --input-format=rc --output-format=coff -DMING $? -o $@
 
 clean: clean-custom
 	-$(DEL)  $(OBJ) $(RES) $(DLL)
diff -Naur vim73.orig/src/Make_cyg.mak vim73/src/Make_cyg.mak
--- vim73.orig/src/Make_cyg.mak	2010-08-02 19:09:22.000000000 +0000
+++ vim73/src/Make_cyg.mak	2011-05-17 09:34:14.927067473 +0000
@@ -1,6 +1,6 @@
 #
 # Makefile for VIM on Win32, using Cygnus gcc
-# Last updated by Dan Sharp.  Last Change: 2010 Feb 24
+# Last updated by Dan Sharp.  Last Change: 2010 Nov 03
 #
 # Also read INSTALLpc.txt!
 #
@@ -27,6 +27,7 @@
 #   MZSCHEME_VER      define to version of MzScheme being used (209_000)
 #   DYNAMIC_MZSCHEME  no or yes: use yes to load the MzScheme DLLs dynamically (yes)
 #   MZSCHEME_DLLS     path to MzScheme DLLs (libmzgc and libmzsch), for "static" build.
+#   MZSCHEME_USE_RACKET  define to use "racket" instead of "mzsch".
 # LUA	define to path to Lua dir to get Lua support (not defined)
 #   LUA_VER	    define to version of Lua being used (51)
 #   DYNAMIC_LUA  no or yes: use yes to load the Lua DLL dynamically (yes)
@@ -254,16 +255,22 @@
 MZSCHEME_GENERATE_BASE=no
 endif
 
+ifndef MZSCHEME_USE_RACKET
+MZSCHEME_MAIN_LIB=mzsch
+else
+MZSCHEME_MAIN_LIB=racket
+endif
+
 ifeq (yes, $(DYNAMIC_MZSCHEME))
-DEFINES += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
+DEFINES += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
 else
 ifndef MZSCHEME_DLLS
 MZSCHEME_DLLS = $(MZSCHEME)
 endif
 ifeq (yes,$(MZSCHEME_PRECISE_GC))
-MZSCHEME_LIB=-lmzsch$(MZSCHEME_VER)
+MZSCHEME_LIB=-l$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER)
 else
-MZSCHEME_LIB = -lmzsch$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
+MZSCHEME_LIB = -l$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
 endif
 EXTRA_LIBS += -L$(MZSCHEME_DLLS) -L$(MZSCHEME_DLLS)/lib $(MZSCHEME_LIB)
 endif
diff -Naur vim73.orig/src/Make_ming.mak vim73/src/Make_ming.mak
--- vim73.orig/src/Make_ming.mak	2010-08-02 19:09:43.000000000 +0000
+++ vim73/src/Make_ming.mak	2011-05-17 09:35:53.956076175 +0000
@@ -56,6 +56,12 @@
 NETBEANS=$(GUI)
 
 
+# Link against the shared version of libstdc++ by default.  Set
+# STATIC_STDCPLUS to "yes" to link against static version instead.
+ifndef STATIC_STDCPLUS
+STATIC_STDCPLUS=no
+endif
+
 # If the user doesn't want gettext, undefine it.
 ifeq (no, $(GETTEXT))
 GETTEXT=
@@ -141,11 +147,17 @@
 MZSCHEME_GENERATE_BASE=no
 endif
 
+ifndef MZSCHEME_USE_RACKET
+MZSCHEME_MAIN_LIB=mzsch
+else
+MZSCHEME_MAIN_LIB=racket
+endif
+
 ifeq (no,$(DYNAMIC_MZSCHEME))
 ifeq (yes,$(MZSCHEME_PRECISE_GC))
-MZSCHEME_LIB=-lmzsch$(MZSCHEME_VER)
+MZSCHEME_LIB=-l$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER)
 else
-MZSCHEME_LIB = -lmzsch$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
+MZSCHEME_LIB = -l$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER) -lmzgc$(MZSCHEME_VER)
 endif
 # the modern MinGW can dynamically link to dlls directly.
 # point MZSCHEME_DLLS to where you put libmzschXXXXXXX.dll and libgcXXXXXXX.dll
@@ -304,11 +316,13 @@
 endif
 CC := $(CROSS_COMPILE)gcc
 WINDRES := $(CROSS_COMPILE)windres
+WINDRES_CC = $(CC)
 
 #>>>>> end of choices
 ###########################################################################
 
 CFLAGS = -Iproto $(DEFINES) -pipe -w -march=$(ARCH) -Wall
+WINDRES_FLAGS = --preprocessor="$(WINDRES_CC) -E -xc" -DRC_INVOKED
 
 ifdef GETTEXT
 DEFINES += -DHAVE_GETTEXT -DHAVE_LOCALE_H
@@ -343,7 +357,7 @@
 ifdef MZSCHEME
 CFLAGS += -I$(MZSCHEME)/include -DFEAT_MZSCHEME -DMZSCHEME_COLLECTS=\"$(MZSCHEME)/collects\"
 ifeq (yes, $(DYNAMIC_MZSCHEME))
-CFLAGS += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
+CFLAGS += -DDYNAMIC_MZSCHEME -DDYNAMIC_MZSCH_DLL=\"lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).dll\" -DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
 endif
 endif
 
@@ -571,8 +585,13 @@
 endif
 
 ifeq (yes, $(OLE))
-LIB += -loleaut32 -lstdc++
+LIB += -loleaut32
 OBJ += $(OUTDIR)/if_ole.o
+ifeq (yes, $(STATIC_STDCPLUS))
+LIB += -Wl,-Bstatic -lstdc++ -Wl,-Bdynamic
+else
+LIB += -lstdc++
+endif
 endif
 
 ifeq (yes, $(MBYTE))
@@ -650,10 +669,10 @@
 	$(CC) -c $(CFLAGS) $< -o $@
 
 $(OUTDIR)/vimres.res: vim.rc version.h gui_w32_rc.h
-	$(WINDRES) $(DEFINES) vim.rc $(OUTDIR)/vimres.res
+	$(WINDRES) $(WINDRES_FLAGS) $(DEFINES) vim.rc $(OUTDIR)/vimres.res
 
 $(OUTDIR)/vimrc.o: $(OUTDIR)/vimres.res
-	$(WINDRES) $(OUTDIR)/vimres.res $(OUTDIR)/vimrc.o
+	$(WINDRES) $(WINDRES_FLAGS) $(OUTDIR)/vimres.res $(OUTDIR)/vimrc.o
 
 $(OUTDIR):
 	$(MKDIR) $(OUTDIR)
diff -Naur vim73.orig/src/Make_mvc.mak vim73/src/Make_mvc.mak
--- vim73.orig/src/Make_mvc.mak	2010-07-18 19:24:20.000000000 +0000
+++ vim73/src/Make_mvc.mak	2011-05-17 09:37:06.132065436 +0000
@@ -380,9 +380,6 @@
 !if "$(_NMAKE_VER)" == "10.00.30319.01"
 MSVCVER = 10.0
 !endif
-!if "$(_NMAKE_VER)" == "9.00.30729.01"
-MSVCVER = 9.0
-!endif
 !endif
 
 # Abort bulding VIM if version of VC is unrecognised.
@@ -705,12 +702,18 @@
 MZSCHEME_VER = 205_000
 !endif
 CFLAGS = $(CFLAGS) -DFEAT_MZSCHEME -I $(MZSCHEME)\include
-!if EXIST("$(MZSCHEME)\collects\scheme\base.ss")
-# for MzScheme 4.x we need to include byte code for basic Scheme stuff
+!if EXIST("$(MZSCHEME)\collects\scheme\base.ss") \
+	|| EXIST("$(MZSCHEME)\collects\scheme\base.rkt") 
+# for MzScheme >= 4 we need to include byte code for basic Scheme stuff
 MZSCHEME_EXTRA_DEP = mzscheme_base.c
 CFLAGS = $(CFLAGS) -DINCLUDE_MZSCHEME_BASE
 !endif
-!if EXIST("$(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib") \
+!if EXIST("$(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib")
+MZSCHEME_MAIN_LIB=mzsch
+!else
+MZSCHEME_MAIN_LIB=racket
+!endif
+!if EXIST("$(MZSCHEME)\lib\msvc\lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).lib") \
 	&& !EXIST("$(MZSCHEME)\lib\msvc\libmzgc$(MZSCHEME_VER).lib")
 !message Building with Precise GC
 MZSCHEME_PRECISE_GC = yes
@@ -722,7 +725,7 @@
 !endif
 !message MzScheme DLLs will be loaded dynamically
 CFLAGS = $(CFLAGS) -DDYNAMIC_MZSCHEME \
-		-DDYNAMIC_MZSCH_DLL=\"libmzsch$(MZSCHEME_VER).dll\" \
+		-DDYNAMIC_MZSCH_DLL=\"lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).dll\" \
 		-DDYNAMIC_MZGC_DLL=\"libmzgc$(MZSCHEME_VER).dll\"
 !else
 !if "$(MZSCHEME_DEBUG)" == "yes"
@@ -730,10 +733,10 @@
 !endif
 !if "$(MZSCHEME_PRECISE_GC)" == "yes"
 # Precise GC does not use separate dll
-MZSCHEME_LIB = $(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib
+MZSCHEME_LIB = $(MZSCHEME)\lib\msvc\lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).lib
 !else
 MZSCHEME_LIB = $(MZSCHEME)\lib\msvc\libmzgc$(MZSCHEME_VER).lib \
-		$(MZSCHEME)\lib\msvc\libmzsch$(MZSCHEME_VER).lib
+		$(MZSCHEME)\lib\msvc\lib$(MZSCHEME_MAIN_LIB)$(MZSCHEME_VER).lib
 !endif
 !endif
 MZSCHEME_OBJ = $(OUTDIR)\if_mzsch.obj
@@ -1156,6 +1159,10 @@
 E0_CFLAGS = $(CFLAGS:\=\\)
 E_CFLAGS = $(E0_CFLAGS:"=\")
 # ") stop the string
+# $LINKARGS2 may contain backslashes and double quotes, escape them both.
+E0_LINKARGS2 = $(LINKARGS2:\=\\)
+E_LINKARGS2 = $(E0_LINKARGS2:"=\")
+# ") stop the string
 
 $(PATHDEF_SRC): auto
 	@echo creating $(PATHDEF_SRC)
@@ -1164,7 +1171,7 @@
 	@echo char_u *default_vim_dir = (char_u *)"$(VIMRCLOC:\=\\)"; >> $(PATHDEF_SRC)
 	@echo char_u *default_vimruntime_dir = (char_u *)"$(VIMRUNTIMEDIR:\=\\)"; >> $(PATHDEF_SRC)
 	@echo char_u *all_cflags = (char_u *)"$(CC:\=\\) $(E_CFLAGS)"; >> $(PATHDEF_SRC)
-	@echo char_u *all_lflags = (char_u *)"$(link:\=\\) $(LINKARGS1:\=\\) $(LINKARGS2:\=\\)"; >> $(PATHDEF_SRC)
+	@echo char_u *all_lflags = (char_u *)"$(link:\=\\) $(LINKARGS1:\=\\) $(E_LINKARGS2)"; >> $(PATHDEF_SRC)
 	@echo char_u *compiled_user = (char_u *)"$(USERNAME)"; >> $(PATHDEF_SRC)
 	@echo char_u *compiled_sys = (char_u *)"$(USERDOMAIN)"; >> $(PATHDEF_SRC)
 
diff -Naur vim73.orig/src/Makefile vim73/src/Makefile
--- vim73.orig/src/Makefile	2010-08-15 12:56:15.000000000 +0000
+++ vim73/src/Makefile	2011-05-17 09:37:56.858435432 +0000
@@ -283,12 +283,13 @@
 
 ######################## auto/config.mk ######################## {{{1
 # At this position auto/config.mk is included. When starting from the
-# distribution it is almost empty. After running auto/configure it contains
-# settings that have been discovered for your system. Settings below this
-# include override settings in auto/config.mk!
-
-# Note: if auto/config.mk is lost somehow (e.g., because configure was
-# interrupted), create an empty auto/config.mk file and do "make config".
+# toplevel Makefile it is almost empty. After running auto/configure it
+# contains settings that have been discovered for your system. Settings below
+# this include override settings in auto/config.mk!
+
+# Note: If make fails because auto/config.mk does not exist (it is not
+# included in the repository), do:
+#    cp config.mk.dist auto/config.mk
 
 # (X) How to include auto/config.mk depends on the version of "make" you have,
 #     if the current choice doesn't work, try the other one.
@@ -414,12 +415,16 @@
 # However, this may still cause problems, such as "import termios" failing.
 # Build two separate versions of Vim in that case.
 #CONF_OPT_PYTHON = --enable-pythoninterp
+#CONF_OPT_PYTHON = --enable-pythoninterp=dynamic
 #CONF_OPT_PYTHON3 = --enable-python3interp
+#CONF_OPT_PYTHON3 = --enable-python3interp=dynamic
 
 # RUBY
 # Uncomment this when you want to include the Ruby interface.
+# First one for static linking, second one for loading when used.
 # Note: you need the development package (e.g., ruby1.9.1-dev on Ubuntu).
 #CONF_OPT_RUBY = --enable-rubyinterp
+#CONF_OPT_RUBY = --enable-rubyinterp=dynamic
 #CONF_OPT_RUBY = --enable-rubyinterp --with-ruby-command=ruby1.9.1
 
 # TCL
@@ -556,7 +561,7 @@
 #CFLAGS = -g -O2 '-DSTARTUPTIME="vimstartup"' -fno-strength-reduce -Wall -Wmissing-prototypes
 
 # Use this with GCC to check for mistakes, unused arguments, etc.
-#CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code -D_FORTIFY_SOURCE=1 -DU_DEBUG
+#CFLAGS = -g -Wall -Wextra -Wmissing-prototypes -Wunreachable-code -D_FORTIFY_SOURCE=1
 #CFLAGS = -g -O2 -Wall -Wextra -Wmissing-prototypes -D_FORTIFY_SOURCE=1 -DU_DEBUG
 #PYTHON_CFLAGS_EXTRA = -Wno-missing-field-initializers
 #MZSCHEME_CFLAGS_EXTRA = -Wno-unreachable-code -Wno-unused-parameter
@@ -589,8 +594,9 @@
 
 # PROFILING - Uncomment the next two lines to do profiling with gcc and gprof.
 # Might not work with GUI or Perl.
-# For unknown reasons adding "-lc" fixes a linking problem with GCC.  That's
-# probably a bug in the "-pg" implementation.
+# For unknown reasons adding "-lc" fixes a linking problem with some versions
+# of GCC.  That's probably a bug in the "-pg" implementation.
+# After running Vim see the profile result with: gmon vim gmon.out | vim -
 # Need to recompile everything after changing this: "make clean" "make".
 #PROFILE_CFLAGS = -pg -g -DWE_ARE_PROFILING
 #PROFILE_LIBS = -pg
@@ -601,8 +607,8 @@
 # Configuration is in the .ccmalloc or ~/.ccmalloc file.
 # Doesn't work very well, since memory linked to from global variables
 # (in libraries) is also marked as leaked memory.
-#PROFILE_CFLAGS = -DEXITFREE
-#PROFILE_LIBS = -lccmalloc
+#LEAK_CFLAGS = -DEXITFREE
+#LEAK_LIBS = -lccmalloc
 
 #####################################################
 ###  Specific systems, check if yours is listed!  ### {{{
@@ -1047,8 +1053,9 @@
 INSTALL_DATA	= cp
 INSTALL_DATA_R	= cp -r
 
-### Program to run on installed binary
+### Program to run on installed binary.  Use the second one to disable strip.
 #STRIP = strip
+#STRIP = /bin/true
 
 ### Permissions for binaries  {{{1
 BINMOD = 755
@@ -1321,15 +1328,15 @@
 .SUFFIXES: .c .o .pro
 
 PRE_DEFS = -Iproto $(DEFS) $(GUI_DEFS) $(GUI_IPATH) $(CPPFLAGS) $(EXTRA_IPATHS)
-POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(TCL_CFLAGS) $(RUBY_CFLAGS) $(EXTRA_DEFS)
+POST_DEFS = $(X_CFLAGS) $(MZSCHEME_CFLAGS) $(TCL_CFLAGS) $(EXTRA_DEFS)
 
-ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(POST_DEFS)
+ALL_CFLAGS = $(PRE_DEFS) $(CFLAGS) $(PROFILE_CFLAGS) $(LEAK_CFLAGS) $(POST_DEFS)
 
 # Exclude $CFLAGS for osdef.sh, for Mac 10.4 some flags don't work together
 # with "-E".
 OSDEF_CFLAGS = $(PRE_DEFS) $(POST_DEFS)
 
-LINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) -Dinline= -D__extension__= -Dalloca=alloca
+LINT_CFLAGS = -DLINT -I. $(PRE_DEFS) $(POST_DEFS) $(RUBY_CFLAGS) $(LUA_CFLAGS) $(PERL_CFLAGS) $(PYTHON_CFLAGS) -Dinline= -D__extension__= -Dalloca=alloca
 
 LINT_EXTRA = -DUSE_SNIFF -DHANGUL_INPUT -D"__attribute__(x)="
 
@@ -1352,7 +1359,8 @@
 	   $(PYTHON3_LIBS) \
 	   $(TCL_LIBS) \
 	   $(RUBY_LIBS) \
-	   $(PROFILE_LIBS)
+	   $(PROFILE_LIBS) \
+	   $(LEAK_LIBS)
 
 # abbreviations
 DEST_BIN = $(DESTDIR)$(BINDIR)
@@ -1474,8 +1482,15 @@
 	    if_python.c if_python3.c if_tcl.c if_ruby.c if_sniff.c \
 	    gui_beval.c workshop.c wsdebug.c integration.c netbeans.c
 
+# Unittest files
+MEMFILE_TEST_SRC = memfile_test.c
+MEMFILE_TEST_TARGET = memfile_test$(EXEEXT)
+
+UNITTEST_SRC = $(MEMFILE_TEST_SRC)
+UNITTEST_TARGETS = $(MEMFILE_TEST_TARGET)
+
 # All sources, also the ones that are not configured
-ALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(EXTRA_SRC)
+ALL_SRC = $(BASIC_SRC) $(ALL_GUI_SRC) $(UNITTEST_SRC) $(EXTRA_SRC)
 
 # Which files to check with lint.  Select one of these three lines.  ALL_SRC
 # checks more, but may not work well for checking a GUI that wasn't configured.
@@ -1486,7 +1501,7 @@
 #LINT_SRC = $(ALL_SRC)
 #LINT_SRC = $(BASIC_SRC)
 
-OBJ = \
+OBJ_COMMON = \
 	objects/buffer.o \
 	objects/blowfish.o \
 	objects/charset.o \
@@ -1507,10 +1522,8 @@
 	$(HANGULIN_OBJ) \
 	objects/if_cscope.o \
 	objects/if_xcmdsrv.o \
-	objects/main.o \
 	objects/mark.o \
-	objects/memfile.o \
-	objects/memline.o \
+        objects/memline.o \
 	objects/menu.o \
 	objects/message.o \
 	objects/misc1.o \
@@ -1535,6 +1548,7 @@
 	objects/term.o \
 	objects/ui.o \
 	objects/undo.o \
+	objects/version.o \
 	objects/window.o \
 	$(GUI_OBJ) \
 	$(LUA_OBJ) \
@@ -1549,6 +1563,13 @@
 	$(NETBEANS_OBJ) \
 	$(WSDEBUG_OBJ)
 
+OBJ = $(OBJ_COMMON) \
+	objects/main.o \
+	objects/memfile.o
+
+MEMFILE_TEST_OBJ = $(OBJ_COMMON) \
+        objects/memfile_test.o
+
 PRO_AUTO = \
 	blowfish.pro \
 	buffer.pro \
@@ -1694,8 +1715,9 @@
 $(VIMTARGET): auto/config.mk objects $(OBJ) version.c version.h
 	$(CCC) version.c -o objects/version.o
 	@LINK="$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \
-		-o $(VIMTARGET) $(OBJ) objects/version.o $(ALL_LIBS)" \
-		MAKE="$(MAKE)" sh $(srcdir)/link.sh
+		-o $(VIMTARGET) $(OBJ) $(ALL_LIBS)" \
+		MAKE="$(MAKE)" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \
+		sh $(srcdir)/link.sh
 
 xxd/xxd$(EXEEXT): xxd/xxd.c
 	cd xxd; CC="$(CC)" CFLAGS="$(CPPFLAGS) $(CFLAGS)" \
@@ -1818,6 +1840,15 @@
 		ln -s $(VIMTARGET) vim; \
 	fi
 	cd testdir; $(MAKE) -f Makefile $(GUI_TESTTARGET) VIMPROG=../$(VIMTARGET) $(GUI_TESTARG)
+	$(MAKE) -f Makefile unittest
+
+unittesttargets:
+	$(MAKE) -f Makefile $(UNITTEST_TARGETS)
+
+unittest unittests: $(UNITTEST_TARGETS)
+	@for t in $(UNITTEST_TARGETS); do \
+		./$$t || exit 1; echo $$t passed; \
+	done
 
 testclean:
 	cd testdir; $(MAKE) -f Makefile clean
@@ -1825,6 +1856,17 @@
 		cd $(PODIR); $(MAKE) checkclean; \
 	fi
 
+# Unittests
+# It's build just like Vim to satisfy all dependencies.
+$(MEMFILE_TEST_TARGET): auto/config.mk objects $(MEMFILE_TEST_OBJ)
+	$(CCC) version.c -o objects/version.o
+	@LINK="$(PURIFY) $(SHRPENV) $(CClink) $(ALL_LIB_DIRS) $(LDFLAGS) \
+		-o $(MEMFILE_TEST_TARGET) $(MEMFILE_TEST_OBJ) $(ALL_LIBS)" \
+		MAKE="$(MAKE)" LINK_AS_NEEDED=$(LINK_AS_NEEDED) \
+		sh $(srcdir)/link.sh
+
+# install targets
+
 install: $(GUI_INSTALL)
 
 install_normal: installvim installtools $(INSTALL_LANGS) install-icons
@@ -2258,6 +2300,7 @@
 	-rm -f *.o objects/* core $(VIMTARGET).core $(VIMTARGET) vim xxd/*.o
 	-rm -f $(TOOLS) auto/osdef.h auto/pathdef.c auto/if_perl.c
 	-rm -f conftest* *~ auto/link.sed
+	-rm -f $(UNITTEST_TARGETS)
 	-rm -f runtime pixmaps
 	-rm -rf $(APPDIR)
 	-rm -rf mzscheme_base.c
@@ -2532,7 +2575,7 @@
 	$(CCC) $(PYTHON3_CFLAGS) $(PYTHON3_CFLAGS_EXTRA) -o $@ if_python3.c
 
 objects/if_ruby.o: if_ruby.c
-	$(CCC) -o $@ if_ruby.c
+	$(CCC) $(RUBY_CFLAGS) -o $@ if_ruby.c
 
 objects/if_sniff.o: if_sniff.c
 	$(CCC) -o $@ if_sniff.c
@@ -2552,6 +2595,9 @@
 objects/memfile.o: memfile.c
 	$(CCC) -o $@ memfile.c
 
+objects/memfile_test.o: memfile_test.c
+	$(CCC) -o $@ memfile_test.c
+
 objects/memline.o: memline.c
 	$(CCC) -o $@ memline.c
 
@@ -2870,7 +2916,7 @@
 objects/os_unix.o: os_unix.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
  gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h globals.h farsi.h \
- arabic.h if_mzsch.h os_unixx.h
+ arabic.h os_unixx.h
 objects/pathdef.o: auto/pathdef.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \
  regexp.h gui.h gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h \
@@ -3009,6 +3055,10 @@
 objects/pty.o: pty.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h ascii.h \
  keymap.h term.h macros.h option.h structs.h regexp.h gui.h gui_beval.h \
  proto/gui_beval.pro ex_cmds.h proto.h globals.h farsi.h arabic.h
+objects/memfile_test.o: memfile_test.c main.c vim.h auto/config.h feature.h \
+ os_unix.h auto/osdef.h ascii.h keymap.h term.h macros.h option.h \
+ structs.h regexp.h gui.h gui_beval.h proto/gui_beval.pro ex_cmds.h \
+ proto.h globals.h farsi.h arabic.h farsi.c arabic.c memfile.c
 objects/hangulin.o: hangulin.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \
  regexp.h gui.h gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h \
@@ -3020,7 +3070,7 @@
 objects/if_mzsch.o: if_mzsch.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \
  regexp.h gui.h gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h \
- globals.h farsi.h arabic.h if_mzsch.h mzscheme_base.c
+ globals.h farsi.h arabic.h if_mzsch.h
 objects/if_perl.o: auto/if_perl.c vim.h auto/config.h feature.h os_unix.h \
  auto/osdef.h ascii.h keymap.h term.h macros.h option.h structs.h \
  regexp.h gui.h gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h \
@@ -3041,7 +3091,7 @@
  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
  gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h globals.h farsi.h \
  arabic.h
-objects/if_ruby.o: if_ruby.c vim.h auto/config.h feature.h os_unix.h auto/osdef.h \
+objects/if_ruby.o: if_ruby.c auto/config.h vim.h feature.h os_unix.h auto/osdef.h \
  ascii.h keymap.h term.h macros.h option.h structs.h regexp.h gui.h \
  gui_beval.h proto/gui_beval.pro ex_cmds.h proto.h globals.h farsi.h \
  arabic.h version.h
diff -Naur vim73.orig/src/ascii.h vim73/src/ascii.h
--- vim73.orig/src/ascii.h	2010-05-15 11:04:07.000000000 +0000
+++ vim73/src/ascii.h	2011-05-17 09:39:31.591921313 +0000
@@ -183,11 +183,6 @@
 # define PATHSEP	psepc
 # define PATHSEPSTR	pseps
 #else
-# ifdef RISCOS
-#  define PATHSEP	'.'
-#  define PATHSEPSTR	"."
-# else
-#  define PATHSEP	'/'
-#  define PATHSEPSTR	"/"
-# endif
+# define PATHSEP	'/'
+# define PATHSEPSTR	"/"
 #endif
diff -Naur vim73.orig/src/auto/config.mk vim73/src/auto/config.mk
--- vim73.orig/src/auto/config.mk	2010-08-15 13:02:25.000000000 +0000
+++ vim73/src/auto/config.mk	1970-01-01 00:00:00.000000000 +0000
@@ -1,5 +0,0 @@
-the first targets to make vim are: scratch config myself
-srcdir = .
-VIMNAME = vim
-EXNAME = ex
-VIEWNAME = view
diff -Naur vim73.orig/src/auto/configure vim73/src/auto/configure
--- vim73.orig/src/auto/configure	2010-08-13 14:17:15.000000000 +0000
+++ vim73/src/auto/configure	2011-05-17 09:39:20.581143348 +0000
@@ -593,6 +593,7 @@
 
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
+LINK_AS_NEEDED
 DEPEND_CFLAGS_FILTER
 MAKEMO
 MSGFMT
@@ -1427,7 +1428,7 @@
   --enable-pythoninterp=OPTS   Include Python interpreter. default=no OPTS=no/yes/dynamic
   --enable-python3interp=OPTS   Include Python3 interpreter. default=no OPTS=no/yes/dynamic
   --enable-tclinterp      Include Tcl interpreter.
-  --enable-rubyinterp     Include Ruby interpreter.
+  --enable-rubyinterp=OPTS     Include Ruby interpreter.  default=no OPTS=no/yes/dynamic
   --enable-cscope         Include cscope interface.
   --enable-workshop       Include Sun Visual Workshop support.
   --disable-netbeans      Disable NetBeans integration support.
@@ -4862,16 +4863,36 @@
       else
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in /usr/include/plt/" >&5
-$as_echo_n "checking if scheme.h can be found in /usr/include/plt/... " >&6; }
-	if test -f /usr/include/plt/scheme.h; then
+	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket" >&5
+$as_echo_n "checking if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket... " >&6; }
+	if test -f $vi_cv_path_mzscheme_pfx/include/racket/scheme.h; then
 	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
-	  SCHEME_INC=/usr/include/plt
+	  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket
 	else
 	  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
 $as_echo "no" >&6; }
-	  vi_cv_path_mzscheme_pfx=
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in /usr/include/plt/" >&5
+$as_echo_n "checking if scheme.h can be found in /usr/include/plt/... " >&6; }
+	  if test -f /usr/include/plt/scheme.h; then
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	    SCHEME_INC=/usr/include/plt
+	  else
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	    { $as_echo "$as_me:${as_lineno-$LINENO}: checking if scheme.h can be found in /usr/include/racket/" >&5
+$as_echo_n "checking if scheme.h can be found in /usr/include/racket/... " >&6; }
+	    if test -f /usr/include/racket/scheme.h; then
+	      { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+	      SCHEME_INC=/usr/include/racket
+	    else
+	      { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+	      vi_cv_path_mzscheme_pfx=
+	    fi
+	  fi
 	fi
       fi
     fi
@@ -4883,12 +4904,22 @@
     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
       MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
-    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket3m.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libracket3m.a"
+      MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libracket.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
     else
             if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
 	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket3m.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lracket3m"
+	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lracket -lmzgc"
       else
         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
       fi
@@ -4901,10 +4932,20 @@
     fi
     if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
       SCHEME_COLLECTS=lib/plt/
+    else
+      if test -d $vi_cv_path_mzscheme_pfx/lib/racket/collects; then
+	SCHEME_COLLECTS=lib/racket/
+      fi
     fi
     if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
-            MZSCHEME_EXTRA="mzscheme_base.c"
-      MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
+      MZSCHEME_EXTRA="mzscheme_base.c"
+    else
+      if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
+	MZSCHEME_EXTRA="mzscheme_base.c"
+      fi
+    fi
+    if test "X$MZSCHEME_EXTRA" != "X" ; then
+            MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
     fi
     MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -I${SCHEME_INC} \
@@ -5285,9 +5326,9 @@
 
 	PYTHON_LIBS="${vi_cv_path_python_plibs}"
 	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
-	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version}"
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME=\\\"${vi_cv_path_python_pfx}\\\""
 	else
-	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version}"
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME=\\\"${vi_cv_path_python_pfx}\\\""
 	fi
 	PYTHON_SRC="if_python.c"
 		if test "x$MACOSX" = "xyes"; then
@@ -5298,7 +5339,7 @@
 	if test "${vi_cv_var_python_version}" = "1.4"; then
 	   PYTHON_OBJ="$PYTHON_OBJ objects/py_getpath.o"
 	fi
-	PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
+    PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
 
 								{ $as_echo "$as_me:${as_lineno-$LINENO}: checking if -pthread should be used" >&5
 $as_echo_n "checking if -pthread should be used... " >&6; }
@@ -5560,9 +5601,9 @@
 
       PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
       if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
-        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}"
+        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -DPYTHON3_HOME=L\\\"${vi_cv_path_python3_pfx}\\\""
       else
-        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}"
+        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version} -DPYTHON3_HOME=L\\\"${vi_cv_path_python3_pfx}\\\""
       fi
       PYTHON3_SRC="if_python3.c"
             if test "x$MACOSX" = "xyes"; then
@@ -5667,10 +5708,10 @@
 
   $as_echo "#define DYNAMIC_PYTHON3 1" >>confdefs.h
 
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can do without RTLD_GLOBAL" >&5
-$as_echo_n "checking whether we can do without RTLD_GLOBAL... " >&6; }
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can do without RTLD_GLOBAL for Python" >&5
+$as_echo_n "checking whether we can do without RTLD_GLOBAL for Python... " >&6; }
   cflags_save=$CFLAGS
-  CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+  CFLAGS="$CFLAGS $PYTHON_CFLAGS"
   ldflags_save=$LDFLAGS
   LDFLAGS="$LDFLAGS -ldl"
   if test "$cross_compiling" = yes; then :
@@ -5689,15 +5730,17 @@
      * Only the first pyhton version used will be switched on.
      */
 
-    int no_rtl_global_needed_for(char *python_instsoname)
+    int no_rtl_global_needed_for(char *python_instsoname, char *prefix)
     {
       int needed = 0;
       void* pylib = dlopen(python_instsoname, RTLD_LAZY);
       if (pylib != 0)
       {
+          void (*pfx)(char *home) = dlsym(pylib, "Py_SetPythonHome");
           void (*init)(void) = dlsym(pylib, "Py_Initialize");
           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
           void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
           (*init)();
           needed = (*simple)("import termios") == -1;
           (*final)();
@@ -5709,7 +5752,7 @@
     int main(int argc, char** argv)
     {
       int not_needed = 0;
-      if (no_rtl_global_needed_for("libpython2.7.so.1.0") && no_rtl_global_needed_for("libpython3.1.so.1.0"))
+      if (no_rtl_global_needed_for("${python_INSTSONAME}", "${vi_cv_path_python_pfx}"))
             not_needed = 1;
       return !not_needed;
     }
@@ -5726,8 +5769,76 @@
   conftest.$ac_objext conftest.beam conftest.$ac_ext
 fi
 
+
+  CFLAGS=$cflags_save
+  LDFLAGS=$ldflags_save
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we can do without RTLD_GLOBAL for Python3" >&5
+$as_echo_n "checking whether we can do without RTLD_GLOBAL for Python3... " >&6; }
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+  ldflags_save=$LDFLAGS
+  LDFLAGS="$LDFLAGS -ldl"
+  if test "$cross_compiling" = yes; then :
+  { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error "cannot run test program while cross compiling
+See \`config.log' for more details." "$LINENO" 5; }
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+    #include <dlfcn.h>
+    #include <wchar.h>
+    /* If this program fails, then RTLD_GLOBAL is needed.
+     * RTLD_GLOBAL will be used and then it is not possible to
+     * have both python versions enabled in the same vim instance.
+     * Only the first pyhton version used will be switched on.
+     */
+
+    int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)
+    {
+      int needed = 0;
+      void* pylib = dlopen(python_instsoname, RTLD_LAZY);
+      if (pylib != 0)
+      {
+          void (*pfx)(wchar_t *home) = dlsym(pylib, "Py_SetPythonHome");
+          void (*init)(void) = dlsym(pylib, "Py_Initialize");
+          int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+          void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
+          (*init)();
+          needed = (*simple)("import termios") == -1;
+          (*final)();
+          dlclose(pylib);
+      }
+      return !needed;
+    }
+
+    int main(int argc, char** argv)
+    {
+      int not_needed = 0;
+      if (no_rtl_global_needed_for("${python3_INSTSONAME}", L"${vi_cv_path_python3_pfx}"))
+            not_needed = 1;
+      return !not_needed;
+    }
+_ACEOF
+if ac_fn_c_try_run "$LINENO"; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; };$as_echo "#define PY3_NO_RTLD_GLOBAL 1" >>confdefs.h
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
+  conftest.$ac_objext conftest.beam conftest.$ac_ext
+fi
+
+
   CFLAGS=$cflags_save
   LDFLAGS=$ldflags_save
+
   PYTHON_SRC="if_python.c"
   PYTHON_OBJ="objects/if_python.o"
   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${python_INSTSONAME}\\\""
@@ -6103,20 +6214,20 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_rubyinterp" >&5
 $as_echo "$enable_rubyinterp" >&6; }
-if test "$enable_rubyinterp" = "yes"; then
+if test "$enable_rubyinterp" = "yes" -o "$enable_rubyinterp" = "dynamic"; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: checking --with-ruby-command argument" >&5
 $as_echo_n "checking --with-ruby-command argument... " >&6; }
 
+
 # Check whether --with-ruby-command was given.
 if test "${with_ruby_command+set}" = set; then :
-  withval=$with_ruby_command; RUBY_CMD="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RUBY_CMD" >&5
+  withval=$with_ruby_command; RUBY_CMD="$withval"; vi_cv_path_ruby="$withval"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RUBY_CMD" >&5
 $as_echo "$RUBY_CMD" >&6; }
 else
   RUBY_CMD="ruby"; { $as_echo "$as_me:${as_lineno-$LINENO}: result: defaulting to $RUBY_CMD" >&5
 $as_echo "defaulting to $RUBY_CMD" >&6; }
 fi
 
-
   # Extract the first word of "$RUBY_CMD", so it can be a program name with args.
 set dummy $RUBY_CMD; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
@@ -6181,17 +6292,14 @@
 	  RUBY_LIBS="$rubylibs"
 	fi
 	librubyarg=`$vi_cv_path_ruby -r rbconfig -e 'print Config.expand(Config::CONFIG["LIBRUBYARG"])'`
-	if test -f "$rubyhdrdir/$librubyarg"; then
-	  librubyarg="$rubyhdrdir/$librubyarg"
-	else
-	  rubylibdir=`$vi_cv_path_ruby -r rbconfig -e 'print Config.expand(Config::CONFIG["libdir"])'`
-	  if test -f "$rubylibdir/$librubyarg"; then
-	    librubyarg="$rubylibdir/$librubyarg"
-	  elif test "$librubyarg" = "libruby.a"; then
-	    	    librubyarg="-lruby"
-	  else
-	    librubyarg=`$vi_cv_path_ruby -r rbconfig -e "print '$librubyarg'.gsub(/-L\./, %'-L#{Config.expand(Config::CONFIG[\"libdir\"])}')"`
-	  fi
+	librubya=`$vi_cv_path_ruby -r rbconfig -e 'print Config.expand(Config::CONFIG["LIBRUBY_A"])'`
+  rubylibdir=`$vi_cv_path_ruby -r rbconfig -e 'print Config.expand(Config::CONFIG["libdir"])'`
+	if test -f "$rubylibdir/$librubya"; then
+	  librubyarg="$librubyarg"
+    RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
+  elif test "$librubyarg" = "libruby.a"; then
+        librubyarg="-lruby"
+    RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
 	fi
 
 	if test "X$librubyarg" != "X"; then
@@ -6209,6 +6317,13 @@
 	RUBY_PRO="if_ruby.pro"
 	$as_echo "#define FEAT_RUBY 1" >>confdefs.h
 
+	if test "$enable_rubyinterp" = "dynamic"; then
+	  libruby=`$vi_cv_path_ruby -r rbconfig -e 'printf "lib%s.%s\n", Config::CONFIG["RUBY_SO_NAME"], Config::CONFIG["DLEXT"]'`
+	  $as_echo "#define DYNAMIC_RUBY 1" >>confdefs.h
+
+	  RUBY_CFLAGS="-DDYNAMIC_RUBY_DLL=\\\"$libruby\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS"
+	  RUBY_LIBS=
+	fi
       else
 	{ $as_echo "$as_me:${as_lineno-$LINENO}: result: not found; disabling Ruby" >&5
 $as_echo "not found; disabling Ruby" >&6; }
@@ -9768,9 +9883,9 @@
 else
   { $as_echo "$as_me:${as_lineno-$LINENO}: result: empty: automatic terminal library selection" >&5
 $as_echo "empty: automatic terminal library selection" >&6; }
-              case "`uname -s 2>/dev/null`" in
-	OSF1|SCO_SV)	tlibs="ncurses curses termlib termcap";;
-	*)	tlibs="ncurses termlib termcap curses";;
+                case "`uname -s 2>/dev/null`" in
+	OSF1|SCO_SV)	tlibs="tinfo ncurses curses termlib termcap";;
+	*)	tlibs="tinfo ncurses termlib termcap curses";;
   esac
   for libname in $tlibs; do
     as_ac_Lib=`$as_echo "ac_cv_lib_${libname}''_tgetent" | $as_tr_sh`
@@ -11915,6 +12030,10 @@
 test -f tags && mv tags tags.save
 if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&5 2>&1; then
   TAGPRG="ctags -I INIT+ --fields=+S"
+elif (eval exctags --version /dev/null | grep Exuberant) < /dev/null 1>&5 2>&1; then
+  TAGPRG="exctags -I INIT+ --fields=+S"
+elif (eval exuberant-ctags --version /dev/null | grep Exuberant) < /dev/null 1>&5 2>&1; then
+  TAGPRG="exuberant-ctags -I INIT+ --fields=+S"
 else
   TAGPRG="ctags"
   (eval etags	   /dev/null) < /dev/null 1>&5 2>&1 && TAGPRG="etags"
@@ -12357,6 +12476,23 @@
 fi
 
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking linker --as-needed support" >&5
+$as_echo_n "checking linker --as-needed support... " >&6; }
+LINK_AS_NEEDED=
+# Check if linker supports --as-needed and --no-as-needed options
+if $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then
+  LDFLAGS="$LDFLAGS -Wl,--as-needed"
+  LINK_AS_NEEDED=yes
+fi
+if test "$LINK_AS_NEEDED" = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
 ac_config_files="$ac_config_files auto/config.mk:config.mk.in"
 
 cat >confcache <<\_ACEOF
diff -Naur vim73.orig/src/blowfish.c vim73/src/blowfish.c
--- vim73.orig/src/blowfish.c	2010-07-14 14:45:39.000000000 +0000
+++ vim73/src/blowfish.c	2011-05-17 09:37:08.595791992 +0000
@@ -413,6 +413,7 @@
     int    salt_len;
 {
     int      i, j, keypos = 0;
+    unsigned u;
     UINT32_T val, data_l, data_r;
     char_u   *key;
     int      keylen;
@@ -432,8 +433,8 @@
     }
     for (i = 0; i < keylen; i++)
     {
-	sscanf((char *)&key[i * 2], "%2x", &j);
-	key[i] = j;
+	sscanf((char *)&key[i * 2], "%2x", &u);
+	key[i] = u;
     }
 
     mch_memmove(sbx, sbi, 4 * 4 * 256);
diff -Naur vim73.orig/src/buffer.c vim73/src/buffer.c
--- vim73.orig/src/buffer.c	2010-08-13 09:14:35.000000000 +0000
+++ vim73/src/buffer.c	2011-05-17 09:39:01.967209231 +0000
@@ -639,6 +639,9 @@
     {
 	clear_wininfo(buf);		/* including window-local options */
 	free_buf_options(buf, TRUE);
+#ifdef FEAT_SPELL
+	ga_clear(&buf->b_s.b_langp);
+#endif
     }
 #ifdef FEAT_EVAL
     vars_clear(&buf->b_vars.dv_hashtab); /* free all internal variables */
@@ -661,9 +664,6 @@
     vim_free(buf->b_start_fenc);
     buf->b_start_fenc = NULL;
 #endif
-#ifdef FEAT_SPELL
-    ga_clear(&buf->b_s.b_langp);
-#endif
 }
 
 /*
@@ -1288,9 +1288,12 @@
     /* Go to the other buffer. */
     set_curbuf(buf, action);
 
-#if defined(FEAT_LISTCMDS) && defined(FEAT_SCROLLBIND)
+#if defined(FEAT_LISTCMDS) \
+	&& (defined(FEAT_SCROLLBIND) || defined(FEAT_CURSORBIND))
     if (action == DOBUF_SPLIT)
-	curwin->w_p_scb = FALSE;	/* reset 'scrollbind' */
+    {
+	RESET_BINDING(curwin);	/* reset 'scrollbind' and 'cursorbind' */
+    }
 #endif
 
 #if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
@@ -1917,9 +1920,7 @@
 		tabpage_new();
 	    else if (win_split(0, 0) == FAIL)	/* Open in a new window */
 		return FAIL;
-# ifdef FEAT_SCROLLBIND
-	    curwin->w_p_scb = FALSE;
-# endif
+	    RESET_BINDING(curwin);
 	}
     }
 #endif
@@ -2526,6 +2527,9 @@
     if (p_fdls >= 0)
 	curwin->w_p_fdl = p_fdls;
 #endif
+#ifdef FEAT_SYN_HL
+    check_colorcolumn(curwin);
+#endif
 }
 
 /*
@@ -3175,7 +3179,7 @@
 	    /* format: "fname + (path) (1 of 2) - VIM" */
 
 	    if (curbuf->b_fname == NULL)
-		STRCPY(buf, _("[No Name]"));
+		vim_strncpy(buf, (char_u *)_("[No Name]"), IOSIZE - 100);
 	    else
 	    {
 		p = transstr(gettail(curbuf->b_fname));
@@ -3231,7 +3235,7 @@
 	    if (serverName != NULL)
 	    {
 		STRCAT(buf, " - ");
-		STRCAT(buf, serverName);
+		vim_strcat(buf, serverName, IOSIZE);
 	    }
 	    else
 #endif
@@ -3363,7 +3367,8 @@
  * or truncated if too long, fillchar is used for all whitespace.
  */
     int
-build_stl_str_hl(wp, out, outlen, fmt, use_sandbox, fillchar, maxwidth, hltab, tabtab)
+build_stl_str_hl(wp, out, outlen, fmt, use_sandbox, fillchar,
+						      maxwidth, hltab, tabtab)
     win_T	*wp;
     char_u	*out;		/* buffer to write into != NameBuff */
     size_t	outlen;		/* length of out[] */
@@ -3458,6 +3463,18 @@
     prevchar_isitem = FALSE;
     for (s = usefmt; *s; )
     {
+	if (curitem == STL_MAX_ITEM)
+	{
+	    /* There are too many items.  Add the error code to the statusline
+	     * to give the user a hint about what went wrong. */
+	    if (p + 6 < out + outlen)
+	    {
+		mch_memmove(p, " E541", (size_t)5);
+		p += 5;
+	    }
+	    break;
+	}
+
 	if (*s != NUL && *s != '%')
 	    prevchar_isflag = prevchar_isitem = FALSE;
 
@@ -3473,6 +3490,8 @@
 	 * Handle one '%' item.
 	 */
 	s++;
+	if (*s == NUL)  /* ignore trailing % */
+	    break;
 	if (*s == '%')
 	{
 	    if (p + 1 >= out + outlen)
diff -Naur vim73.orig/src/config.h.in vim73/src/config.h.in
--- vim73.orig/src/config.h.in	2010-08-13 13:45:27.000000000 +0000
+++ vim73/src/config.h.in	2011-05-17 09:34:00.400679782 +0000
@@ -349,6 +349,9 @@
 /* Define if you want to include the Ruby interpreter. */
 #undef FEAT_RUBY
 
+/* Define for linking via dlopen() or LoadLibrary() */
+#undef DYNAMIC_RUBY
+
 /* Define if you want to include the Tcl interpreter. */
 #undef FEAT_TCL
 
diff -Naur vim73.orig/src/config.mk.in vim73/src/config.mk.in
--- vim73.orig/src/config.mk.in	2010-07-17 15:28:51.000000000 +0000
+++ vim73/src/config.mk.in	2011-05-17 09:34:17.106825537 +0000
@@ -30,6 +30,7 @@
 CPP		= @CPP@
 CPP_MM		= @CPP_MM@
 DEPEND_CFLAGS_FILTER = @DEPEND_CFLAGS_FILTER@
+LINK_AS_NEEDED	= @LINK_AS_NEEDED@
 X_CFLAGS	= @X_CFLAGS@
 X_LIBS_DIR	= @X_LIBS@
 X_PRE_LIBS	= @X_PRE_LIBS@
diff -Naur vim73.orig/src/configure.in vim73/src/configure.in
--- vim73.orig/src/configure.in	2010-08-13 14:15:17.000000000 +0000
+++ vim73/src/configure.in	2011-05-17 09:39:20.577143792 +0000
@@ -568,13 +568,27 @@
 	SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/plt
       else
 	AC_MSG_RESULT(no)
-	AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
-	if test -f /usr/include/plt/scheme.h; then
+	AC_MSG_CHECKING(if scheme.h can be found in $vi_cv_path_mzscheme_pfx/include/racket)
+	if test -f $vi_cv_path_mzscheme_pfx/include/racket/scheme.h; then
 	  AC_MSG_RESULT(yes)
-	  SCHEME_INC=/usr/include/plt
+	  SCHEME_INC=${vi_cv_path_mzscheme_pfx}/include/racket
 	else
 	  AC_MSG_RESULT(no)
-	  vi_cv_path_mzscheme_pfx=
+	  AC_MSG_CHECKING(if scheme.h can be found in /usr/include/plt/)
+	  if test -f /usr/include/plt/scheme.h; then
+	    AC_MSG_RESULT(yes)
+	    SCHEME_INC=/usr/include/plt
+	  else
+	    AC_MSG_RESULT(no)
+	    AC_MSG_CHECKING(if scheme.h can be found in /usr/include/racket/)
+	    if test -f /usr/include/racket/scheme.h; then
+	      AC_MSG_RESULT(yes)
+	      SCHEME_INC=/usr/include/racket
+	    else
+	      AC_MSG_RESULT(no)
+	      vi_cv_path_mzscheme_pfx=
+	    fi
+	  fi
 	fi
       fi
     fi
@@ -586,13 +600,23 @@
     elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.a"
       MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
-    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"; then
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket3m.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libracket3m.a"
+      MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket.a"; then
+      MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libracket.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
+    elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a"; then
       MZSCHEME_LIBS="${vi_cv_path_mzscheme_pfx}/lib/libmzscheme.a ${vi_cv_path_mzscheme_pfx}/lib/libmzgc.a"
     else
       dnl Using shared objects
       if test -f "${vi_cv_path_mzscheme_pfx}/lib/libmzscheme3m.so"; then
         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme3m"
 	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket3m.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lracket3m"
+	MZSCHEME_CFLAGS="-DMZ_PRECISE_GC"
+      elif test -f "${vi_cv_path_mzscheme_pfx}/lib/libracket.so"; then
+        MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lracket -lmzgc"
       else
         MZSCHEME_LIBS="-L${vi_cv_path_mzscheme_pfx}/lib -lmzscheme -lmzgc"
       fi
@@ -607,10 +631,20 @@
     fi
     if test -d $vi_cv_path_mzscheme_pfx/lib/plt/collects; then
       SCHEME_COLLECTS=lib/plt/
+    else
+      if test -d $vi_cv_path_mzscheme_pfx/lib/racket/collects; then
+	SCHEME_COLLECTS=lib/racket/
+      fi
     fi
     if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.ss" ; then
-      dnl need to generate bytecode for MzScheme base
       MZSCHEME_EXTRA="mzscheme_base.c"
+    else
+      if test -f "${vi_cv_path_mzscheme_pfx}/${SCHEME_COLLECTS}collects/scheme/base.rkt" ; then
+	MZSCHEME_EXTRA="mzscheme_base.c"
+      fi
+    fi
+    if test "X$MZSCHEME_EXTRA" != "X" ; then
+      dnl need to generate bytecode for MzScheme base
       MZSCHEME_CFLAGS="${MZSCHEME_CFLAGS} -DINCLUDE_MZSCHEME_BASE"
       MZSCHEME_MZC="${vi_cv_path_mzscheme_pfx}/bin/mzc"
     fi
@@ -857,9 +891,9 @@
 
 	PYTHON_LIBS="${vi_cv_path_python_plibs}"
 	if test "${vi_cv_path_python_pfx}" = "${vi_cv_path_python_epfx}"; then
-	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version}"
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME=\\\"${vi_cv_path_python_pfx}\\\""
 	else
-	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version}"
+	  PYTHON_CFLAGS="-I${vi_cv_path_python_pfx}/include/python${vi_cv_var_python_version} -I${vi_cv_path_python_epfx}/include/python${vi_cv_var_python_version} -DPYTHON_HOME=\\\"${vi_cv_path_python_pfx}\\\""
 	fi
 	PYTHON_SRC="if_python.c"
 	dnl For Mac OSX 10.2 config.o is included in the Python library.
@@ -871,7 +905,7 @@
 	if test "${vi_cv_var_python_version}" = "1.4"; then
 	   PYTHON_OBJ="$PYTHON_OBJ objects/py_getpath.o"
 	fi
-	PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
+    PYTHON_GETPATH_CFLAGS="-DPYTHONPATH='\"${vi_cv_path_pythonpath}\"' -DPREFIX='\"${vi_cv_path_python_pfx}\"' -DEXEC_PREFIX='\"${vi_cv_path_python_epfx}\"'"
 
 	dnl On FreeBSD linking with "-pthread" is required to use threads.
 	dnl _THREAD_SAFE must be used for compiling then.
@@ -1029,9 +1063,9 @@
 
       PYTHON3_LIBS="${vi_cv_path_python3_plibs}"
       if test "${vi_cv_path_python3_pfx}" = "${vi_cv_path_python3_epfx}"; then
-        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version}"
+        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -DPYTHON3_HOME=L\\\"${vi_cv_path_python3_pfx}\\\""
       else
-        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version}"
+        PYTHON3_CFLAGS="-I${vi_cv_path_python3_pfx}/include/python${vi_cv_var_python3_version} -I${vi_cv_path_python3_epfx}/include/python${vi_cv_var_python3_version} -DPYTHON3_HOME=L\\\"${vi_cv_path_python3_pfx}\\\""
       fi
       PYTHON3_SRC="if_python3.c"
       dnl For Mac OSX 10.2 config.o is included in the Python library.
@@ -1109,9 +1143,9 @@
 if test "$python_ok" = yes && test "$python3_ok" = yes; then
   AC_DEFINE(DYNAMIC_PYTHON)
   AC_DEFINE(DYNAMIC_PYTHON3)
-  AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL)
+  AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python)
   cflags_save=$CFLAGS
-  CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+  CFLAGS="$CFLAGS $PYTHON_CFLAGS"
   ldflags_save=$LDFLAGS
   LDFLAGS="$LDFLAGS -ldl"
   AC_RUN_IFELSE([
@@ -1122,15 +1156,17 @@
      * Only the first pyhton version used will be switched on.
      */
 
-    int no_rtl_global_needed_for(char *python_instsoname)
+    int no_rtl_global_needed_for(char *python_instsoname, char *prefix)
     {
       int needed = 0;
       void* pylib = dlopen(python_instsoname, RTLD_LAZY);
       if (pylib != 0)
       {
+          void (*pfx)(char *home) = dlsym(pylib, "Py_SetPythonHome");
           void (*init)(void) = dlsym(pylib, "Py_Initialize");
           int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
           void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
           (*init)();
           needed = (*simple)("import termios") == -1;
           (*final)();
@@ -1142,13 +1178,60 @@
     int main(int argc, char** argv)
     {
       int not_needed = 0;
-      if (no_rtl_global_needed_for("libpython2.7.so.1.0") && no_rtl_global_needed_for("libpython3.1.so.1.0"))
+      if (no_rtl_global_needed_for("${python_INSTSONAME}", "${vi_cv_path_python_pfx}"))
             not_needed = 1;
       return !not_needed;
     }],
     [AC_MSG_RESULT(yes);AC_DEFINE(PY_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
+
   CFLAGS=$cflags_save
   LDFLAGS=$ldflags_save
+
+  AC_MSG_CHECKING(whether we can do without RTLD_GLOBAL for Python3)
+  cflags_save=$CFLAGS
+  CFLAGS="$CFLAGS $PYTHON3_CFLAGS"
+  ldflags_save=$LDFLAGS
+  LDFLAGS="$LDFLAGS -ldl"
+  AC_RUN_IFELSE([
+    #include <dlfcn.h>
+    #include <wchar.h>
+    /* If this program fails, then RTLD_GLOBAL is needed.
+     * RTLD_GLOBAL will be used and then it is not possible to
+     * have both python versions enabled in the same vim instance.
+     * Only the first pyhton version used will be switched on.
+     */
+
+    int no_rtl_global_needed_for(char *python_instsoname, wchar_t *prefix)
+    {
+      int needed = 0;
+      void* pylib = dlopen(python_instsoname, RTLD_LAZY);
+      if (pylib != 0)
+      {
+          void (*pfx)(wchar_t *home) = dlsym(pylib, "Py_SetPythonHome");
+          void (*init)(void) = dlsym(pylib, "Py_Initialize");
+          int (*simple)(char*) = dlsym(pylib, "PyRun_SimpleString");
+          void (*final)(void) = dlsym(pylib, "Py_Finalize");
+          (*pfx)(prefix);
+          (*init)();
+          needed = (*simple)("import termios") == -1;
+          (*final)();
+          dlclose(pylib);
+      }
+      return !needed;
+    }
+
+    int main(int argc, char** argv)
+    {
+      int not_needed = 0;
+      if (no_rtl_global_needed_for("${python3_INSTSONAME}", L"${vi_cv_path_python3_pfx}"))
+            not_needed = 1;
+      return !not_needed;
+    }],
+    [AC_MSG_RESULT(yes);AC_DEFINE(PY3_NO_RTLD_GLOBAL)], [AC_MSG_RESULT(no)])
+
+  CFLAGS=$cflags_save
+  LDFLAGS=$ldflags_save
+
   PYTHON_SRC="if_python.c"
   PYTHON_OBJ="objects/if_python.o"
   PYTHON_CFLAGS="$PYTHON_CFLAGS -DDYNAMIC_PYTHON_DLL=\\\"${python_INSTSONAME}\\\""
@@ -1299,15 +1382,15 @@
 
 AC_MSG_CHECKING(--enable-rubyinterp argument)
 AC_ARG_ENABLE(rubyinterp,
-	[  --enable-rubyinterp     Include Ruby interpreter.], ,
+	[  --enable-rubyinterp[=OPTS]     Include Ruby interpreter.  [default=no] [OPTS=no/yes/dynamic]], ,
 	[enable_rubyinterp="no"])
 AC_MSG_RESULT($enable_rubyinterp)
-if test "$enable_rubyinterp" = "yes"; then
+if test "$enable_rubyinterp" = "yes" -o "$enable_rubyinterp" = "dynamic"; then
   AC_MSG_CHECKING(--with-ruby-command argument)
+  AC_SUBST(vi_cv_path_ruby)
   AC_ARG_WITH(ruby-command, [  --with-ruby-command=RUBY  name of the Ruby command (default: ruby)],
-	RUBY_CMD="$withval"; AC_MSG_RESULT($RUBY_CMD),
+	RUBY_CMD="$withval"; vi_cv_path_ruby="$withval"; AC_MSG_RESULT($RUBY_CMD),
 	RUBY_CMD="ruby"; AC_MSG_RESULT(defaulting to $RUBY_CMD))
-  AC_SUBST(vi_cv_path_ruby)
   AC_PATH_PROG(vi_cv_path_ruby, $RUBY_CMD)
   if test "X$vi_cv_path_ruby" != "X"; then
     AC_MSG_CHECKING(Ruby version)
@@ -1329,18 +1412,15 @@
 	  RUBY_LIBS="$rubylibs"
 	fi
 	librubyarg=`$vi_cv_path_ruby -r rbconfig -e 'print Config.expand(Config::CONFIG[["LIBRUBYARG"]])'`
-	if test -f "$rubyhdrdir/$librubyarg"; then
-	  librubyarg="$rubyhdrdir/$librubyarg"
-	else
-	  rubylibdir=`$vi_cv_path_ruby -r rbconfig -e 'print Config.expand(Config::CONFIG[["libdir"]])'`
-	  if test -f "$rubylibdir/$librubyarg"; then
-	    librubyarg="$rubylibdir/$librubyarg"
-	  elif test "$librubyarg" = "libruby.a"; then
-	    dnl required on Mac OS 10.3 where libruby.a doesn't exist
-	    librubyarg="-lruby"
-	  else
-	    librubyarg=`$vi_cv_path_ruby -r rbconfig -e "print '$librubyarg'.gsub(/-L\./, %'-L#{Config.expand(Config::CONFIG[\"libdir\"])}')"`
-	  fi
+	librubya=`$vi_cv_path_ruby -r rbconfig -e 'print Config.expand(Config::CONFIG[["LIBRUBY_A"]])'`
+  rubylibdir=`$vi_cv_path_ruby -r rbconfig -e 'print Config.expand(Config::CONFIG[["libdir"]])'`
+	if test -f "$rubylibdir/$librubya"; then
+	  librubyarg="$librubyarg"
+    RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
+  elif test "$librubyarg" = "libruby.a"; then
+    dnl required on Mac OS 10.3 where libruby.a doesn't exist
+    librubyarg="-lruby"
+    RUBY_LIBS="$RUBY_LIBS -L$rubylibdir"
 	fi
 
 	if test "X$librubyarg" != "X"; then
@@ -1360,6 +1440,12 @@
 	RUBY_OBJ="objects/if_ruby.o"
 	RUBY_PRO="if_ruby.pro"
 	AC_DEFINE(FEAT_RUBY)
+	if test "$enable_rubyinterp" = "dynamic"; then
+	  libruby=`$vi_cv_path_ruby -r rbconfig -e 'printf "lib%s.%s\n", Config::CONFIG[["RUBY_SO_NAME"]], Config::CONFIG[["DLEXT"]]'`
+	  AC_DEFINE(DYNAMIC_RUBY)
+	  RUBY_CFLAGS="-DDYNAMIC_RUBY_DLL=\\\"$libruby\\\" -DDYNAMIC_RUBY_VER=$rubyversion $RUBY_CFLAGS"
+	  RUBY_LIBS=
+	fi
       else
 	AC_MSG_RESULT(not found; disabling Ruby)
       fi
@@ -2529,13 +2615,14 @@
   AC_MSG_RESULT([empty: automatic terminal library selection])
   dnl  On HP-UX 10.10 termcap or termlib should be used instead of
   dnl  curses, because curses is much slower.
-  dnl  Newer versions of ncurses are preferred over anything.
+  dnl  Newer versions of ncurses are preferred over anything, except
+  dnl  when tinfo has been split off, it contains all we need.
   dnl  Older versions of ncurses have bugs, get a new one!
   dnl  Digital Unix (OSF1) should use curses (Ronald Schild).
   dnl  On SCO Openserver should prefer termlib (Roger Cornelius).
   case "`uname -s 2>/dev/null`" in
-	OSF1|SCO_SV)	tlibs="ncurses curses termlib termcap";;
-	*)	tlibs="ncurses termlib termcap curses";;
+	OSF1|SCO_SV)	tlibs="tinfo ncurses curses termlib termcap";;
+	*)	tlibs="tinfo ncurses termlib termcap curses";;
   esac
   for libname in $tlibs; do
     AC_CHECK_LIB(${libname}, tgetent,,)
@@ -3280,7 +3367,7 @@
 AC_CHECK_LIB(xpg4, _xpg4_setrunelocale, [LIBS="$LIBS -lxpg4"],,)
 
 dnl Check how we can run ctags.  Default to "ctags" when nothing works.
-dnl --version for Exuberant ctags (preferred)
+dnl Use --version to detect Exuberant ctags (preferred)
 dnl       Add --fields=+S to get function signatures for omni completion.
 dnl -t for typedefs (many ctags have this)
 dnl -s for static functions (Elvis ctags only?)
@@ -3290,6 +3377,10 @@
 test -f tags && mv tags tags.save
 if (eval ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
   TAGPRG="ctags -I INIT+ --fields=+S"
+elif (eval exctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+  TAGPRG="exctags -I INIT+ --fields=+S"
+elif (eval exuberant-ctags --version /dev/null | grep Exuberant) < /dev/null 1>&AC_FD_CC 2>&1; then
+  TAGPRG="exuberant-ctags -I INIT+ --fields=+S"
 else
   TAGPRG="ctags"
   (eval etags	   /dev/null) < /dev/null 1>&AC_FD_CC 2>&1 && TAGPRG="etags"
@@ -3487,6 +3578,23 @@
 fi
 AC_SUBST(DEPEND_CFLAGS_FILTER)
 
+dnl link.sh tries to avoid overlinking in a hackish way.
+dnl At least GNU ld supports --as-needed which provides the same functionality
+dnl at linker level. Let's use it.
+AC_MSG_CHECKING(linker --as-needed support)
+LINK_AS_NEEDED=
+# Check if linker supports --as-needed and --no-as-needed options
+if $CC -Wl,--help 2>/dev/null | grep as-needed > /dev/null; then
+  LDFLAGS="$LDFLAGS -Wl,--as-needed"
+  LINK_AS_NEEDED=yes
+fi
+if test "$LINK_AS_NEEDED" = yes; then
+  AC_MSG_RESULT(yes)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST(LINK_AS_NEEDED)
+
 dnl write output files
 AC_OUTPUT(auto/config.mk:config.mk.in)
 
diff -Naur vim73.orig/src/diff.c vim73/src/diff.c
--- vim73.orig/src/diff.c	2010-07-31 13:35:21.000000000 +0000
+++ vim73/src/diff.c	2011-05-17 09:32:40.821512501 +0000
@@ -1127,11 +1127,13 @@
 # endif
 
     wp->w_p_diff = TRUE;
+    /* Use 'scrollbind' and 'cursorbind' when available */
+#ifdef FEAT_SCROLLBIND
+    wp->w_p_scb = TRUE;
+#endif
 #ifdef FEAT_CURSORBIND
-    /* Use cursorbind if it's available */
     wp->w_p_crb = TRUE;
 #endif
-    wp->w_p_scb = TRUE;
     wp->w_p_wrap = FALSE;
 # ifdef FEAT_FOLDING
     curwin = wp;
@@ -1177,10 +1179,7 @@
 	{
 	    /* Set 'diff', 'scrollbind' off and 'wrap' on. */
 	    wp->w_p_diff = FALSE;
-#ifdef FEAT_CURSORBIND
-	    wp->w_p_crb = FALSE;
-#endif
-	    wp->w_p_scb = FALSE;
+	    RESET_BINDING(wp);
 	    wp->w_p_wrap = TRUE;
 #ifdef FEAT_FOLDING
 	    curwin = wp;
diff -Naur vim73.orig/src/edit.c vim73/src/edit.c
--- vim73.orig/src/edit.c	2010-08-08 12:55:05.000000000 +0000
+++ vim73/src/edit.c	2011-05-17 09:39:15.913661372 +0000
@@ -58,6 +58,10 @@
 };
 
 static char e_hitend[] = N_("Hit end of paragraph");
+#ifdef FEAT_COMPL_FUNC
+static char e_complwin[] = N_("E839: Completion function changed window");
+static char e_compldel[] = N_("E840: Completion function deleted text");
+#endif
 
 /*
  * Structure used to store one match for insert completion.
@@ -1549,12 +1553,16 @@
 ins_ctrl_v()
 {
     int		c;
+    int		did_putchar = FALSE;
 
     /* may need to redraw when no more chars available now */
     ins_redraw(FALSE);
 
     if (redrawing() && !char_avail())
+    {
 	edit_putchar('^', TRUE);
+	did_putchar = TRUE;
+    }
     AppendToRedobuff((char_u *)CTRL_V_STR);	/* CTRL-V */
 
 #ifdef FEAT_CMDL_INFO
@@ -1562,8 +1570,10 @@
 #endif
 
     c = get_literal();
-    edit_unputchar();  /* when line fits in 'columns' the '^' is at the start
-			  of the next line and will not be redrawn */
+    if (did_putchar)
+	/* when the line fits in 'columns' the '^' is at the start of the next
+	 * line and will not removed by the redraw */
+	edit_unputchar();
 #ifdef FEAT_CMDL_INFO
     clear_showcmd();
 #endif
@@ -2658,6 +2668,7 @@
     if (stop_arrow() == FAIL)
 	return;
 
+    compl_direction = FORWARD;
     if (startcol > curwin->w_cursor.col)
 	startcol = curwin->w_cursor.col;
     compl_col = startcol;
@@ -3833,6 +3844,8 @@
     char_u	*args[2];
     char_u	*funcname;
     pos_T	pos;
+    win_T	*curwin_save;
+    buf_T	*curbuf_save;
 
     funcname = (type == CTRL_X_FUNCTION) ? curbuf->b_p_cfu : curbuf->b_p_ofu;
     if (*funcname == NUL)
@@ -3843,13 +3856,27 @@
     args[1] = base;
 
     pos = curwin->w_cursor;
+    curwin_save = curwin;
+    curbuf_save = curbuf;
     matchlist = call_func_retlist(funcname, 2, args, FALSE);
+    if (curwin_save != curwin || curbuf_save != curbuf)
+    {
+	EMSG(_(e_complwin));
+	goto theend;
+    }
     curwin->w_cursor = pos;	/* restore the cursor position */
-    if (matchlist == NULL)
-	return;
+    check_cursor();
+    if (!equalpos(curwin->w_cursor, pos))
+    {
+	EMSG(_(e_compldel));
+	goto theend;
+    }
+    if (matchlist != NULL)
+	ins_compl_add_list(matchlist);
 
-    ins_compl_add_list(matchlist);
-    list_unref(matchlist);
+theend:
+    if (matchlist != NULL)
+	list_unref(matchlist);
 }
 #endif /* FEAT_COMPL_FUNC */
 
@@ -3889,6 +3916,7 @@
     char_u	*word;
     int		icase = FALSE;
     int		adup = FALSE;
+    int		aempty = FALSE;
     char_u	*(cptext[CPT_COUNT]);
 
     if (tv->v_type == VAR_DICT && tv->vval.v_dict != NULL)
@@ -3906,13 +3934,15 @@
 	    icase = get_dict_number(tv->vval.v_dict, (char_u *)"icase");
 	if (get_dict_string(tv->vval.v_dict, (char_u *)"dup", FALSE) != NULL)
 	    adup = get_dict_number(tv->vval.v_dict, (char_u *)"dup");
+	if (get_dict_string(tv->vval.v_dict, (char_u *)"empty", FALSE) != NULL)
+	    aempty = get_dict_number(tv->vval.v_dict, (char_u *)"empty");
     }
     else
     {
 	word = get_tv_string_chk(tv);
 	vim_memset(cptext, 0, sizeof(cptext));
     }
-    if (word == NULL || *word == NUL)
+    if (word == NULL || (!aempty && *word == NUL))
 	return FAIL;
     return ins_compl_add(word, -1, icase, NULL, cptext, dir, 0, adup);
 }
@@ -4994,6 +5024,8 @@
 	    int		col;
 	    char_u	*funcname;
 	    pos_T	pos;
+	    win_T	*curwin_save;
+	    buf_T	*curbuf_save;
 
 	    /* Call 'completefunc' or 'omnifunc' and get pattern length as a
 	     * string */
@@ -5009,8 +5041,21 @@
 	    args[0] = (char_u *)"1";
 	    args[1] = NULL;
 	    pos = curwin->w_cursor;
+	    curwin_save = curwin;
+	    curbuf_save = curbuf;
 	    col = call_func_retnr(funcname, 2, args, FALSE);
+	    if (curwin_save != curwin || curbuf_save != curbuf)
+	    {
+		EMSG(_(e_complwin));
+		return FAIL;
+	    }
 	    curwin->w_cursor = pos;	/* restore the cursor position */
+	    check_cursor();
+	    if (!equalpos(curwin->w_cursor, pos))
+	    {
+		EMSG(_(e_compldel));
+		return FAIL;
+	    }
 
 	    if (col < 0)
 		col = curs_col;
@@ -9598,6 +9643,7 @@
 {
     int	    c;
     int	    cc;
+    int	    did_putchar = FALSE;
 
     pc_status = PC_STATUS_UNSET;
     if (redrawing() && !char_avail())
@@ -9606,6 +9652,7 @@
 	ins_redraw(FALSE);
 
 	edit_putchar('?', TRUE);
+	did_putchar = TRUE;
 #ifdef FEAT_CMDL_INFO
 	add_to_showcmd_c(Ctrl_K);
 #endif
@@ -9622,8 +9669,10 @@
     c = plain_vgetc();
     --no_mapping;
     --allow_keys;
-    edit_unputchar();  /* when line fits in 'columns' the '?' is at the start
-			  of the next line and will not be redrawn */
+    if (did_putchar)
+	/* when the line fits in 'columns' the '?' is at the start of the next
+	 * line and will not be removed by the redraw */
+	edit_unputchar();
 
     if (IS_SPECIAL(c) || mod_mask)	    /* special key */
     {
@@ -9635,6 +9684,7 @@
     }
     if (c != ESC)
     {
+	did_putchar = FALSE;
 	if (redrawing() && !char_avail())
 	{
 	    /* may need to redraw when no more chars available now */
@@ -9642,11 +9692,9 @@
 
 	    if (char2cells(c) == 1)
 	    {
-		/* first remove the '?', otherwise it's restored when typing
-		 * an ESC next */
-		edit_unputchar();
 		ins_redraw(FALSE);
 		edit_putchar(c, TRUE);
+		did_putchar = TRUE;
 	    }
 #ifdef FEAT_CMDL_INFO
 	    add_to_showcmd_c(c);
@@ -9657,8 +9705,10 @@
 	cc = plain_vgetc();
 	--no_mapping;
 	--allow_keys;
-	edit_unputchar();  /* when line fits in 'columns' the '?' is at the
-			      start of the next line and will not be redrawn */
+	if (did_putchar)
+	    /* when the line fits in 'columns' the '?' is at the start of the
+	     * next line and will not be removed by a redraw */
+	    edit_unputchar();
 	if (cc != ESC)
 	{
 	    AppendToRedobuff((char_u *)CTRL_V_STR);
diff -Naur vim73.orig/src/eval.c vim73/src/eval.c
--- vim73.orig/src/eval.c	2010-08-09 20:12:14.000000000 +0000
+++ vim73/src/eval.c	2011-05-17 09:39:31.595920869 +0000
@@ -10,9 +10,6 @@
 /*
  * eval.c: Expression evaluation.
  */
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for mch_open(), must be before vim.h */
-#endif
 
 #include "vim.h"
 
@@ -362,6 +359,7 @@
     {VV_NAME("operator",	 VAR_STRING), VV_RO},
     {VV_NAME("searchforward",	 VAR_NUMBER), 0},
     {VV_NAME("oldfiles",	 VAR_LIST), 0},
+    {VV_NAME("windowid",	 VAR_NUMBER), VV_RO},
 };
 
 /* shorthand */
@@ -433,9 +431,9 @@
 static void listitem_free __ARGS((listitem_T *item));
 static void listitem_remove __ARGS((list_T *l, listitem_T *item));
 static long list_len __ARGS((list_T *l));
-static int list_equal __ARGS((list_T *l1, list_T *l2, int ic));
-static int dict_equal __ARGS((dict_T *d1, dict_T *d2, int ic));
-static int tv_equal __ARGS((typval_T *tv1, typval_T *tv2, int ic));
+static int list_equal __ARGS((list_T *l1, list_T *l2, int ic, int recursive));
+static int dict_equal __ARGS((dict_T *d1, dict_T *d2, int ic, int recursive));
+static int tv_equal __ARGS((typval_T *tv1, typval_T *tv2, int ic, int recursive));
 static listitem_T *list_find __ARGS((list_T *l, long n));
 static long list_find_nr __ARGS((list_T *l, long idx, int *errorp));
 static long list_idx_of_item __ARGS((list_T *l, listitem_T *item));
@@ -791,6 +789,8 @@
 static void set_var __ARGS((char_u *name, typval_T *varp, int copy));
 static int var_check_ro __ARGS((int flags, char_u *name));
 static int var_check_fixed __ARGS((int flags, char_u *name));
+static int var_check_func_name __ARGS((char_u *name, int new_var));
+static int valid_varname __ARGS((char_u *varname));
 static int tv_check_lock __ARGS((int lock, char_u *name));
 static int item_copy __ARGS((typval_T *from, typval_T *to, int deep, int copyID));
 static char_u *find_option_end __ARGS((char_u **arg, int *opt_flags));
@@ -853,6 +853,7 @@
 
     init_var_dict(&globvardict, &globvars_var);
     init_var_dict(&vimvardict, &vimvars_var);
+    vimvardict.dv_lock = VAR_FIXED;
     hash_init(&compat_hashtab);
     hash_init(&func_hashtab);
 
@@ -2325,7 +2326,7 @@
 	    else if (endchars != NULL
 			     && vim_strchr(endchars, *skipwhite(arg)) == NULL)
 		EMSG(_(e_letunexp));
-	    else
+	    else if (!check_secure())
 	    {
 		c1 = name[len];
 		name[len] = NUL;
@@ -2718,8 +2719,27 @@
 	    lp->ll_list = NULL;
 	    lp->ll_dict = lp->ll_tv->vval.v_dict;
 	    lp->ll_di = dict_find(lp->ll_dict, key, len);
+
+	    /* When assigning to g: check that a function and variable name is
+	     * valid. */
+	    if (rettv != NULL && lp->ll_dict == &globvardict)
+	    {
+		if (rettv->v_type == VAR_FUNC
+			       && var_check_func_name(key, lp->ll_di == NULL))
+		    return NULL;
+		if (!valid_varname(key))
+		    return NULL;
+	    }
+
 	    if (lp->ll_di == NULL)
 	    {
+		/* Can't add "v:" variable. */
+		if (lp->ll_dict == &vimvardict)
+		{
+		    EMSG2(_(e_illvar), name);
+		    return NULL;
+		}
+
 		/* Key does not exist in dict: may need to add it. */
 		if (*p == '[' || *p == '.' || unlet)
 		{
@@ -2739,6 +2759,10 @@
 		    p = NULL;
 		break;
 	    }
+	    /* existing variable, need to check if it can be changed */
+	    else if (var_check_ro(lp->ll_di->di_flags, name))
+		return NULL;
+
 	    if (len == -1)
 		clear_tv(&var1);
 	    lp->ll_tv = &lp->ll_di->di_tv;
@@ -2770,6 +2794,8 @@
 	    {
 		if (lp->ll_range && !lp->ll_empty2)
 		    clear_tv(&var2);
+		if (!quiet)
+		    EMSGN(_(e_listidx), lp->ll_n1);
 		return NULL;
 	    }
 
@@ -2787,7 +2813,11 @@
 		{
 		    ni = list_find(lp->ll_list, lp->ll_n2);
 		    if (ni == NULL)
+		    {
+			if (!quiet)
+			    EMSGN(_(e_listidx), lp->ll_n2);
 			return NULL;
+		    }
 		    lp->ll_n2 = list_idx_of_item(lp->ll_list, ni);
 		}
 
@@ -2795,7 +2825,11 @@
 		if (lp->ll_n1 < 0)
 		    lp->ll_n1 = list_idx_of_item(lp->ll_list, lp->ll_li);
 		if (lp->ll_n2 < lp->ll_n1)
+		{
+		    if (!quiet)
+			EMSGN(_(e_listidx), lp->ll_n2);
 		    return NULL;
+		}
 	    }
 
 	    lp->ll_tv = &lp->ll_li->li_tv;
@@ -3337,6 +3371,15 @@
     int		failed = FALSE;
     funcdict_T	fudi;
 
+    if (eap->skip)
+    {
+	/* trans_function_name() doesn't work well when skipping, use eval0()
+	 * instead to skip to any following command, e.g. for:
+	 *   :if 0 | call dict.foo().bar() | endif  */
+	eval0(eap->arg, &rettv, &eap->nextcmd, FALSE);
+	return;
+    }
+
     tofree = trans_function_name(&arg, eap->skip, TFN_INT, &fudi);
     if (fudi.fd_newkey != NULL)
     {
@@ -4349,7 +4392,8 @@
 		else
 		{
 		    /* Compare two Lists for being equal or unequal. */
-		    n1 = list_equal(rettv->vval.v_list, var2.vval.v_list, ic);
+		    n1 = list_equal(rettv->vval.v_list, var2.vval.v_list,
+								   ic, FALSE);
 		    if (type == TYPE_NEQUAL)
 			n1 = !n1;
 		}
@@ -4378,7 +4422,8 @@
 		else
 		{
 		    /* Compare two Dictionaries for being equal or unequal. */
-		    n1 = dict_equal(rettv->vval.v_dict, var2.vval.v_dict, ic);
+		    n1 = dict_equal(rettv->vval.v_dict, var2.vval.v_dict,
+								   ic, FALSE);
 		    if (type == TYPE_NEQUAL)
 			n1 = !n1;
 		}
@@ -5097,9 +5142,7 @@
 	    else
 		ret = OK;
 	}
-
-	if (alias != NULL)
-	    vim_free(alias);
+	vim_free(alias);
     }
 
     *arg = skipwhite(*arg);
@@ -5913,10 +5956,11 @@
  * Return TRUE when two lists have exactly the same values.
  */
     static int
-list_equal(l1, l2, ic)
+list_equal(l1, l2, ic, recursive)
     list_T	*l1;
     list_T	*l2;
     int		ic;	/* ignore case for strings */
+    int		recursive;  /* TRUE when used recursively */
 {
     listitem_T	*item1, *item2;
 
@@ -5930,7 +5974,7 @@
     for (item1 = l1->lv_first, item2 = l2->lv_first;
 	    item1 != NULL && item2 != NULL;
 			       item1 = item1->li_next, item2 = item2->li_next)
-	if (!tv_equal(&item1->li_tv, &item2->li_tv, ic))
+	if (!tv_equal(&item1->li_tv, &item2->li_tv, ic, recursive))
 	    return FALSE;
     return item1 == NULL && item2 == NULL;
 }
@@ -5952,10 +5996,11 @@
  * Return TRUE when two dictionaries have exactly the same key/values.
  */
     static int
-dict_equal(d1, d2, ic)
+dict_equal(d1, d2, ic, recursive)
     dict_T	*d1;
     dict_T	*d2;
     int		ic;	/* ignore case for strings */
+    int		recursive; /* TRUE when used recursively */
 {
     hashitem_T	*hi;
     dictitem_T	*item2;
@@ -5976,7 +6021,7 @@
 	    item2 = dict_find(d2, hi->hi_key, -1);
 	    if (item2 == NULL)
 		return FALSE;
-	    if (!tv_equal(&HI2DI(hi)->di_tv, &item2->di_tv, ic))
+	    if (!tv_equal(&HI2DI(hi)->di_tv, &item2->di_tv, ic, recursive))
 		return FALSE;
 	    --todo;
 	}
@@ -5984,41 +6029,54 @@
     return TRUE;
 }
 
+static int tv_equal_recurse_limit;
+
 /*
  * Return TRUE if "tv1" and "tv2" have the same value.
  * Compares the items just like "==" would compare them, but strings and
  * numbers are different.  Floats and numbers are also different.
  */
     static int
-tv_equal(tv1, tv2, ic)
+tv_equal(tv1, tv2, ic, recursive)
     typval_T *tv1;
     typval_T *tv2;
-    int	    ic;	    /* ignore case */
+    int	     ic;	    /* ignore case */
+    int	     recursive;	    /* TRUE when used recursively */
 {
     char_u	buf1[NUMBUFLEN], buf2[NUMBUFLEN];
     char_u	*s1, *s2;
-    static int  recursive = 0;	    /* cach recursive loops */
+    static int  recursive_cnt = 0;	    /* catch recursive loops */
     int		r;
 
     if (tv1->v_type != tv2->v_type)
 	return FALSE;
+
     /* Catch lists and dicts that have an endless loop by limiting
-     * recursiveness to 1000.  We guess they are equal then. */
-    if (recursive >= 1000)
+     * recursiveness to a limit.  We guess they are equal then.
+     * A fixed limit has the problem of still taking an awful long time.
+     * Reduce the limit every time running into it. That should work fine for
+     * deeply linked structures that are not recursively linked and catch
+     * recursiveness quickly. */
+    if (!recursive)
+	tv_equal_recurse_limit = 1000;
+    if (recursive_cnt >= tv_equal_recurse_limit)
+    {
+	--tv_equal_recurse_limit;
 	return TRUE;
+    }
 
     switch (tv1->v_type)
     {
 	case VAR_LIST:
-	    ++recursive;
-	    r = list_equal(tv1->vval.v_list, tv2->vval.v_list, ic);
-	    --recursive;
+	    ++recursive_cnt;
+	    r = list_equal(tv1->vval.v_list, tv2->vval.v_list, ic, TRUE);
+	    --recursive_cnt;
 	    return r;
 
 	case VAR_DICT:
-	    ++recursive;
-	    r = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic);
-	    --recursive;
+	    ++recursive_cnt;
+	    r = dict_equal(tv1->vval.v_dict, tv2->vval.v_dict, ic, TRUE);
+	    --recursive_cnt;
 	    return r;
 
 	case VAR_FUNC:
@@ -7075,7 +7133,7 @@
 }
 
 /*
- * Add a list  entry to dictionary "d".
+ * Add a list entry to dictionary "d".
  * Returns FAIL when out of memory and when key already exists.
  */
     int
@@ -7097,6 +7155,7 @@
 	dictitem_free(item);
 	return FAIL;
     }
+    ++list->lv_refcount;
     return OK;
 }
 
@@ -7802,7 +7861,7 @@
     {"log10",		1, 1, f_log10},
 #endif
     {"map",		2, 2, f_map},
-    {"maparg",		1, 3, f_maparg},
+    {"maparg",		1, 4, f_maparg},
     {"mapcheck",	1, 3, f_mapcheck},
     {"match",		2, 4, f_match},
     {"matchadd",	2, 4, f_matchadd},
@@ -8497,7 +8556,7 @@
     if (argvars[0].v_type == VAR_LIST)
     {
 	if ((l = argvars[0].vval.v_list) != NULL
-		&& !tv_check_lock(l->lv_lock, (char_u *)"add()")
+		&& !tv_check_lock(l->lv_lock, (char_u *)_("add() argument"))
 		&& list_append_tv(l, &argvars[1]) == OK)
 	    copy_tv(&argvars[0], rettv);
     }
@@ -9298,7 +9357,7 @@
 
     if (!error)
 	rettv->vval.v_number = do_dialog(type, NULL, message, buttons,
-								   def, NULL);
+							    def, NULL, FALSE);
 #endif
 }
 
@@ -9389,7 +9448,7 @@
 	    }
 
 	    for ( ; li != NULL; li = li->li_next)
-		if (tv_equal(&li->li_tv, &argvars[1], ic))
+		if (tv_equal(&li->li_tv, &argvars[1], ic, FALSE))
 		    ++n;
 	}
     }
@@ -9416,7 +9475,7 @@
 		if (!HASHITEM_EMPTY(hi))
 		{
 		    --todo;
-		    if (tv_equal(&HI2DI(hi)->di_tv, &argvars[1], ic))
+		    if (tv_equal(&HI2DI(hi)->di_tv, &argvars[1], ic, FALSE))
 			++n;
 		}
 	    }
@@ -9857,7 +9916,7 @@
     char_u	*s;
     int		len;
     char_u	*errormsg;
-    int		flags = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;
+    int		options = WILD_SILENT|WILD_USE_NL|WILD_LIST_NOTFOUND;
     expand_T	xpc;
     int		error = FALSE;
 
@@ -9875,12 +9934,14 @@
 	 * for 'wildignore' and don't put matches for 'suffixes' at the end. */
 	if (argvars[1].v_type != VAR_UNKNOWN
 				    && get_tv_number_chk(&argvars[1], &error))
-	    flags |= WILD_KEEP_ALL;
+	    options |= WILD_KEEP_ALL;
 	if (!error)
 	{
 	    ExpandInit(&xpc);
 	    xpc.xp_context = EXPAND_FILES;
-	    rettv->vval.v_string = ExpandOne(&xpc, s, NULL, flags, WILD_ALL);
+	    if (p_wic)
+		options += WILD_ICASE;
+	    rettv->vval.v_string = ExpandOne(&xpc, s, NULL, options, WILD_ALL);
 	}
 	else
 	    rettv->vval.v_string = NULL;
@@ -9896,6 +9957,8 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
+    char      *arg_errmsg = N_("extend() argument");
+
     if (argvars[0].v_type == VAR_LIST && argvars[1].v_type == VAR_LIST)
     {
 	list_T		*l1, *l2;
@@ -9905,7 +9968,7 @@
 
 	l1 = argvars[0].vval.v_list;
 	l2 = argvars[1].vval.v_list;
-	if (l1 != NULL && !tv_check_lock(l1->lv_lock, (char_u *)"extend()")
+	if (l1 != NULL && !tv_check_lock(l1->lv_lock, (char_u *)_(arg_errmsg))
 		&& l2 != NULL)
 	{
 	    if (argvars[2].v_type != VAR_UNKNOWN)
@@ -9944,7 +10007,7 @@
 
 	d1 = argvars[0].vval.v_dict;
 	d2 = argvars[1].vval.v_dict;
-	if (d1 != NULL && !tv_check_lock(d1->dv_lock, (char_u *)"extend()")
+	if (d1 != NULL && !tv_check_lock(d1->dv_lock, (char_u *)_(arg_errmsg))
 		&& d2 != NULL)
 	{
 	    /* Check the third argument. */
@@ -10186,20 +10249,22 @@
     typval_T	save_key;
     int		rem;
     int		todo;
-    char_u	*ermsg = map ? (char_u *)"map()" : (char_u *)"filter()";
+    char_u	*ermsg = (char_u *)(map ? "map()" : "filter()");
+    char	*arg_errmsg = (map ? N_("map() argument")
+				   : N_("filter() argument"));
     int		save_did_emsg;
     int		idx = 0;
 
     if (argvars[0].v_type == VAR_LIST)
     {
 	if ((l = argvars[0].vval.v_list) == NULL
-		|| (map && tv_check_lock(l->lv_lock, ermsg)))
+		|| tv_check_lock(l->lv_lock, (char_u *)_(arg_errmsg)))
 	    return;
     }
     else if (argvars[0].v_type == VAR_DICT)
     {
 	if ((d = argvars[0].vval.v_dict) == NULL
-		|| (map && tv_check_lock(d->dv_lock, ermsg)))
+		|| tv_check_lock(d->dv_lock, (char_u *)_(arg_errmsg)))
 	    return;
     }
     else
@@ -10236,7 +10301,8 @@
 		{
 		    --todo;
 		    di = HI2DI(hi);
-		    if (tv_check_lock(di->di_tv.v_lock, ermsg))
+		    if (tv_check_lock(di->di_tv.v_lock,
+						     (char_u *)_(arg_errmsg)))
 			break;
 		    vimvars[VV_KEY].vv_str = vim_strsave(di->di_key);
 		    if (filter_map_one(&di->di_tv, expr, map, &rem) == FAIL
@@ -10255,7 +10321,7 @@
 
 	    for (li = l->lv_first; li != NULL; li = nli)
 	    {
-		if (tv_check_lock(li->li_tv.v_lock, ermsg))
+		if (tv_check_lock(li->li_tv.v_lock, (char_u *)_(arg_errmsg)))
 		    break;
 		nli = li->li_next;
 		vimvars[VV_KEY].vv_nr = idx;
@@ -10839,6 +10905,11 @@
 
 	if (*varname == '&')	/* buffer-local-option */
 	    get_option_tv(&varname, rettv, TRUE);
+	else if (STRCMP(varname, "changedtick") == 0)
+	{
+	    rettv->v_type = VAR_NUMBER;
+	    rettv->vval.v_number = curbuf->b_changedtick;
+	}
 	else
 	{
 	    if (*varname == NUL)
@@ -11039,18 +11110,22 @@
     typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
-    char_u	cwd[MAXPATHL];
+    char_u	*cwd;
 
     rettv->v_type = VAR_STRING;
-    if (mch_dirname(cwd, MAXPATHL) == FAIL)
-	rettv->vval.v_string = NULL;
-    else
+    rettv->vval.v_string = NULL;
+    cwd = alloc(MAXPATHL);
+    if (cwd != NULL)
     {
-	rettv->vval.v_string = vim_strsave(cwd);
+	if (mch_dirname(cwd, MAXPATHL) != FAIL)
+	{
+	    rettv->vval.v_string = vim_strsave(cwd);
 #ifdef BACKSLASH_IN_FILENAME
-	if (rettv->vval.v_string != NULL)
-	    slash_adjust(rettv->vval.v_string);
+	    if (rettv->vval.v_string != NULL)
+		slash_adjust(rettv->vval.v_string);
 #endif
+	}
+	vim_free(cwd);
     }
 }
 
@@ -11653,7 +11728,7 @@
     typval_T	*argvars;
     typval_T	*rettv;
 {
-    int		flags = WILD_SILENT|WILD_USE_NL;
+    int		options = WILD_SILENT|WILD_USE_NL;
     expand_T	xpc;
     int		error = FALSE;
 
@@ -11661,14 +11736,16 @@
     * for 'wildignore' and don't put matches for 'suffixes' at the end. */
     if (argvars[1].v_type != VAR_UNKNOWN
 				&& get_tv_number_chk(&argvars[1], &error))
-	flags |= WILD_KEEP_ALL;
+	options |= WILD_KEEP_ALL;
     rettv->v_type = VAR_STRING;
     if (!error)
     {
 	ExpandInit(&xpc);
 	xpc.xp_context = EXPAND_FILES;
+	if (p_wic)
+	    options += WILD_ICASE;
 	rettv->vval.v_string = ExpandOne(&xpc, get_tv_string(&argvars[0]),
-						       NULL, flags, WILD_ALL);
+						     NULL, options, WILD_ALL);
     }
     else
 	rettv->vval.v_string = NULL;
@@ -11741,9 +11818,6 @@
 #ifdef __QNX__
 	"qnx",
 #endif
-#ifdef RISCOS
-	"riscos",
-#endif
 #ifdef UNIX
 	"unix",
 #endif
@@ -12116,6 +12190,9 @@
 #ifdef FEAT_TOOLBAR
 	"toolbar",
 #endif
+#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+	"unnamedplus",
+#endif
 #ifdef FEAT_USR_CMDS
 	"user-commands",    /* was accidentally included in 5.4 */
 	"user_commands",
@@ -12572,7 +12649,7 @@
 	}
 
 	for ( ; item != NULL; item = item->li_next, ++idx)
-	    if (tv_equal(&item->li_tv, &argvars[1], ic))
+	    if (tv_equal(&item->li_tv, &argvars[1], ic, FALSE))
 	    {
 		rettv->vval.v_number = idx;
 		break;
@@ -12712,7 +12789,7 @@
 	    IObuff[0] = NUL;
 	if (message != NULL && defstr != NULL
 		&& do_dialog(VIM_QUESTION, NULL, message,
-				(char_u *)_("&OK\n&Cancel"), 1, IObuff) == 1)
+			  (char_u *)_("&OK\n&Cancel"), 1, IObuff, FALSE) == 1)
 	    rettv->vval.v_string = vim_strsave(IObuff);
 	else
 	{
@@ -12850,7 +12927,7 @@
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "insert()");
     else if ((l = argvars[0].vval.v_list) != NULL
-	    && !tv_check_lock(l->lv_lock, (char_u *)"insert()"))
+	    && !tv_check_lock(l->lv_lock, (char_u *)_("insert() argument")))
     {
 	if (argvars[2].v_type != VAR_UNKNOWN)
 	    before = get_tv_number_chk(&argvars[2], &error);
@@ -13290,8 +13367,10 @@
     char_u	*keys_buf = NULL;
     char_u	*rhs;
     int		mode;
-    garray_T	ga;
     int		abbr = FALSE;
+    int         get_dict = FALSE;
+    mapblock_T	*mp;
+    int		buffer_local;
 
     /* return empty string for failure */
     rettv->v_type = VAR_STRING;
@@ -13305,7 +13384,11 @@
     {
 	which = get_tv_string_buf_chk(&argvars[1], buf);
 	if (argvars[2].v_type != VAR_UNKNOWN)
+	{
 	    abbr = get_tv_number(&argvars[2]);
+	    if (argvars[3].v_type != VAR_UNKNOWN)
+		get_dict = get_tv_number(&argvars[3]);
+	}
     }
     else
 	which = (char_u *)"";
@@ -13315,19 +13398,34 @@
     mode = get_map_mode(&which, 0);
 
     keys = replace_termcodes(keys, &keys_buf, TRUE, TRUE, FALSE);
-    rhs = check_map(keys, mode, exact, FALSE, abbr);
+    rhs = check_map(keys, mode, exact, FALSE, abbr, &mp, &buffer_local);
     vim_free(keys_buf);
-    if (rhs != NULL)
-    {
-	ga_init(&ga);
-	ga.ga_itemsize = 1;
-	ga.ga_growsize = 40;
 
-	while (*rhs != NUL)
-	    ga_concat(&ga, str2special(&rhs, FALSE));
+    if (!get_dict)
+    {
+	/* Return a string. */
+	if (rhs != NULL)
+	    rettv->vval.v_string = str2special_save(rhs, FALSE);
+
+    }
+    else if (rettv_dict_alloc(rettv) != FAIL && rhs != NULL)
+    {
+	/* Return a dictionary. */
+	char_u	    *lhs = str2special_save(mp->m_keys, TRUE);
+	char_u	    *mapmode = map_mode_to_chars(mp->m_mode);
+	dict_T	    *dict = rettv->vval.v_dict;
+
+	dict_add_nr_str(dict, "lhs",	 0L, lhs);
+	dict_add_nr_str(dict, "rhs",     0L, mp->m_orig_str);
+	dict_add_nr_str(dict, "noremap", mp->m_noremap ? 1L : 0L , NULL);
+	dict_add_nr_str(dict, "expr",    mp->m_expr    ? 1L : 0L, NULL);
+	dict_add_nr_str(dict, "silent",  mp->m_silent  ? 1L : 0L, NULL);
+	dict_add_nr_str(dict, "sid",     (long)mp->m_script_ID, NULL);
+	dict_add_nr_str(dict, "buffer",  (long)buffer_local, NULL);
+	dict_add_nr_str(dict, "mode",    0L, mapmode);
 
-	ga_append(&ga, NUL);
-	rettv->vval.v_string = (char_u *)ga.ga_data;
+	vim_free(lhs);
+	vim_free(mapmode);
     }
 }
 
@@ -14224,9 +14322,9 @@
 	{
 	    if (buf[filtd] == '\n' || readlen <= 0)
 	    {
-		/* Only when in binary mode add an empty list item when the
-		 * last line ends in a '\n'. */
-		if (!binary && readlen == 0 && filtd == 0)
+		/* In binary mode add an empty list item when the last
+		 * non-empty line ends in a '\n'. */
+		if (!binary && readlen == 0 && filtd == 0 && prev == NULL)
 		    break;
 
 		/* Found end-of-line or end-of-file: add a text line to the
@@ -14291,25 +14389,28 @@
 
 	if (tolist == 0)
 	{
-	    /* "buf" is full, need to move text to an allocated buffer */
-	    if (prev == NULL)
+	    if (buflen >= FREAD_SIZE / 2)
 	    {
-		prev = vim_strnsave(buf, buflen);
-		prevlen = buflen;
-	    }
-	    else
-	    {
-		s = alloc((unsigned)(prevlen + buflen));
-		if (s != NULL)
+		/* "buf" is full, need to move text to an allocated buffer */
+		if (prev == NULL)
 		{
-		    mch_memmove(s, prev, prevlen);
-		    mch_memmove(s + prevlen, buf, buflen);
-		    vim_free(prev);
-		    prev = s;
-		    prevlen += buflen;
+		    prev = vim_strnsave(buf, buflen);
+		    prevlen = buflen;
 		}
+		else
+		{
+		    s = alloc((unsigned)(prevlen + buflen));
+		    if (s != NULL)
+		    {
+			mch_memmove(s, prev, prevlen);
+			mch_memmove(s + prevlen, buf, buflen);
+			vim_free(prev);
+			prev = s;
+			prevlen += buflen;
+		    }
+		}
+		filtd = 0;
 	    }
-	    filtd = 0;
 	}
 	else
 	{
@@ -14691,13 +14792,14 @@
     char_u	*key;
     dict_T	*d;
     dictitem_T	*di;
+    char	*arg_errmsg = N_("remove() argument");
 
     if (argvars[0].v_type == VAR_DICT)
     {
 	if (argvars[2].v_type != VAR_UNKNOWN)
 	    EMSG2(_(e_toomanyarg), "remove()");
 	else if ((d = argvars[0].vval.v_dict) != NULL
-		&& !tv_check_lock(d->dv_lock, (char_u *)"remove() argument"))
+		&& !tv_check_lock(d->dv_lock, (char_u *)_(arg_errmsg)))
 	{
 	    key = get_tv_string_chk(&argvars[1]);
 	    if (key != NULL)
@@ -14717,7 +14819,7 @@
     else if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listdictarg), "remove()");
     else if ((l = argvars[0].vval.v_list) != NULL
-	    && !tv_check_lock(l->lv_lock, (char_u *)"remove() argument"))
+	    && !tv_check_lock(l->lv_lock, (char_u *)_(arg_errmsg)))
     {
 	int	    error = FALSE;
 
@@ -14847,6 +14949,9 @@
     typval_T	*rettv;
 {
     char_u	*p;
+#ifdef HAVE_READLINK
+    char_u	*buf = NULL;
+#endif
 
     p = get_tv_string(&argvars[0]);
 #ifdef FEAT_SHORTCUT
@@ -14862,7 +14967,6 @@
 #else
 # ifdef HAVE_READLINK
     {
-	char_u	buf[MAXPATHL + 1];
 	char_u	*cpy;
 	int	len;
 	char_u	*remain = NULL;
@@ -14890,6 +14994,10 @@
 	    q[-1] = NUL;
 	}
 
+	buf = alloc(MAXPATHL + 1);
+	if (buf == NULL)
+	    goto fail;
+
 	for (;;)
 	{
 	    for (;;)
@@ -15033,6 +15141,7 @@
 
 #ifdef HAVE_READLINK
 fail:
+    vim_free(buf);
 #endif
     rettv->v_type = VAR_STRING;
 }
@@ -15051,7 +15160,7 @@
     if (argvars[0].v_type != VAR_LIST)
 	EMSG2(_(e_listarg), "reverse()");
     else if ((l = argvars[0].vval.v_list) != NULL
-	    && !tv_check_lock(l->lv_lock, (char_u *)"reverse()"))
+	    && !tv_check_lock(l->lv_lock, (char_u *)_("reverse() argument")))
     {
 	li = l->lv_last;
 	l->lv_first = l->lv_last = NULL;
@@ -16348,7 +16457,8 @@
     else
     {
 	l = argvars[0].vval.v_list;
-	if (l == NULL || tv_check_lock(l->lv_lock, (char_u *)"sort()"))
+	if (l == NULL || tv_check_lock(l->lv_lock,
+					     (char_u *)_("sort() argument")))
 	    return;
 	rettv->vval.v_list = l;
 	rettv->v_type = VAR_LIST;
@@ -17512,18 +17622,22 @@
     typval_T	*argvars UNUSED;
     typval_T	*rettv;
 {
-    char_u	fname[MAXPATHL + 1];
+    char_u	*fname;
     tagname_T	tn;
     int		first;
 
     if (rettv_list_alloc(rettv) == FAIL)
 	return;
+    fname = alloc(MAXPATHL);
+    if (fname == NULL)
+	return;
 
     for (first = TRUE; ; first = FALSE)
 	if (get_tagfname(&tn, first, fname) == FAIL
 		|| list_append_string(rettv->vval.v_list, fname, -1) == FAIL)
 	    break;
     tagname_free(&tn);
+    vim_free(fname);
 }
 
 /*
@@ -19730,7 +19844,6 @@
     dictitem_T	*v;
     char_u	*varname;
     hashtab_T	*ht;
-    char_u	*p;
 
     ht = find_var_ht(name, &varname);
     if (ht == NULL || *varname == NUL)
@@ -19740,25 +19853,8 @@
     }
     v = find_var_in_ht(ht, varname, TRUE);
 
-    if (tv->v_type == VAR_FUNC)
-    {
-	if (!(vim_strchr((char_u *)"wbs", name[0]) != NULL && name[1] == ':')
-		&& !ASCII_ISUPPER((name[0] != NUL && name[1] == ':')
-							 ? name[2] : name[0]))
-	{
-	    EMSG2(_("E704: Funcref variable name must start with a capital: %s"), name);
-	    return;
-	}
-	/* Don't allow hiding a function.  When "v" is not NULL we migth be
-	 * assigning another function to the same var, the type is checked
-	 * below. */
-	if (v == NULL && function_exists(name))
-	{
-	    EMSG2(_("E705: Variable name conflicts with existing function: %s"),
-									name);
-	    return;
-	}
-    }
+    if (tv->v_type == VAR_FUNC && var_check_func_name(name, v == NULL))
+	return;
 
     if (v != NULL)
     {
@@ -19824,13 +19920,8 @@
 	}
 
 	/* Make sure the variable name is valid. */
-	for (p = varname; *p != NUL; ++p)
-	    if (!eval_isnamec1(*p) && (p == varname || !VIM_ISDIGIT(*p))
-						       && *p != AUTOLOAD_CHAR)
-	    {
-		EMSG2(_(e_illvar), varname);
-		return;
-	    }
+	if (!valid_varname(varname))
+	    return;
 
 	v = (dictitem_T *)alloc((unsigned)(sizeof(dictitem_T)
 							  + STRLEN(varname)));
@@ -19895,6 +19986,55 @@
 }
 
 /*
+ * Check if a funcref is assigned to a valid variable name.
+ * Return TRUE and give an error if not.
+ */
+    static int
+var_check_func_name(name, new_var)
+    char_u *name;    /* points to start of variable name */
+    int    new_var;  /* TRUE when creating the variable */
+{
+    if (!(vim_strchr((char_u *)"wbs", name[0]) != NULL && name[1] == ':')
+	    && !ASCII_ISUPPER((name[0] != NUL && name[1] == ':')
+						     ? name[2] : name[0]))
+    {
+	EMSG2(_("E704: Funcref variable name must start with a capital: %s"),
+									name);
+	return TRUE;
+    }
+    /* Don't allow hiding a function.  When "v" is not NULL we might be
+     * assigning another function to the same var, the type is checked
+     * below. */
+    if (new_var && function_exists(name))
+    {
+	EMSG2(_("E705: Variable name conflicts with existing function: %s"),
+								    name);
+	return TRUE;
+    }
+    return FALSE;
+}
+
+/*
+ * Check if a variable name is valid.
+ * Return FALSE and give an error if not.
+ */
+    static int
+valid_varname(varname)
+    char_u *varname;
+{
+    char_u *p;
+
+    for (p = varname; *p != NUL; ++p)
+	if (!eval_isnamec1(*p) && (p == varname || !VIM_ISDIGIT(*p))
+						   && *p != AUTOLOAD_CHAR)
+	{
+	    EMSG2(_(e_illvar), varname);
+	    return FALSE;
+	}
+    return TRUE;
+}
+
+/*
  * Return TRUE if typeval "tv" is set to be locked (immutable).
  * Also give an error message, using "name".
  */
@@ -22519,18 +22659,21 @@
 	if (tab != NULL)
 	{
 	    *tab++ = '\0';	/* isolate the variable name */
-	    if (*tab == 'S')	/* string var */
-		type = VAR_STRING;
+	    switch (*tab)
+	    {
+		case 'S': type = VAR_STRING; break;
 #ifdef FEAT_FLOAT
-	    else if (*tab == 'F')
-		type = VAR_FLOAT;
+		case 'F': type = VAR_FLOAT; break;
 #endif
+		case 'D': type = VAR_DICT; break;
+		case 'L': type = VAR_LIST; break;
+	    }
 
 	    tab = vim_strchr(tab, '\t');
 	    if (tab != NULL)
 	    {
 		tv.v_type = type;
-		if (type == VAR_STRING)
+		if (type == VAR_STRING || type == VAR_DICT || type == VAR_LIST)
 		    tv.vval.v_string = viminfo_readstring(virp,
 				       (int)(tab - virp->vir_line + 1), TRUE);
 #ifdef FEAT_FLOAT
@@ -22539,9 +22682,27 @@
 #endif
 		else
 		    tv.vval.v_number = atol((char *)tab + 1);
+		if (type == VAR_DICT || type == VAR_LIST)
+		{
+		    typval_T *etv = eval_expr(tv.vval.v_string, NULL);
+
+		    if (etv == NULL)
+			/* Failed to parse back the dict or list, use it as a
+			 * string. */
+			tv.v_type = VAR_STRING;
+		    else
+		    {
+			vim_free(tv.vval.v_string);
+			tv = *etv;
+		    }
+		}
+
 		set_var(virp->vir_line + 1, &tv, FALSE);
-		if (type == VAR_STRING)
+
+		if (tv.v_type == VAR_STRING)
 		    vim_free(tv.vval.v_string);
+		else if (tv.v_type == VAR_DICT || tv.v_type == VAR_LIST)
+		    clear_tv(&tv);
 	    }
 	}
     }
@@ -22583,8 +22744,10 @@
 		    case VAR_STRING: s = "STR"; break;
 		    case VAR_NUMBER: s = "NUM"; break;
 #ifdef FEAT_FLOAT
-		    case VAR_FLOAT: s = "FLO"; break;
+		    case VAR_FLOAT:  s = "FLO"; break;
 #endif
+		    case VAR_DICT:   s = "DIC"; break;
+		    case VAR_LIST:   s = "LIS"; break;
 		    default: continue;
 		}
 		fprintf(fp, "!%s\t%s\t", this_var->di_key, s);
diff -Naur vim73.orig/src/ex_cmds.c vim73/src/ex_cmds.c
--- vim73.orig/src/ex_cmds.c	2010-08-13 09:14:35.000000000 +0000
+++ vim73/src/ex_cmds.c	2011-05-17 09:39:31.599920425 +0000
@@ -11,10 +11,6 @@
  * ex_cmds.c: some functions for command line commands
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for mch_open(), must be before vim.h */
-#endif
-
 #include "vim.h"
 #include "version.h"
 
@@ -323,7 +319,8 @@
     /* When sorting numbers "start_col_nr" is the number, not the column
      * number. */
     if (sort_nr)
-	result = l1.start_col_nr - l2.start_col_nr;
+	result = l1.start_col_nr == l2.start_col_nr ? 0
+				 : l1.start_col_nr > l2.start_col_nr ? 1 : -1;
     else
     {
 	/* We need to copy one line into "sortbuf1", because there is no
@@ -482,7 +479,7 @@
 	     * of the match, by temporarily terminating the string there */
 	    s2 = s + end_col;
 	    c = *s2;
-	    (*s2) = 0;
+	    *s2 = NUL;
 	    /* Sorting on number: Store the number itself. */
 	    p = s + start_col;
 	    if (sort_hex)
@@ -491,9 +488,13 @@
 		s = skiptodigit(p);
 	    if (s > p && s[-1] == '-')
 		--s;  /* include preceding negative sign */
-	    vim_str2nr(s, NULL, NULL, sort_oct, sort_hex,
-					&nrs[lnum - eap->line1].start_col_nr, NULL);
-	    (*s2) = c;
+	    if (*s == NUL)
+		/* empty line should sort before any number */
+		nrs[lnum - eap->line1].start_col_nr = -MAXLNUM;
+	    else
+		vim_str2nr(s, NULL, NULL, sort_oct, sort_hex,
+				  &nrs[lnum - eap->line1].start_col_nr, NULL);
+	    *s2 = c;
 	}
 	else
 	{
@@ -898,9 +899,6 @@
  * Handle the ":!cmd" command.	Also for ":r !cmd" and ":w !cmd"
  * Bangs in the argument are replaced with the previously entered command.
  * Remember the argument.
- *
- * RISCOS: Bangs only replaced when followed by a space, since many
- * pathnames contain one.
  */
     void
 do_bang(addr_count, eap, forceit, do_in, do_out)
@@ -979,11 +977,7 @@
 	trailarg = NULL;
 	while (*p)
 	{
-	    if (*p == '!'
-#ifdef RISCOS
-			&& (p[1] == ' ' || p[1] == NUL)
-#endif
-					)
+	    if (*p == '!')
 	    {
 		if (p > newcmd && p[-1] == '\\')
 		    STRMOVE(p - 1, p);
@@ -1577,14 +1571,8 @@
 	    if (p != NULL)
 		*p = NUL;
 	}
-# ifdef RISCOS
-	STRCAT(buf, " { < ");	/* Use RISC OS notation for input. */
-	STRCAT(buf, itmp);
-	STRCAT(buf, " } ");
-# else
 	STRCAT(buf, " <");	/* " < " causes problems on Amiga */
 	STRCAT(buf, itmp);
-# endif
 	if (*p_shq == NUL)
 	{
 	    p = vim_strchr(cmd, '|');
@@ -1633,16 +1621,9 @@
     else
 	vim_snprintf((char *)end, (size_t)(buflen - (end - buf)),
 #ifdef FEAT_QUICKFIX
-# ifndef RISCOS
-		opt != p_sp ? " %s%s" :
-# endif
 		" %s %s",
 #else
-# ifndef RISCOS
 		" %s%s",	/* " > %s" causes problems on Amiga */
-# else
-		" %s %s",	/* But is needed for 'shellpipe' and RISC OS */
-# endif
 #endif
 		(char *)opt, (char *)fname);
 }
@@ -1843,11 +1824,7 @@
 #ifdef VMS
 				    (char_u *)"-tmp",
 #else
-# ifdef RISCOS
-				    (char_u *)"/tmp",
-# else
 				    (char_u *)".tmp",
-# endif
 #endif
 				    FALSE);
 	    if (tempname == NULL)		/* out of memory */
@@ -2700,6 +2677,10 @@
 									TRUE);
 		do_modelines(0);
 	    }
+
+	    /* Autocommands may have changed buffer names, esp. when
+	     * 'autochdir' is set. */
+	    fname = curbuf->b_sfname;
 #endif
 	}
 
@@ -2772,7 +2753,7 @@
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
 	    if (p_confirm || cmdmod.confirm)
 	    {
-		char_u	buff[IOSIZE];
+		char_u	buff[DIALOG_MSG_SIZE];
 
 		dialog_msg(buff, _("Overwrite existing file \"%s\"?"), fname);
 		if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 2) != VIM_YES)
@@ -2790,7 +2771,7 @@
 	/* For ":w! filename" check that no swap file exists for "filename". */
 	if (other && !emsg_silent)
 	{
-	    char_u	dir[MAXPATHL];
+	    char_u	*dir;
 	    char_u	*p;
 	    int		r;
 	    char_u	*swapname;
@@ -2801,20 +2782,29 @@
 	     * Use 'shortname' of the current buffer, since there is no buffer
 	     * for the written file. */
 	    if (*p_dir == NUL)
+	    {
+		dir = alloc(5);
+		if (dir == NULL)
+		    return FAIL;
 		STRCPY(dir, ".");
+	    }
 	    else
 	    {
+		dir = alloc(MAXPATHL);
+		if (dir == NULL)
+		    return FAIL;
 		p = p_dir;
 		copy_option_part(&p, dir, MAXPATHL, ",");
 	    }
 	    swapname = makeswapname(fname, ffname, curbuf, dir);
+	    vim_free(dir);
 	    r = vim_fexists(swapname);
 	    if (r)
 	    {
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
 		if (p_confirm || cmdmod.confirm)
 		{
-		    char_u	buff[IOSIZE];
+		    char_u	buff[DIALOG_MSG_SIZE];
 
 		    dialog_msg(buff,
 			    _("Swap file \"%s\" exists, overwrite anyway?"),
@@ -2964,7 +2954,7 @@
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
 	if ((p_confirm || cmdmod.confirm) && buf->b_fname != NULL)
 	{
-	    char_u	buff[IOSIZE];
+	    char_u	buff[DIALOG_MSG_SIZE];
 
 	    if (buf->b_p_ro)
 		dialog_msg(buff, _("'readonly' option is set for \"%s\".\nDo you wish to write anyway?"),
@@ -3498,9 +3488,7 @@
 	curbuf->b_p_bin = FALSE;	/* reset 'bin' before reading file */
 	curwin->w_p_nu = 0;		/* no line numbers */
 	curwin->w_p_rnu = 0;		/* no relative line numbers */
-#ifdef FEAT_SCROLLBIND
-	curwin->w_p_scb = FALSE;	/* no scroll binding */
-#endif
+	RESET_BINDING(curwin);		/* no scroll or cursor binding */
 #ifdef FEAT_ARABIC
 	curwin->w_p_arab = FALSE;	/* no arabic mode */
 #endif
@@ -5353,8 +5341,9 @@
 global_exe(cmd)
     char_u	*cmd;
 {
-    linenr_T	old_lcount;	/* b_ml.ml_line_count before the command */
-    linenr_T	lnum;		/* line number according to old situation */
+    linenr_T old_lcount;	/* b_ml.ml_line_count before the command */
+    buf_T    *old_buf = curbuf;	/* remember what buffer we started in */
+    linenr_T lnum;		/* line number according to old situation */
 
     /*
      * Set current position only once for a global command.
@@ -5398,8 +5387,10 @@
 	msg_didout = FALSE;
 
     /* If substitutes done, report number of substitutes, otherwise report
-     * number of extra or deleted lines. */
-    if (!do_sub_msg(FALSE))
+     * number of extra or deleted lines.
+     * Don't report extra or deleted lines in the edge case where the buffer
+     * we are in after execution is different from the buffer we started in. */
+    if (!do_sub_msg(FALSE) && curbuf == old_buf)
 	msgmore(curbuf->b_ml.ml_line_count - old_lcount);
 }
 
@@ -5409,7 +5400,7 @@
     vir_T	*virp;
     int		force;
 {
-    if (old_sub != NULL && force)
+    if (force)
 	vim_free(old_sub);
     if (force || old_sub == NULL)
 	old_sub = viminfo_readstring(virp, 1, TRUE);
@@ -5471,9 +5462,8 @@
 		return FALSE;
 	    curwin->w_p_pvw = TRUE;
 	    curwin->w_p_wfh = TRUE;
-# ifdef FEAT_SCROLLBIND
-	    curwin->w_p_scb = FALSE;	    /* don't take over 'scrollbind' */
-# endif
+	    RESET_BINDING(curwin);	    /* don't take over 'scrollbind'
+					       and 'cursorbind' */
 # ifdef FEAT_DIFF
 	    curwin->w_p_diff = FALSE;	    /* no 'diff' */
 # endif
@@ -6559,8 +6549,7 @@
 struct sign
 {
     sign_T	*sn_next;	/* next sign in list */
-    int		sn_typenr;	/* type number of sign (negative if not equal
-				   to name) */
+    int		sn_typenr;	/* type number of sign */
     char_u	*sn_name;	/* name of sign */
     char_u	*sn_icon;	/* name of pixmap */
 #ifdef FEAT_SIGN_ICONS
@@ -6572,7 +6561,7 @@
 };
 
 static sign_T	*first_sign = NULL;
-static int	last_sign_typenr = MAX_TYPENR;	/* is decremented */
+static int	next_sign_typenr = 1;
 
 static int sign_cmd_idx __ARGS((char_u *begin_cmd, char_u *end_cmd));
 static void sign_list_defined __ARGS((sign_T *sp));
@@ -6654,9 +6643,14 @@
 	    EMSG(_("E156: Missing sign name"));
 	else
 	{
+	    /* Isolate the sign name.  If it's a number skip leading zeroes,
+	     * so that "099" and "99" are the same sign.  But keep "0". */
 	    p = skiptowhite(arg);
 	    if (*p != NUL)
 		*p++ = NUL;
+	    while (arg[0] == '0' && arg[1] != NUL)
+		++arg;
+
 	    sp_prev = NULL;
 	    for (sp = first_sign; sp != NULL; sp = sp->sn_next)
 	    {
@@ -6669,46 +6663,52 @@
 		/* ":sign define {name} ...": define a sign */
 		if (sp == NULL)
 		{
+		    sign_T	*lp;
+		    int		start = next_sign_typenr;
+
 		    /* Allocate a new sign. */
 		    sp = (sign_T *)alloc_clear((unsigned)sizeof(sign_T));
 		    if (sp == NULL)
 			return;
-		    if (sp_prev == NULL)
-			first_sign = sp;
-		    else
-			sp_prev->sn_next = sp;
-		    sp->sn_name = vim_strnsave(arg, (int)(p - arg));
 
-		    /* If the name is a number use that for the typenr,
-		     * otherwise use a negative number. */
-		    if (VIM_ISDIGIT(*arg))
-			sp->sn_typenr = atoi((char *)arg);
-		    else
+		    /* Check that next_sign_typenr is not already being used.
+		     * This only happens after wrapping around.  Hopefully
+		     * another one got deleted and we can use its number. */
+		    for (lp = first_sign; lp != NULL; )
 		    {
-			sign_T	*lp;
-			int	start = last_sign_typenr;
-
-			for (lp = first_sign; lp != NULL; lp = lp->sn_next)
+			if (lp->sn_typenr == next_sign_typenr)
 			{
-			    if (lp->sn_typenr == last_sign_typenr)
+			    ++next_sign_typenr;
+			    if (next_sign_typenr == MAX_TYPENR)
+				next_sign_typenr = 1;
+			    if (next_sign_typenr == start)
 			    {
-				--last_sign_typenr;
-				if (last_sign_typenr == 0)
-				    last_sign_typenr = MAX_TYPENR;
-				if (last_sign_typenr == start)
-				{
-				    EMSG(_("E612: Too many signs defined"));
-				    return;
-				}
-				lp = first_sign;
-				continue;
+				vim_free(sp);
+				EMSG(_("E612: Too many signs defined"));
+				return;
 			    }
+			    lp = first_sign;  /* start all over */
+			    continue;
 			}
+			lp = lp->sn_next;
+		    }
+
+		    sp->sn_typenr = next_sign_typenr;
+		    if (++next_sign_typenr == MAX_TYPENR)
+			next_sign_typenr = 1; /* wrap around */
 
-			sp->sn_typenr = last_sign_typenr--;
-			if (last_sign_typenr == 0)
-			    last_sign_typenr = MAX_TYPENR; /* wrap around */
+		    sp->sn_name = vim_strsave(arg);
+		    if (sp->sn_name == NULL)  /* out of memory */
+		    {
+			vim_free(sp);
+			return;
 		    }
+
+		    /* add the new sign to the list of signs */
+		    if (sp_prev == NULL)
+			first_sign = sp;
+		    else
+			sp_prev->sn_next = sp;
 		}
 
 		/* set values for a defined sign. */
@@ -6886,6 +6886,8 @@
 		arg = skiptowhite(arg);
 		if (*arg != NUL)
 		    *arg++ = NUL;
+		while (sign_name[0] == '0' && sign_name[1] != NUL)
+		    ++sign_name;
 	    }
 	    else if (STRNCMP(arg, "file=", 5) == 0)
 	    {
diff -Naur vim73.orig/src/ex_cmds2.c vim73/src/ex_cmds2.c
--- vim73.orig/src/ex_cmds2.c	2010-07-27 19:43:38.000000000 +0000
+++ vim73/src/ex_cmds2.c	2011-05-17 09:39:31.599920425 +0000
@@ -11,10 +11,6 @@
  * ex_cmds2.c: some more functions for command line commands
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for mch_open(), must be before vim.h */
-#endif
-
 #include "vim.h"
 #include "version.h"
 
@@ -504,18 +500,10 @@
 	/* Expand the file name in the same way as do_source().  This means
 	 * doing it twice, so that $DIR/file gets expanded when $DIR is
 	 * "~/dir". */
-#ifdef RISCOS
-	q = mch_munge_fname(p);
-#else
 	q = expand_env_save(p);
-#endif
 	if (q == NULL)
 	    return FAIL;
-#ifdef RISCOS
-	p = mch_munge_fname(q);
-#else
 	p = expand_env_save(q);
-#endif
 	vim_free(q);
 	if (p == NULL)
 	    return FAIL;
@@ -1119,7 +1107,7 @@
 static enum
 {
     PEXP_SUBCMD,	/* expand :profile sub-commands */
-    PEXP_FUNC,		/* expand :profile func {funcname} */
+    PEXP_FUNC		/* expand :profile func {funcname} */
 } pexpand_what;
 
 static char *pexpand_cmds[] = {
@@ -1496,7 +1484,7 @@
     buf_T	*buf;
     int		checkall;	/* may abandon all changed buffers */
 {
-    char_u	buff[IOSIZE];
+    char_u	buff[DIALOG_MSG_SIZE];
     int		ret;
     buf_T	*buf2;
 
@@ -2165,9 +2153,7 @@
 	{
 	    if (win_split(0, 0) == FAIL)
 		return;
-# ifdef FEAT_SCROLLBIND
-	    curwin->w_p_scb = FALSE;
-# endif
+	    RESET_BINDING(curwin);
 	}
 	else
 #endif
@@ -2946,11 +2932,7 @@
     proftime_T		    wait_start;
 #endif
 
-#ifdef RISCOS
-    p = mch_munge_fname(fname);
-#else
     p = expand_env_save(fname);
-#endif
     if (p == NULL)
 	return retval;
     fname_exp = fix_fname(p);
diff -Naur vim73.orig/src/ex_docmd.c vim73/src/ex_docmd.c
--- vim73.orig/src/ex_docmd.c	2010-08-07 14:59:47.000000000 +0000
+++ vim73/src/ex_docmd.c	2011-05-17 09:39:31.603919981 +0000
@@ -733,7 +733,7 @@
  * do_cmdline(): execute one Ex command line
  *
  * 1. Execute "cmdline" when it is not NULL.
- *    If "cmdline" is NULL, or more lines are needed, getline() is used.
+ *    If "cmdline" is NULL, or more lines are needed, fgetline() is used.
  * 2. Split up in parts separated with '|'.
  *
  * This function can be called recursively!
@@ -741,7 +741,7 @@
  * flags:
  * DOCMD_VERBOSE  - The command will be included in the error message.
  * DOCMD_NOWAIT   - Don't call wait_return() and friends.
- * DOCMD_REPEAT   - Repeat execution until getline() returns NULL.
+ * DOCMD_REPEAT   - Repeat execution until fgetline() returns NULL.
  * DOCMD_KEYTYPED - Don't reset KeyTyped.
  * DOCMD_EXCRESET - Reset the exception environment (used for debugging).
  * DOCMD_KEEPLINE - Store first typed line (for repeating with ".").
@@ -749,15 +749,15 @@
  * return FAIL if cmdline could not be executed, OK otherwise
  */
     int
-do_cmdline(cmdline, getline, cookie, flags)
+do_cmdline(cmdline, fgetline, cookie, flags)
     char_u	*cmdline;
-    char_u	*(*getline) __ARGS((int, void *, int));
-    void	*cookie;		/* argument for getline() */
+    char_u	*(*fgetline) __ARGS((int, void *, int));
+    void	*cookie;		/* argument for fgetline() */
     int		flags;
 {
     char_u	*next_cmdline;		/* next cmd to execute */
     char_u	*cmdline_copy = NULL;	/* copy of cmd line */
-    int		used_getline = FALSE;	/* used "getline" to obtain command */
+    int		used_getline = FALSE;	/* used "fgetline" to obtain command */
     static int	recursive = 0;		/* recursive depth */
     int		msg_didout_before_start = 0;
     int		count = 0;		/* line number count */
@@ -775,14 +775,14 @@
     struct msglist	**saved_msg_list = NULL;
     struct msglist	*private_msg_list;
 
-    /* "getline" and "cookie" passed to do_one_cmd() */
+    /* "fgetline" and "cookie" passed to do_one_cmd() */
     char_u	*(*cmd_getline) __ARGS((int, void *, int));
     void	*cmd_cookie;
     struct loop_cookie cmd_loop_cookie;
     void	*real_cookie;
     int		getline_is_func;
 #else
-# define cmd_getline getline
+# define cmd_getline fgetline
 # define cmd_cookie cookie
 #endif
     static int	call_depth = 0;		/* recursiveness */
@@ -822,10 +822,10 @@
     cstack.cs_lflags = 0;
     ga_init2(&lines_ga, (int)sizeof(wcmd_T), 10);
 
-    real_cookie = getline_cookie(getline, cookie);
+    real_cookie = getline_cookie(fgetline, cookie);
 
     /* Inside a function use a higher nesting level. */
-    getline_is_func = getline_equal(getline, cookie, get_func_line);
+    getline_is_func = getline_equal(fgetline, cookie, get_func_line);
     if (getline_is_func && ex_nesting_level == func_level(real_cookie))
 	++ex_nesting_level;
 
@@ -837,7 +837,7 @@
 	breakpoint = func_breakpoint(real_cookie);
 	dbg_tick = func_dbg_tick(real_cookie);
     }
-    else if (getline_equal(getline, cookie, getsourceline))
+    else if (getline_equal(fgetline, cookie, getsourceline))
     {
 	fname = sourcing_name;
 	breakpoint = source_breakpoint(real_cookie);
@@ -881,7 +881,8 @@
      * KeyTyped is only set when calling vgetc().  Reset it here when not
      * calling vgetc() (sourced command lines).
      */
-    if (!(flags & DOCMD_KEYTYPED) && !getline_equal(getline, cookie, getexline))
+    if (!(flags & DOCMD_KEYTYPED)
+			       && !getline_equal(fgetline, cookie, getexline))
 	KeyTyped = FALSE;
 
     /*
@@ -894,7 +895,7 @@
     do
     {
 #ifdef FEAT_EVAL
-	getline_is_func = getline_equal(getline, cookie, get_func_line);
+	getline_is_func = getline_equal(fgetline, cookie, get_func_line);
 #endif
 
 	/* stop skipping cmds for an error msg after all endif/while/for */
@@ -909,7 +910,7 @@
 
 	/*
 	 * 1. If repeating a line in a loop, get a line from lines_ga.
-	 * 2. If no line given: Get an allocated line with getline().
+	 * 2. If no line given: Get an allocated line with fgetline().
 	 * 3. If a line is given: Make a copy, so we can mess with it.
 	 */
 
@@ -938,12 +939,12 @@
 	    }
 #ifdef FEAT_PROFILE
 	    else if (do_profiling == PROF_YES
-			     && getline_equal(getline, cookie, getsourceline))
+			    && getline_equal(fgetline, cookie, getsourceline))
 		script_line_end();
 #endif
 
 	    /* Check if a sourced file hit a ":finish" command. */
-	    if (source_finished(getline, cookie))
+	    if (source_finished(fgetline, cookie))
 	    {
 		retval = FAIL;
 		break;
@@ -954,7 +955,7 @@
 						   && *dbg_tick != debug_tick)
 	    {
 		*breakpoint = dbg_find_breakpoint(
-				getline_equal(getline, cookie, getsourceline),
+				getline_equal(fgetline, cookie, getsourceline),
 							fname, sourcing_lnum);
 		*dbg_tick = debug_tick;
 	    }
@@ -969,7 +970,7 @@
 		dbg_breakpoint(fname, sourcing_lnum);
 		/* Find next breakpoint. */
 		*breakpoint = dbg_find_breakpoint(
-				getline_equal(getline, cookie, getsourceline),
+			       getline_equal(fgetline, cookie, getsourceline),
 							fname, sourcing_lnum);
 		*dbg_tick = debug_tick;
 	    }
@@ -978,7 +979,7 @@
 	    {
 		if (getline_is_func)
 		    func_line_start(real_cookie);
-		else if (getline_equal(getline, cookie, getsourceline))
+		else if (getline_equal(fgetline, cookie, getsourceline))
 		    script_line_start();
 	    }
 # endif
@@ -987,7 +988,7 @@
 	if (cstack.cs_looplevel > 0)
 	{
 	    /* Inside a while/for loop we need to store the lines and use them
-	     * again.  Pass a different "getline" function to do_one_cmd()
+	     * again.  Pass a different "fgetline" function to do_one_cmd()
 	     * below, so that it stores lines in or reads them from
 	     * "lines_ga".  Makes it possible to define a function inside a
 	     * while/for loop. */
@@ -995,27 +996,27 @@
 	    cmd_cookie = (void *)&cmd_loop_cookie;
 	    cmd_loop_cookie.lines_gap = &lines_ga;
 	    cmd_loop_cookie.current_line = current_line;
-	    cmd_loop_cookie.getline = getline;
+	    cmd_loop_cookie.getline = fgetline;
 	    cmd_loop_cookie.cookie = cookie;
 	    cmd_loop_cookie.repeating = (current_line < lines_ga.ga_len);
 	}
 	else
 	{
-	    cmd_getline = getline;
+	    cmd_getline = fgetline;
 	    cmd_cookie = cookie;
 	}
 #endif
 
-	/* 2. If no line given, get an allocated line with getline(). */
+	/* 2. If no line given, get an allocated line with fgetline(). */
 	if (next_cmdline == NULL)
 	{
 	    /*
 	     * Need to set msg_didout for the first line after an ":if",
 	     * otherwise the ":if" will be overwritten.
 	     */
-	    if (count == 1 && getline_equal(getline, cookie, getexline))
+	    if (count == 1 && getline_equal(fgetline, cookie, getexline))
 		msg_didout = TRUE;
-	    if (getline == NULL || (next_cmdline = getline(':', cookie,
+	    if (fgetline == NULL || (next_cmdline = fgetline(':', cookie,
 #ifdef FEAT_EVAL
 		    cstack.cs_idx < 0 ? 0 : (cstack.cs_idx + 1) * 2
 #else
@@ -1142,7 +1143,7 @@
 	     * If the command was typed, remember it for the ':' register.
 	     * Do this AFTER executing the command to make :@: work.
 	     */
-	    if (getline_equal(getline, cookie, getexline)
+	    if (getline_equal(fgetline, cookie, getexline)
 						  && new_last_cmdline != NULL)
 	    {
 		vim_free(last_cmdline);
@@ -1163,7 +1164,7 @@
 #ifdef FEAT_EVAL
 	/* reset did_emsg for a function that is not aborted by an error */
 	if (did_emsg && !force_abort
-		&& getline_equal(getline, cookie, get_func_line)
+		&& getline_equal(fgetline, cookie, get_func_line)
 					      && !func_has_abort(real_cookie))
 	    did_emsg = FALSE;
 
@@ -1202,7 +1203,7 @@
 		    if (breakpoint != NULL)
 		    {
 			*breakpoint = dbg_find_breakpoint(
-				getline_equal(getline, cookie, getsourceline),
+			       getline_equal(fgetline, cookie, getsourceline),
 									fname,
 			   ((wcmd_T *)lines_ga.ga_data)[current_line].lnum-1);
 			*dbg_tick = debug_tick;
@@ -1296,8 +1297,8 @@
 #endif
 	    )
 	    && !(did_emsg && used_getline
-			  && (getline_equal(getline, cookie, getexmodeline)
-				|| getline_equal(getline, cookie, getexline)))
+			    && (getline_equal(fgetline, cookie, getexmodeline)
+			       || getline_equal(fgetline, cookie, getexline)))
 	    && (next_cmdline != NULL
 #ifdef FEAT_EVAL
 			|| cstack.cs_idx >= 0
@@ -1316,9 +1317,9 @@
 	 * unclosed conditional.
 	 */
 	if (!got_int && !did_throw
-		&& ((getline_equal(getline, cookie, getsourceline)
-			&& !source_finished(getline, cookie))
-		    || (getline_equal(getline, cookie, get_func_line)
+		&& ((getline_equal(fgetline, cookie, getsourceline)
+			&& !source_finished(fgetline, cookie))
+		    || (getline_equal(fgetline, cookie, get_func_line)
 					    && !func_has_ended(real_cookie))))
 	{
 	    if (cstack.cs_flags[cstack.cs_idx] & CSF_TRY)
@@ -1354,7 +1355,7 @@
     /* If a missing ":endtry", ":endwhile", ":endfor", or ":endif" or a memory
      * lack was reported above and the error message is to be converted to an
      * exception, do this now after rewinding the cstack. */
-    do_errthrow(&cstack, getline_equal(getline, cookie, get_func_line)
+    do_errthrow(&cstack, getline_equal(fgetline, cookie, get_func_line)
 				  ? (char_u *)"endfunction" : (char_u *)NULL);
 
     if (trylevel == 0)
@@ -1449,9 +1450,9 @@
      */
     if (did_throw)
 	need_rethrow = TRUE;
-    if ((getline_equal(getline, cookie, getsourceline)
+    if ((getline_equal(fgetline, cookie, getsourceline)
 		&& ex_nesting_level > source_level(real_cookie))
-	    || (getline_equal(getline, cookie, get_func_line)
+	    || (getline_equal(fgetline, cookie, get_func_line)
 		&& ex_nesting_level > func_level(real_cookie) + 1))
     {
 	if (!did_throw)
@@ -1460,16 +1461,16 @@
     else
     {
 	/* When leaving a function, reduce nesting level. */
-	if (getline_equal(getline, cookie, get_func_line))
+	if (getline_equal(fgetline, cookie, get_func_line))
 	    --ex_nesting_level;
 	/*
 	 * Go to debug mode when returning from a function in which we are
 	 * single-stepping.
 	 */
-	if ((getline_equal(getline, cookie, getsourceline)
-		    || getline_equal(getline, cookie, get_func_line))
+	if ((getline_equal(fgetline, cookie, getsourceline)
+		    || getline_equal(fgetline, cookie, get_func_line))
 		&& ex_nesting_level + 1 <= debug_break_level)
-	    do_debug(getline_equal(getline, cookie, getsourceline)
+	    do_debug(getline_equal(fgetline, cookie, getsourceline)
 		    ? (char_u *)_("End of sourced file")
 		    : (char_u *)_("End of function"));
     }
@@ -2423,25 +2424,39 @@
     if (       (ea.argt & REGSTR)
 	    && *ea.arg != NUL
 #ifdef FEAT_USR_CMDS
-	    && valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put
-						   && USER_CMDIDX(ea.cmdidx)))
 	    /* Do not allow register = for user commands */
 	    && (!USER_CMDIDX(ea.cmdidx) || *ea.arg != '=')
-#else
-	    && valid_yank_reg(*ea.arg, ea.cmdidx != CMD_put)
 #endif
 	    && !((ea.argt & COUNT) && VIM_ISDIGIT(*ea.arg)))
     {
-	ea.regname = *ea.arg++;
-#ifdef FEAT_EVAL
-	/* for '=' register: accept the rest of the line as an expression */
-	if (ea.arg[-1] == '=' && ea.arg[0] != NUL)
+#ifndef FEAT_CLIPBOARD
+	/* check these explicitly for a more specific error message */
+	if (*ea.arg == '*' || *ea.arg == '+')
 	{
-	    set_expr_line(vim_strsave(ea.arg));
-	    ea.arg += STRLEN(ea.arg);
+	    errormsg = (char_u *)_(e_invalidreg);
+	    goto doend;
 	}
 #endif
-	ea.arg = skipwhite(ea.arg);
+	if (
+#ifdef FEAT_USR_CMDS
+	    valid_yank_reg(*ea.arg, (ea.cmdidx != CMD_put
+						   && USER_CMDIDX(ea.cmdidx)))
+#else
+	    valid_yank_reg(*ea.arg, ea.cmdidx != CMD_put)
+#endif
+	   )
+	{
+	    ea.regname = *ea.arg++;
+#ifdef FEAT_EVAL
+	    /* for '=' register: accept the rest of the line as an expression */
+	    if (ea.arg[-1] == '=' && ea.arg[0] != NUL)
+	    {
+		set_expr_line(vim_strsave(ea.arg));
+		ea.arg += STRLEN(ea.arg);
+	    }
+#endif
+	    ea.arg = skipwhite(ea.arg);
+	}
     }
 
     /*
@@ -2871,8 +2886,10 @@
 	    }
 
 #ifdef FEAT_USR_CMDS
-	/* Look for a user defined command as a last resort */
-	if (eap->cmdidx == CMD_SIZE && *eap->cmd >= 'A' && *eap->cmd <= 'Z')
+	/* Look for a user defined command as a last resort.  Let ":Print" be
+	 * overruled by a user defined command. */
+	if ((eap->cmdidx == CMD_SIZE || eap->cmdidx == CMD_Print)
+		&& *eap->cmd >= 'A' && *eap->cmd <= 'Z')
 	{
 	    /* User defined commands may contain digits. */
 	    while (ASCII_ISALNUM(*p))
@@ -3465,7 +3482,8 @@
 	case CMD_find:
 	case CMD_sfind:
 	case CMD_tabfind:
-	    xp->xp_context = EXPAND_FILES_IN_PATH;
+	    if (xp->xp_context == EXPAND_FILES)
+		xp->xp_context = EXPAND_FILES_IN_PATH;
 	    break;
 	case CMD_cd:
 	case CMD_chdir:
@@ -4520,12 +4538,14 @@
 		else /* n == 2 */
 		{
 		    expand_T	xpc;
+		    int		options = WILD_LIST_NOTFOUND|WILD_ADD_SLASH;
 
 		    ExpandInit(&xpc);
 		    xpc.xp_context = EXPAND_FILES;
+		    if (p_wic)
+			options += WILD_ICASE;
 		    p = ExpandOne(&xpc, eap->arg, NULL,
-					    WILD_LIST_NOTFOUND|WILD_ADD_SLASH,
-						   WILD_EXPAND_FREE);
+						   options, WILD_EXPAND_FREE);
 		    if (p == NULL)
 			return FAIL;
 		}
@@ -5087,12 +5107,14 @@
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)
 	    if ((p_confirm || cmdmod.confirm) && curbuf->b_fname != NULL)
 	    {
-		char_u	buff[IOSIZE];
+		char_u	buff[DIALOG_MSG_SIZE];
 
 		if (n == 1)
-		    STRCPY(buff, _("1 more file to edit.  Quit anyway?"));
+		    vim_strncpy(buff,
+			    (char_u *)_("1 more file to edit.  Quit anyway?"),
+							 DIALOG_MSG_SIZE - 1);
 		else
-		    vim_snprintf((char *)buff, IOSIZE,
+		    vim_snprintf((char *)buff, DIALOG_MSG_SIZE,
 			      _("%d more files to edit.  Quit anyway?"), n);
 		if (vim_dialog_yesno(VIM_QUESTION, NULL, buff, 1) == VIM_YES)
 		    return OK;
@@ -5587,6 +5609,7 @@
     int	    compl = EXPAND_NOTHING;
     char_u  *compl_arg = NULL;
     int	    has_attr = (eap->arg[0] == '-');
+    int	    name_len;
 
     p = eap->arg;
 
@@ -5612,6 +5635,7 @@
 	return;
     }
     end = p;
+    name_len = (int)(end - name);
 
     /* If there is nothing after the name, and no attributes were specified,
      * we are listing commands
@@ -5626,6 +5650,13 @@
 	EMSG(_("E183: User defined commands must start with an uppercase letter"));
 	return;
     }
+    else if ((name_len == 1 && *name == 'X')
+	  || (name_len <= 4
+		  && STRNCMP(name, "Next", name_len > 4 ? 4 : name_len) == 0))
+    {
+	EMSG(_("E841: Reserved name, cannot be used for user defined command"));
+	return;
+    }
     else
 	uc_add_command(name, end - name, p, argt, def, flags, compl, compl_arg,
 								eap->forceit);
@@ -6039,15 +6070,17 @@
 		end = vim_strchr(start + 1, '>');
 	    if (buf != NULL)
 	    {
-		ksp = vim_strchr(p, K_SPECIAL);
-		if (ksp != NULL && (start == NULL || ksp < start || end == NULL)
+		for (ksp = p; *ksp != NUL && *ksp != K_SPECIAL; ++ksp)
+		    ;
+		if (*ksp == K_SPECIAL
+			&& (start == NULL || ksp < start || end == NULL)
 			&& ((ksp[1] == KS_SPECIAL && ksp[2] == KE_FILLER)
 # ifdef FEAT_GUI
 			    || (ksp[1] == KS_EXTRA && ksp[2] == (int)KE_CSI)
 # endif
 			    ))
 		{
-		    /* K_SPECIAL han been put in the buffer as K_SPECIAL
+		    /* K_SPECIAL has been put in the buffer as K_SPECIAL
 		     * KS_SPECIAL KE_FILLER, like for mappings, but
 		     * do_cmdline() doesn't handle that, so convert it back.
 		     * Also change K_SPECIAL KS_EXTRA KE_CSI into CSI. */
@@ -6897,9 +6930,7 @@
 # ifdef FEAT_WINDOWS
 	if (win_split(0, 0) == FAIL)
 	    return;
-#  ifdef FEAT_SCROLLBIND
-	curwin->w_p_scb = FALSE;
-#  endif
+	RESET_BINDING(curwin);
 
 	/* When splitting the window, create a new alist.  Otherwise the
 	 * existing one is overwritten. */
@@ -7299,7 +7330,9 @@
 		|| cmdmod.browse
 #  endif
 	   )
-	    curwin->w_p_scb = FALSE;
+	{
+	    RESET_BINDING(curwin);
+	}
 	else
 	    do_check_scrollbind(FALSE);
 # endif
@@ -8907,35 +8940,42 @@
 		failed = TRUE;
 	    if (eap->cmdidx == CMD_mksession)
 	    {
-		char_u dirnow[MAXPATHL];	/* current directory */
+		char_u *dirnow;	 /* current directory */
 
-		/*
-		 * Change to session file's dir.
-		 */
-		if (mch_dirname(dirnow, MAXPATHL) == FAIL
-					    || mch_chdir((char *)dirnow) != 0)
-		    *dirnow = NUL;
-		if (*dirnow != NUL && (ssop_flags & SSOP_SESDIR))
-		{
-		    if (vim_chdirfile(fname) == OK)
-			shorten_fnames(TRUE);
-		}
-		else if (*dirnow != NUL
-			&& (ssop_flags & SSOP_CURDIR) && globaldir != NULL)
+		dirnow = alloc(MAXPATHL);
+		if (dirnow == NULL)
+		    failed = TRUE;
+		else
 		{
-		    if (mch_chdir((char *)globaldir) == 0)
-			shorten_fnames(TRUE);
-		}
+		    /*
+		     * Change to session file's dir.
+		     */
+		    if (mch_dirname(dirnow, MAXPATHL) == FAIL
+					    || mch_chdir((char *)dirnow) != 0)
+			*dirnow = NUL;
+		    if (*dirnow != NUL && (ssop_flags & SSOP_SESDIR))
+		    {
+			if (vim_chdirfile(fname) == OK)
+			    shorten_fnames(TRUE);
+		    }
+		    else if (*dirnow != NUL
+			   && (ssop_flags & SSOP_CURDIR) && globaldir != NULL)
+		    {
+			if (mch_chdir((char *)globaldir) == 0)
+			    shorten_fnames(TRUE);
+		    }
 
-		failed |= (makeopens(fd, dirnow) == FAIL);
+		    failed |= (makeopens(fd, dirnow) == FAIL);
 
-		/* restore original dir */
-		if (*dirnow != NUL && ((ssop_flags & SSOP_SESDIR)
+		    /* restore original dir */
+		    if (*dirnow != NUL && ((ssop_flags & SSOP_SESDIR)
 			|| ((ssop_flags & SSOP_CURDIR) && globaldir != NULL)))
-		{
-		    if (mch_chdir((char *)dirnow) != 0)
-			EMSG(_(e_prev_dir));
-		    shorten_fnames(TRUE);
+		    {
+			if (mch_chdir((char *)dirnow) != 0)
+			    EMSG(_(e_prev_dir));
+			shorten_fnames(TRUE);
+		    }
+		    vim_free(dirnow);
 		}
 	    }
 	    else
@@ -8966,10 +9006,15 @@
 	else if (eap->cmdidx == CMD_mksession)
 	{
 	    /* successful session write - set this_session var */
-	    char_u	tbuf[MAXPATHL];
+	    char_u	*tbuf;
 
-	    if (vim_FullName(fname, tbuf, MAXPATHL, FALSE) == OK)
-		set_vim_var_string(VV_THIS_SESSION, tbuf, -1);
+	    tbuf = alloc(MAXPATHL);
+	    if (tbuf != NULL)
+	    {
+		if (vim_FullName(fname, tbuf, MAXPATHL, FALSE) == OK)
+		    set_vim_var_string(VV_THIS_SESSION, tbuf, -1);
+		vim_free(tbuf);
+	    }
 	}
 #endif
 #ifdef MKSESSION_NL
@@ -9295,7 +9340,7 @@
 								  && !got_int)
     {
 	update_topline_cursor();
-	normal_cmd(&oa, FALSE);	/* execute a Normal mode cmd */
+	normal_cmd(&oa, TRUE);	/* execute a Normal mode cmd */
     }
 }
 #endif
@@ -9393,7 +9438,7 @@
 ex_ptag(eap)
     exarg_T	*eap;
 {
-    g_do_tagpreview = p_pvh;
+    g_do_tagpreview = p_pvh;  /* will be reset to 0 in ex_tag_cmd() */
     ex_tag_cmd(eap, cmdnames[eap->cmdidx].cmd_name + 1);
 }
 
@@ -9525,17 +9570,23 @@
 #define SPEC_CFILE  4
 		    "<sfile>",		/* ":so" file name */
 #define SPEC_SFILE  5
+		    "<slnum>",		/* ":so" file line number */
+#define SPEC_SLNUM  6
 #ifdef FEAT_AUTOCMD
 		    "<afile>",		/* autocommand file name */
-# define SPEC_AFILE 6
+# define SPEC_AFILE 7
 		    "<abuf>",		/* autocommand buffer number */
-# define SPEC_ABUF  7
+# define SPEC_ABUF  8
 		    "<amatch>",		/* autocommand match name */
-# define SPEC_AMATCH 8
+# define SPEC_AMATCH 9
 #endif
 #ifdef FEAT_CLIENTSERVER
 		    "<client>"
-# define SPEC_CLIENT 9
+# ifdef FEAT_AUTOCMD
+#  define SPEC_CLIENT 10
+# else
+#  define SPEC_CLIENT 7
+# endif
 #endif
     };
 
@@ -9560,6 +9611,7 @@
  *	  '<cWORD>' to WORD under the cursor
  *	  '<cfile>' to path name under the cursor
  *	  '<sfile>' to sourced file name
+ *	  '<slnum>' to sourced file line number
  *	  '<afile>' to file name for autocommand
  *	  '<abuf>'  to buffer number for autocommand
  *	  '<amatch>' to matching name for autocommand
@@ -9591,10 +9643,7 @@
 #ifdef FEAT_MODIFY_FNAME
     int		skip_mod = FALSE;
 #endif
-
-#if defined(FEAT_AUTOCMD) || defined(FEAT_CLIENTSERVER)
     char_u	strbuf[30];
-#endif
 
     *errormsg = NULL;
     if (escaped != NULL)
@@ -9653,14 +9702,7 @@
 		    valid = 0;	    /* Must have ":p:h" to be valid */
 		}
 		else
-#ifdef RISCOS
-		    /* Always use the full path for RISC OS if possible. */
-		    result = curbuf->b_ffname;
-		    if (result == NULL)
-			result = curbuf->b_fname;
-#else
 		    result = curbuf->b_fname;
-#endif
 		break;
 
 	case SPEC_HASH:		/* '#' or "#99": alternate file */
@@ -9783,6 +9825,15 @@
 		    return NULL;
 		}
 		break;
+	case SPEC_SLNUM:	/* line in file for ":so" command */
+		if (sourcing_name == NULL || sourcing_lnum == 0)
+		{
+		    *errormsg = (char_u *)_("E842: no line number to use for \"<slnum>\"");
+		    return NULL;
+		}
+		sprintf((char *)strbuf, "%ld", (long)sourcing_lnum);
+		result = strbuf;
+		break;
 #if defined(FEAT_CLIENTSERVER)
 	case SPEC_CLIENT:	/* Source of last submitted input */
 		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
@@ -9796,11 +9847,7 @@
 	if (src[*usedlen] == '<')	/* remove the file name extension */
 	{
 	    ++*usedlen;
-#ifdef RISCOS
-	    if ((s = vim_strrchr(result, '/')) != NULL && s >= gettail(result))
-#else
 	    if ((s = vim_strrchr(result, '.')) != NULL && s >= gettail(result))
-#endif
 		resultlen = (int)(s - result);
 	}
 #ifdef FEAT_MODIFY_FNAME
@@ -10645,7 +10692,7 @@
     unsigned	*flagp;
 {
     int		i;
-    char_u	buf[MAXPATHL];
+    char_u	*buf = NULL;
     char_u	*s;
 
     if (gap->ga_len == 0)
@@ -10660,11 +10707,19 @@
 	{
 	    if (fullname)
 	    {
-		(void)vim_FullName(s, buf, MAXPATHL, FALSE);
-		s = buf;
+		buf = alloc(MAXPATHL);
+		if (buf != NULL)
+		{
+		    (void)vim_FullName(s, buf, MAXPATHL, FALSE);
+		    s = buf;
+		}
 	    }
 	    if (fputs(" ", fd) < 0 || ses_put_fname(fd, s, flagp) == FAIL)
+	    {
+		vim_free(buf);
 		return FAIL;
+	    }
+	    vim_free(buf);
 	}
     }
     return put_eol(fd);
@@ -10707,7 +10762,7 @@
  * Write a file name to the session file.
  * Takes care of the "slash" option in 'sessionoptions' and escapes special
  * characters.
- * Returns FAIL if writing fails.
+ * Returns FAIL if writing fails or out of memory.
  */
     static int
 ses_put_fname(fd, name, flagp)
@@ -10716,49 +10771,32 @@
     unsigned	*flagp;
 {
     char_u	*sname;
+    char_u	*p;
     int		retval = OK;
-    int		c;
 
     sname = home_replace_save(NULL, name);
-    if (sname != NULL)
-	name = sname;
-    while (*name != NUL)
-    {
-#ifdef FEAT_MBYTE
-	{
-	    int l;
+    if (sname == NULL)
+	return FAIL;
 
-	    if (has_mbyte && (l = (*mb_ptr2len)(name)) > 1)
-	    {
-		/* copy a multibyte char */
-		while (--l >= 0)
-		{
-		    if (putc(*name, fd) != *name)
-			retval = FAIL;
-		    ++name;
-		}
-		continue;
-	    }
-	}
-#endif
-	c = *name++;
-	if (c == '\\' && (*flagp & SSOP_SLASH))
-	    /* change a backslash to a forward slash */
-	    c = '/';
-	else if ((vim_strchr(escape_chars, c) != NULL
-#ifdef BACKSLASH_IN_FILENAME
-		    && c != '\\'
-#endif
-		 ) || c == '#' || c == '%')
-	{
-	    /* escape a special character with a backslash */
-	    if (putc('\\', fd) != '\\')
-		retval = FAIL;
-	}
-	if (putc(c, fd) != c)
-	    retval = FAIL;
+    if (*flagp & SSOP_SLASH)
+    {
+	/* change all backslashes to forward slashes */
+	for (p = sname; *p != NUL; mb_ptr_adv(p))
+	    if (*p == '\\')
+		*p = '/';
     }
+
+    /* escapse special characters */
+    p = vim_strsave_fnameescape(sname, FALSE);
     vim_free(sname);
+    if (p == NULL)
+	return FAIL;
+
+    /* write the result */
+    if (fputs((char *)p, fd) < 0)
+	retval = FAIL;
+
+    vim_free(p);
     return retval;
 }
 
@@ -10826,8 +10864,7 @@
 	    else if (vim_ispathsep(*p))
 	    {
 		*s++ = '=';
-#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA) || defined(RISCOS) \
-	|| defined(VMS)
+#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA) || defined(VMS)
 		if (*p == ':')
 		    *s++ = '-';
 		else
@@ -10910,7 +10947,7 @@
 
 #if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG) || defined(PROTO)
 /*
- * Make a dialog message in "buff[IOSIZE]".
+ * Make a dialog message in "buff[DIALOG_MSG_SIZE]".
  * "format" must contain "%s".
  */
     void
@@ -10921,7 +10958,7 @@
 {
     if (fname == NULL)
 	fname = (char_u *)_("Untitled");
-    vim_snprintf((char *)buff, IOSIZE, format, fname);
+    vim_snprintf((char *)buff, DIALOG_MSG_SIZE, format, fname);
 }
 #endif
 
diff -Naur vim73.orig/src/ex_getln.c vim73/src/ex_getln.c
--- vim73.orig/src/ex_getln.c	2010-08-14 15:25:45.000000000 +0000
+++ vim73/src/ex_getln.c	2011-05-17 09:38:39.473705700 +0000
@@ -688,28 +688,35 @@
 		    p = get_expr_line();
 		    --textlock;
 		    restore_cmdline(&save_ccline);
-		    len = (int)STRLEN(p);
 
-		    if (p != NULL && realloc_cmdbuff(len + 1) == OK)
+		    if (p != NULL)
 		    {
-			ccline.cmdlen = len;
-			STRCPY(ccline.cmdbuff, p);
-			vim_free(p);
-
-			/* Restore the cursor or use the position set with
-			 * set_cmdline_pos(). */
-			if (new_cmdpos > ccline.cmdlen)
-			    ccline.cmdpos = ccline.cmdlen;
-			else
-			    ccline.cmdpos = new_cmdpos;
-
-			KeyTyped = FALSE;	/* Don't do p_wc completion. */
-			redrawcmd();
-			goto cmdline_changed;
+			len = (int)STRLEN(p);
+			if (realloc_cmdbuff(len + 1) == OK)
+			{
+			    ccline.cmdlen = len;
+			    STRCPY(ccline.cmdbuff, p);
+			    vim_free(p);
+
+			    /* Restore the cursor or use the position set with
+			     * set_cmdline_pos(). */
+			    if (new_cmdpos > ccline.cmdlen)
+				ccline.cmdpos = ccline.cmdlen;
+			    else
+				ccline.cmdpos = new_cmdpos;
+
+			    KeyTyped = FALSE;	/* Don't do p_wc completion. */
+			    redrawcmd();
+			    goto cmdline_changed;
+			}
 		    }
 		}
 		beep_flush();
-		c = ESC;
+		got_int = FALSE;	/* don't abandon the command line */
+		did_emsg = FALSE;
+		emsg_on_display = FALSE;
+		redrawcmd();
+		goto cmdline_not_changed;
 	    }
 #endif
 	    else
@@ -2342,15 +2349,31 @@
 	windgoto(msg_row, msg_col);
 	pend = (char_u *)(line_ga.ga_data) + line_ga.ga_len;
 
-	/* we are done when a NL is entered, but not when it comes after a
-	 * backslash */
-	if (line_ga.ga_len > 0 && pend[-1] == '\n'
-		&& (line_ga.ga_len <= 1 || pend[-2] != '\\'))
-	{
-	    --line_ga.ga_len;
-	    --pend;
-	    *pend = NUL;
-	    break;
+	/* We are done when a NL is entered, but not when it comes after an
+	 * odd number of backslashes, that results in a NUL. */
+	if (line_ga.ga_len > 0 && pend[-1] == '\n')
+	{
+	    int bcount = 0;
+
+	    while (line_ga.ga_len - 2 >= bcount && pend[-2 - bcount] == '\\')
+		++bcount;
+
+	    if (bcount > 0)
+	    {
+		/* Halve the number of backslashes: "\NL" -> "NUL", "\\NL" ->
+		 * "\NL", etc. */
+		line_ga.ga_len -= (bcount + 1) / 2;
+		pend -= (bcount + 1) / 2;
+		pend[-1] = '\n';
+	    }
+
+	    if ((bcount & 1) == 0)
+	    {
+		--line_ga.ga_len;
+		--pend;
+		*pend = NUL;
+		break;
+	    }
 	}
     }
 
@@ -3316,10 +3339,14 @@
 	    p2 = NULL;
 	else
 	{
+	    int use_options = options |
+		    WILD_HOME_REPLACE|WILD_ADD_SLASH|WILD_SILENT|WILD_ESCAPE;
+
+	    if (p_wic)
+		use_options += WILD_ICASE;
 	    p2 = ExpandOne(xp, p1,
 			 vim_strnsave(&ccline.cmdbuff[i], xp->xp_pattern_len),
-		    WILD_HOME_REPLACE|WILD_ADD_SLASH|WILD_SILENT|WILD_ESCAPE
-							      |options, type);
+							   use_options, type);
 	    vim_free(p1);
 	    /* longest match: make sure it is not shorter, happens with :help */
 	    if (p2 != NULL && type == WILD_LONGEST)
@@ -3405,6 +3432,7 @@
  * options = WILD_KEEP_ALL:	    don't remove 'wildignore' entries
  * options = WILD_SILENT:	    don't print warning messages
  * options = WILD_ESCAPE:	    put backslash before special chars
+ * options = WILD_ICASE:	    ignore case for files
  *
  * The variables xp->xp_context and xp->xp_backslash must have been set!
  */
@@ -3674,6 +3702,7 @@
     if (options & WILD_ESCAPE)
     {
 	if (xp->xp_context == EXPAND_FILES
+		|| xp->xp_context == EXPAND_FILES_IN_PATH
 		|| xp->xp_context == EXPAND_SHELLCMD
 		|| xp->xp_context == EXPAND_BUFFERS
 		|| xp->xp_context == EXPAND_DIRECTORIES)
@@ -4338,6 +4367,7 @@
     char_u	***matches;	/* return: array of pointers to matches */
 {
     char_u	*file_str = NULL;
+    int		options = WILD_ADD_SLASH|WILD_SILENT;
 
     if (xp->xp_context == EXPAND_UNSUCCESSFUL)
     {
@@ -4356,9 +4386,11 @@
     if (file_str == NULL)
 	return EXPAND_UNSUCCESSFUL;
 
+    if (p_wic)
+	options += WILD_ICASE;
+
     /* find all files that match the description */
-    if (ExpandFromContext(xp, file_str, matchcount, matches,
-					  WILD_ADD_SLASH|WILD_SILENT) == FAIL)
+    if (ExpandFromContext(xp, file_str, matchcount, matches, options) == FAIL)
     {
 	*matchcount = 0;
 	*matches = NULL;
@@ -4410,7 +4442,7 @@
     char_u	*pat;
     int		*num_file;
     char_u	***file;
-    int		options;
+    int		options;  /* EW_ flags */
 {
 #ifdef FEAT_CMDL_COMPL
     regmatch_T	regmatch;
@@ -4464,6 +4496,9 @@
 	    flags |= (EW_FILE | EW_PATH);
 	else
 	    flags = (flags | EW_DIR) & ~EW_FILE;
+	if (options & WILD_ICASE)
+	    flags |= EW_ICASE;
+
 	/* Expand wildcards, supporting %:h and the like. */
 	ret = expand_wildcards_eval(&pat, num_file, file, flags);
 	if (free_pat)
@@ -4728,7 +4763,11 @@
 			    || (pat[1] == '.' && vim_ispathsep(pat[2])))))
 	path = (char_u *)".";
     else
+    {
 	path = vim_getenv((char_u *)"PATH", &mustfree);
+	if (path == NULL)
+	    path = (char_u *)"";
+    }
 
     /*
      * Go over all directories in $PATH.  Expand matches in that directory and
@@ -6147,9 +6186,7 @@
     curwin->w_p_rl = cmdmsg_rl;
     cmdmsg_rl = FALSE;
 # endif
-# ifdef FEAT_SCROLLBIND
-    curwin->w_p_scb = FALSE;
-# endif
+    RESET_BINDING(curwin);
 
 # ifdef FEAT_AUTOCMD
     /* Do execute autocommands for setting the filetype (load syntax). */
diff -Naur vim73.orig/src/fileio.c vim73/src/fileio.c
--- vim73.orig/src/fileio.c	2010-08-14 12:20:54.000000000 +0000
+++ vim73/src/fileio.c	2011-05-17 09:39:31.607919537 +0000
@@ -11,14 +11,6 @@
  * fileio.c: read from and write to a file
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for lseek(), must be before vim.h */
-#endif
-
-#if defined __EMX__
-# include "vimio.h"	/* for mktemp(), CJW 1997-12-03 */
-#endif
-
 #include "vim.h"
 
 #if defined(__TANDEM) || defined(__MINT__)
@@ -258,6 +250,7 @@
 #ifdef FEAT_CRYPT
     char_u	*cryptkey = NULL;
     int		did_ask_for_key = FALSE;
+    int		crypt_method_used;
 #endif
 #ifdef FEAT_PERSISTENT_UNDO
     context_sha256_T sha_ctx;
@@ -325,7 +318,7 @@
     int		using_b_fname;
 #endif
 
-    write_no_eol_lnum = 0;	/* in case it was set by the previous read */
+    curbuf->b_no_eol_lnum = 0;	/* in case it was set by the previous read */
 
     /*
      * If there is no file name yet, use the one for the read file.
@@ -511,18 +504,11 @@
 
     if (newfile && !read_stdin && !read_buffer)
     {
-	/* Remember time of file.
-	 * For RISCOS, also remember the filetype.
-	 */
+	/* Remember time of file. */
 	if (mch_stat((char *)fname, &st) >= 0)
 	{
 	    buf_store_time(curbuf, &st, fname);
 	    curbuf->b_mtime_read = curbuf->b_mtime;
-
-#if defined(RISCOS) && defined(FEAT_OSFILETYPE)
-	    /* Read the filetype into the buffer local filetype option. */
-	    mch_read_filetype(fname);
-#endif
 #ifdef UNIX
 	    /*
 	     * Use the protection bits of the original file for the swap file.
@@ -564,7 +550,6 @@
 
 /*
  * for UNIX: check readonly with perm and mch_access()
- * for RISCOS: same as Unix, otherwise file gets re-datestamped!
  * for MSDOS and Amiga: check readonly by trying to open the file for writing
  */
     file_readonly = FALSE;
@@ -918,7 +903,7 @@
 	    {
 		/* Read the first line (and a bit more).  Immediately rewind to
 		 * the start of the file.  If the read() fails "len" is -1. */
-		len = vim_read(fd, firstline, 80);
+		len = read_eintr(fd, firstline, 80);
 		lseek(fd, (off_t)0L, SEEK_SET);
 		for (p = firstline; p < firstline + len; ++p)
 		    if (*p >= 0x80)
@@ -1373,7 +1358,7 @@
 		    /*
 		     * Read bytes from the file.
 		     */
-		    size = vim_read(fd, ptr, size);
+		    size = read_eintr(fd, ptr, size);
 		}
 
 		if (size <= 0)
@@ -2297,6 +2282,7 @@
 	save_file_ff(curbuf);		/* remember the current file format */
 
 #ifdef FEAT_CRYPT
+    crypt_method_used = use_crypt_method;
     if (cryptkey != NULL)
     {
 	crypt_pop_state();
@@ -2491,7 +2477,10 @@
 #ifdef FEAT_CRYPT
 	    if (cryptkey != NULL)
 	    {
-		STRCAT(IObuff, _("[crypted]"));
+		if (crypt_method_used == 1)
+		    STRCAT(IObuff, _("[blowfish]"));
+		else
+		    STRCAT(IObuff, _("[crypted]"));
 		c = TRUE;
 	    }
 #endif
@@ -2607,10 +2596,11 @@
 
     /*
      * Trick: We remember if the last line of the read didn't have
-     * an eol for when writing it again.  This is required for
+     * an eol even when 'binary' is off, for when writing it again with
+     * 'binary' on.  This is required for
      * ":autocmd FileReadPost *.gz set bin|'[,']!gunzip" to work.
      */
-    write_no_eol_lnum = read_no_eol_lnum;
+    curbuf->b_no_eol_lnum = read_no_eol_lnum;
 
     /* When reloading a buffer put the cursor at the first line that is
      * different. */
@@ -2658,13 +2648,17 @@
 							    FALSE, NULL, eap);
 	if (msg_scrolled == n)
 	    msg_scroll = m;
-#ifdef FEAT_EVAL
+# ifdef FEAT_EVAL
 	if (aborting())	    /* autocmds may abort script processing */
 	    return FAIL;
-#endif
+# endif
     }
 #endif
 
+    /* Reset now, following writes should not omit the EOL.  Also, the line
+     * number will become invalid because of edits. */
+    curbuf->b_no_eol_lnum = 0;
+
     if (recoverymode && error)
 	return FAIL;
     return OK;
@@ -3202,6 +3196,9 @@
     int		    write_undo_file = FALSE;
     context_sha256_T sha_ctx;
 #endif
+#ifdef FEAT_CRYPT
+    int		    crypt_method_used;
+#endif
 
     if (fname == NULL || *fname == NUL)	/* safety check */
 	return FAIL;
@@ -3799,13 +3796,7 @@
 
 	/* make sure we have a valid backup extension to use */
 	if (*p_bex == NUL)
-	{
-#ifdef RISCOS
-	    backup_ext = (char_u *)"/bak";
-#else
 	    backup_ext = (char_u *)".bak";
-#endif
-	}
 	else
 	    backup_ext = p_bex;
 
@@ -4000,7 +3991,7 @@
 #ifdef HAS_BW_FLAGS
 			write_info.bw_flags = FIO_NOCONVERT;
 #endif
-			while ((write_info.bw_len = vim_read(fd, copybuf,
+			while ((write_info.bw_len = read_eintr(fd, copybuf,
 								BUFSIZE)) > 0)
 			{
 			    if (buf_write_bytes(&write_info) == FAIL)
@@ -4568,7 +4559,7 @@
 	if (end == 0
 		|| (lnum == end
 		    && write_bin
-		    && (lnum == write_no_eol_lnum
+		    && (lnum == buf->b_no_eol_lnum
 			|| (lnum == buf->b_ml.ml_line_count && !buf->b_p_eol))))
 	{
 	    ++lnum;			/* written the line, count it */
@@ -4719,11 +4710,6 @@
 #endif
     if (perm >= 0)		/* set perm. of new file same as old file */
 	(void)mch_setperm(wfname, perm);
-#ifdef RISCOS
-    if (!append && !filtering)
-	/* Set the filetype after writing the file. */
-	mch_set_filetype(wfname, buf->b_p_oft);
-#endif
 #ifdef HAVE_ACL
     /* Probably need to set the ACL before changing the user (can't set the
      * ACL on a file the user doesn't own). */
@@ -4731,6 +4717,7 @@
 	mch_set_acl(wfname, acl);
 #endif
 #ifdef FEAT_CRYPT
+    crypt_method_used = use_crypt_method;
     if (wb_flags & FIO_ENCRYPTED)
 	crypt_pop_state();
 #endif
@@ -4813,7 +4800,7 @@
 #ifdef HAS_BW_FLAGS
 			write_info.bw_flags = FIO_NOCONVERT;
 #endif
-			while ((write_info.bw_len = vim_read(fd, smallbuf,
+			while ((write_info.bw_len = read_eintr(fd, smallbuf,
 						      SMBUFSIZE)) > 0)
 			    if (buf_write_bytes(&write_info) == FAIL)
 				break;
@@ -4885,7 +4872,10 @@
 #ifdef FEAT_CRYPT
 	if (wb_flags & FIO_ENCRYPTED)
 	{
-	    STRCAT(IObuff, _("[crypted]"));
+	    if (crypt_method_used == 1)
+		STRCAT(IObuff, _("[blowfish]"));
+	    else
+		STRCAT(IObuff, _("[crypted]"));
 	    c = TRUE;
 	}
 #endif
@@ -5094,8 +5084,6 @@
     {
 	aco_save_T	aco;
 
-	write_no_eol_lnum = 0;	/* in case it was set by the previous read */
-
 	/*
 	 * Apply POST autocommands.
 	 * Careful: The autocommands may call buf_write() recursively!
@@ -5330,7 +5318,7 @@
 
 /*
  * Call write() to write a number of bytes to the file.
- * Also handles encryption and 'encoding' conversion.
+ * Handles encryption and 'encoding' conversion.
  *
  * Return FAIL for failure, OK otherwise.
  */
@@ -5702,16 +5690,8 @@
 	crypt_encode(buf, len, buf);
 #endif
 
-    /* Repeat the write(), it may be interrupted by a signal. */
-    while (len > 0)
-    {
-	wlen = vim_write(ip->bw_fd, buf, len);
-	if (wlen <= 0)		    /* error! */
-	    return FAIL;
-	len -= wlen;
-	buf += wlen;
-    }
-    return OK;
+    wlen = write_eintr(ip->bw_fd, buf, len);
+    return (wlen < len) ? FAIL : OK;
 }
 
 #ifdef FEAT_MBYTE
@@ -6024,15 +6004,19 @@
 shorten_fname1(full_path)
     char_u	*full_path;
 {
-    char_u	dirname[MAXPATHL];
+    char_u	*dirname;
     char_u	*p = full_path;
 
+    dirname = alloc(MAXPATHL);
+    if (dirname == NULL)
+	return full_path;
     if (mch_dirname(dirname, MAXPATHL) == OK)
     {
 	p = shorten_fname(full_path, dirname);
 	if (p == NULL || *p == NUL)
 	    p = full_path;
     }
+    vim_free(dirname);
     return p;
 }
 #endif
@@ -6259,19 +6243,17 @@
      */
     for (ptr = retval + fnamelen; ptr > retval; mb_ptr_back(retval, ptr))
     {
-#ifndef RISCOS
 	if (*ext == '.'
-# ifdef USE_LONG_FNAME
+#ifdef USE_LONG_FNAME
 		    && (!USE_LONG_FNAME || shortname)
-# else
-#  ifndef SHORT_FNAME
+#else
+# ifndef SHORT_FNAME
 		    && shortname
-#  endif
 # endif
+#endif
 								)
 	    if (*ptr == '.')	/* replace '.' by '_' */
 		*ptr = '_';
-#endif
 	if (vim_ispathsep(*ptr))
 	{
 	    ++ptr;
@@ -6306,23 +6288,14 @@
 	if (fname == NULL || *fname == NUL
 				   || vim_ispathsep(fname[STRLEN(fname) - 1]))
 	{
-#ifdef RISCOS
-	    if (*ext == '/')
-#else
 	    if (*ext == '.')
-#endif
 		*s++ = '_';
 	}
 	/*
 	 * If the extension starts with '.', truncate the base name at 8
 	 * characters
 	 */
-#ifdef RISCOS
-	/* We normally use '/', but swap files are '_' */
-	else if (*ext == '/' || *ext == '_')
-#else
 	else if (*ext == '.')
-#endif
 	{
 	    if ((size_t)(s - ptr) > (size_t)8)
 	    {
@@ -6334,13 +6307,8 @@
 	 * If the extension doesn't start with '.', and the file name
 	 * doesn't have an extension yet, append a '.'
 	 */
-#ifdef RISCOS
-	else if ((e = vim_strchr(ptr, '/')) == NULL)
-	    *s++ = '/';
-#else
 	else if ((e = vim_strchr(ptr, '.')) == NULL)
 	    *s++ = '.';
-#endif
 	/*
 	 * If the extension doesn't start with '.', and there already is an
 	 * extension, it may need to be truncated
@@ -6368,23 +6336,14 @@
     /*
      * Prepend the dot.
      */
-    if (prepend_dot && !shortname && *(e = gettail(retval)) !=
-#ifdef RISCOS
-	    '/'
-#else
-	    '.'
-#endif
+    if (prepend_dot && !shortname && *(e = gettail(retval)) != '.'
 #ifdef USE_LONG_FNAME
 	    && USE_LONG_FNAME
 #endif
 				)
     {
 	STRMOVE(e + 1, e);
-#ifdef RISCOS
-	*e = '/';
-#else
 	*e = '.';
-#endif
     }
 #endif
 
@@ -6552,6 +6511,21 @@
 	    use_tmp_file = TRUE;
     }
 #endif
+#ifdef WIN3264
+    {
+	BY_HANDLE_FILE_INFORMATION info1, info2;
+
+	/* It's possible for the source and destination to be the same file.
+	 * In that case go through a temp file name.  This makes rename("foo",
+	 * "./foo") a no-op (in a complicated way). */
+	if (win32_fileinfo(from, &info1) == FILEINFO_OK
+		&& win32_fileinfo(to, &info2) == FILEINFO_OK
+		&& info1.dwVolumeSerialNumber == info2.dwVolumeSerialNumber
+		&& info1.nFileIndexHigh == info2.nFileIndexHigh
+		&& info1.nFileIndexLow == info2.nFileIndexLow)
+	    use_tmp_file = TRUE;
+    }
+#endif
 
 #if defined(UNIX) || defined(CASE_INSENSITIVE_FILENAME)
     if (use_tmp_file)
@@ -6662,8 +6636,8 @@
 	return -1;
     }
 
-    while ((n = vim_read(fd_in, buffer, BUFSIZE)) > 0)
-	if (vim_write(fd_out, buffer, n) != n)
+    while ((n = read_eintr(fd_in, buffer, BUFSIZE)) > 0)
+	if (write_eintr(fd_out, buffer, n) != n)
 	{
 	    errmsg = _("E208: Error writing to \"%s\"");
 	    break;
@@ -7024,7 +6998,7 @@
 		    STRCAT(tbuf, mesg2);
 		}
 		if (do_dialog(VIM_WARNING, (char_u *)_("Warning"), tbuf,
-				(char_u *)_("&OK\n&Load File"), 1, NULL) == 2)
+			  (char_u *)_("&OK\n&Load File"), 1, NULL, TRUE) == 2)
 		    reload = TRUE;
 	    }
 	    else
@@ -7272,8 +7246,8 @@
 write_lnum_adjust(offset)
     linenr_T	offset;
 {
-    if (write_no_eol_lnum != 0)		/* only if there is a missing eol */
-	write_no_eol_lnum += offset;
+    if (curbuf->b_no_eol_lnum != 0)	/* only if there is a missing eol */
+	curbuf->b_no_eol_lnum += offset;
 }
 
 #if defined(TEMPDIRNAMES) || defined(PROTO)
@@ -7475,7 +7449,10 @@
 
     STRCPY(itmp, "");
     if (GetTempPath(_MAX_PATH, szTempFile) == 0)
-	szTempFile[0] = NUL;	/* GetTempPath() failed, use current dir */
+    {
+	szTempFile[0] = '.';	/* GetTempPath() failed, use current dir */
+	szTempFile[1] = NUL;
+    }
     strcpy(buf4, "VIM");
     buf4[2] = extra_char;   /* make it "VIa", "VIb", etc. */
     if (GetTempFileName(szTempFile, buf4, 0, itmp) == 0)
@@ -7496,8 +7473,11 @@
 # else /* WIN3264 */
 
 #  ifdef USE_TMPNAM
+    char_u	*p;
+
     /* tmpnam() will make its own name */
-    if (*tmpnam((char *)itmp) == NUL)
+    p = tmpnam((char *)itmp);
+    if (p == NULL || *p == NUL)
 	return NULL;
 #  else
     char_u	*p;
@@ -10181,19 +10161,11 @@
 		    ++p;
 		break;
 	    case '.':
-#ifdef RISCOS
-		if (allow_dirs != NULL)
-		     *allow_dirs = TRUE;
-		/* FALLTHROUGH */
-#endif
 	    case '~':
 		reg_pat[i++] = '\\';
 		reg_pat[i++] = *p;
 		break;
 	    case '?':
-#ifdef RISCOS
-	    case '#':
-#endif
 		reg_pat[i++] = '.';
 		break;
 	    case '\\':
@@ -10304,3 +10276,55 @@
     }
     return reg_pat;
 }
+
+#if defined(EINTR) || defined(PROTO)
+/*
+ * Version of read() that retries when interrupted by EINTR (possibly
+ * by a SIGWINCH).
+ */
+    long
+read_eintr(fd, buf, bufsize)
+    int	    fd;
+    void    *buf;
+    size_t  bufsize;
+{
+    long ret;
+
+    for (;;)
+    {
+	ret = vim_read(fd, buf, bufsize);
+	if (ret >= 0 || errno != EINTR)
+	    break;
+    }
+    return ret;
+}
+
+/*
+ * Version of write() that retries when interrupted by EINTR (possibly
+ * by a SIGWINCH).
+ */
+    long
+write_eintr(fd, buf, bufsize)
+    int	    fd;
+    void    *buf;
+    size_t  bufsize;
+{
+    long    ret = 0;
+    long    wlen;
+
+    /* Repeat the write() so long it didn't fail, other than being interrupted
+     * by a signal. */
+    while (ret < (long)bufsize)
+    {
+	wlen = vim_write(fd, (char *)buf + ret, bufsize - ret);
+	if (wlen < 0)
+	{
+	    if (errno != EINTR)
+		break;
+	}
+	else
+	    ret += wlen;
+    }
+    return ret;
+}
+#endif
diff -Naur vim73.orig/src/getchar.c vim73/src/getchar.c
--- vim73.orig/src/getchar.c	2010-08-08 13:00:33.000000000 +0000
+++ vim73/src/getchar.c	2011-05-17 09:38:46.448931545 +0000
@@ -635,11 +635,14 @@
 /*
  * Stuff "s" into the stuff buffer, leaving special key codes unmodified and
  * escaping other K_SPECIAL and CSI bytes.
+ * Change CR, LF and ESC into a space.
  */
     void
 stuffReadbuffSpec(s)
     char_u	*s;
 {
+    int c;
+
     while (*s != NUL)
     {
 	if (*s == K_SPECIAL && s[1] != NUL && s[2] != NUL)
@@ -649,11 +652,16 @@
 	    s += 3;
 	}
 	else
+	{
 #ifdef FEAT_MBYTE
-	    stuffcharReadbuff(mb_ptr2char_adv(&s));
+	    c = mb_ptr2char_adv(&s);
 #else
-	    stuffcharReadbuff(*s++);
+	    c = *s++;
 #endif
+	    if (c == CAR || c == NL || c == ESC)
+		c = ' ';
+	    stuffcharReadbuff(c);
+	}
     }
 }
 #endif
@@ -1506,9 +1514,6 @@
     }
 }
 
-#define KL_PART_KEY -1		/* keylen value for incomplete key-code */
-#define KL_PART_MAP -2		/* keylen value for incomplete mapping */
-
 /*
  * Get the next input character.
  * Can return a special key or a multi-byte character.
@@ -2171,7 +2176,7 @@
 					if (!timedout)
 					{
 					    /* break at a partly match */
-					    keylen = KL_PART_MAP;
+					    keylen = KEYLEN_PART_MAP;
 					    break;
 					}
 				    }
@@ -2192,7 +2197,7 @@
 
 			/* If no partly match found, use the longest full
 			 * match. */
-			if (keylen != KL_PART_MAP)
+			if (keylen != KEYLEN_PART_MAP)
 			{
 			    mp = mp_match;
 			    keylen = mp_match_len;
@@ -2230,7 +2235,7 @@
 			}
 			/* Need more chars for partly match. */
 			if (mlen == typebuf.tb_len)
-			    keylen = KL_PART_KEY;
+			    keylen = KEYLEN_PART_KEY;
 			else if (max_mlen < mlen)
 			    /* no match, may have to check for termcode at
 			     * next character */
@@ -2238,7 +2243,7 @@
 		    }
 
 		    if ((mp == NULL || max_mlen >= mp_match_len)
-						     && keylen != KL_PART_MAP)
+						 && keylen != KEYLEN_PART_MAP)
 		    {
 			int	save_keylen = keylen;
 
@@ -2264,8 +2269,8 @@
 			    /* If no termcode matched but 'pastetoggle'
 			     * matched partially it's like an incomplete key
 			     * sequence. */
-			    if (keylen == 0 && save_keylen == KL_PART_KEY)
-				keylen = KL_PART_KEY;
+			    if (keylen == 0 && save_keylen == KEYLEN_PART_KEY)
+				keylen = KEYLEN_PART_KEY;
 
 			    /*
 			     * When getting a partial match, but the last
@@ -2302,7 +2307,7 @@
 				    continue;
 				}
 				if (*s == NUL)	    /* need more characters */
-				    keylen = KL_PART_KEY;
+				    keylen = KEYLEN_PART_KEY;
 			    }
 			    if (keylen >= 0)
 #endif
@@ -2339,7 +2344,8 @@
 			if (keylen > 0)	    /* full matching terminal code */
 			{
 #if defined(FEAT_GUI) && defined(FEAT_MENU)
-			    if (typebuf.tb_buf[typebuf.tb_off] == K_SPECIAL
+			    if (typebuf.tb_len >= 2
+				&& typebuf.tb_buf[typebuf.tb_off] == K_SPECIAL
 					 && typebuf.tb_buf[typebuf.tb_off + 1]
 								   == KS_MENU)
 			    {
@@ -2381,7 +2387,7 @@
 			/* Partial match: get some more characters.  When a
 			 * matching mapping was found use that one. */
 			if (mp == NULL || keylen < 0)
-			    keylen = KL_PART_KEY;
+			    keylen = KEYLEN_PART_KEY;
 			else
 			    keylen = mp_match_len;
 		    }
@@ -2553,7 +2559,8 @@
 #endif
 			&& typebuf.tb_maplen == 0
 			&& (State & INSERT)
-			&& (p_timeout || (keylen == KL_PART_KEY && p_ttimeout))
+			&& (p_timeout
+			    || (keylen == KEYLEN_PART_KEY && p_ttimeout))
 			&& (c = inchar(typebuf.tb_buf + typebuf.tb_off
 						     + typebuf.tb_len, 3, 25L,
 						 typebuf.tb_change_cnt)) == 0)
@@ -2711,8 +2718,11 @@
 		 * are still available.  But when those available characters
 		 * are part of a mapping, and we are going to do a blocking
 		 * wait here.  Need to update the screen to display the
-		 * changed text so far. */
-		if ((State & INSERT) && advance && must_redraw != 0)
+		 * changed text so far. Also for when 'lazyredraw' is set and
+		 * redrawing was postponed because there was something in the
+		 * input buffer (e.g., termresponse). */
+		if (((State & INSERT) != 0 || p_lz) && (State & CMDLINE) == 0
+			  && advance && must_redraw != 0 && !need_wait_return)
 		{
 		    update_screen(0);
 		    setcursor(); /* put cursor back where it belongs */
@@ -2783,9 +2793,9 @@
 			    ? 0
 			    : ((typebuf.tb_len == 0
 				    || !(p_timeout || (p_ttimeout
-						   && keylen == KL_PART_KEY)))
+					       && keylen == KEYLEN_PART_KEY)))
 				    ? -1L
-				    : ((keylen == KL_PART_KEY && p_ttm >= 0)
+				    : ((keylen == KEYLEN_PART_KEY && p_ttm >= 0)
 					    ? p_ttm
 					    : p_tm)), typebuf.tb_change_cnt);
 
@@ -3168,6 +3178,7 @@
     int		expr = FALSE;
 #endif
     int		noremap;
+    char_u      *orig_rhs;
 
     keys = arg;
     map_table = maphash;
@@ -3266,6 +3277,7 @@
     }
     if (*p != NUL)
 	*p++ = NUL;
+
     p = skipwhite(p);
     rhs = p;
     hasarg = (*rhs != NUL);
@@ -3288,6 +3300,7 @@
      */
     if (haskey)
 	keys = replace_termcodes(keys, &keys_buf, TRUE, TRUE, special);
+    orig_rhs = rhs;
     if (hasarg)
     {
 	if (STRICMP(rhs, "<nop>") == 0)	    /* "<Nop>" means nothing */
@@ -3298,7 +3311,7 @@
 
 #ifdef FEAT_FKMAP
     /*
-     * when in right-to-left mode and alternate keymap option set,
+     * When in right-to-left mode and alternate keymap option set,
      * reverse the character flow in the rhs in Farsi.
      */
     if (p_altkeymap && curwin->w_p_rl)
@@ -3556,6 +3569,8 @@
 				}
 				vim_free(mp->m_str);
 				mp->m_str = newstr;
+				vim_free(mp->m_orig_str);
+				mp->m_orig_str = vim_strsave(orig_rhs);
 				mp->m_noremap = noremap;
 				mp->m_silent = silent;
 				mp->m_mode = mode;
@@ -3633,10 +3648,12 @@
 
     mp->m_keys = vim_strsave(keys);
     mp->m_str = vim_strsave(rhs);
+    mp->m_orig_str = vim_strsave(orig_rhs);
     if (mp->m_keys == NULL || mp->m_str == NULL)
     {
 	vim_free(mp->m_keys);
 	vim_free(mp->m_str);
+	vim_free(mp->m_orig_str);
 	vim_free(mp);
 	retval = 4;	/* no mem */
 	goto theend;
@@ -3682,6 +3699,7 @@
     mp = *mpp;
     vim_free(mp->m_keys);
     vim_free(mp->m_str);
+    vim_free(mp->m_orig_str);
     *mpp = mp->m_next;
     vim_free(mp);
 }
@@ -3851,12 +3869,57 @@
     }
 }
 
+/*
+ * Return characters to represent the map mode in an allocated string.
+ * Returns NULL when out of memory.
+ */
+    char_u *
+map_mode_to_chars(mode)
+    int mode;
+{
+    garray_T    mapmode;
+
+    ga_init2(&mapmode, 1, 7);
+
+    if ((mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)
+	ga_append(&mapmode, '!');			/* :map! */
+    else if (mode & INSERT)
+	ga_append(&mapmode, 'i');			/* :imap */
+    else if (mode & LANGMAP)
+	ga_append(&mapmode, 'l');			/* :lmap */
+    else if (mode & CMDLINE)
+	ga_append(&mapmode, 'c');			/* :cmap */
+    else if ((mode & (NORMAL + VISUAL + SELECTMODE + OP_PENDING))
+				 == NORMAL + VISUAL + SELECTMODE + OP_PENDING)
+	ga_append(&mapmode, ' ');			/* :map */
+    else
+    {
+	if (mode & NORMAL)
+	    ga_append(&mapmode, 'n');			/* :nmap */
+	if (mode & OP_PENDING)
+	    ga_append(&mapmode, 'o');			/* :omap */
+	if ((mode & (VISUAL + SELECTMODE)) == VISUAL + SELECTMODE)
+	    ga_append(&mapmode, 'v');			/* :vmap */
+	else
+	{
+	    if (mode & VISUAL)
+		ga_append(&mapmode, 'x');		/* :xmap */
+	    if (mode & SELECTMODE)
+		ga_append(&mapmode, 's');		/* :smap */
+	}
+    }
+
+    ga_append(&mapmode, NUL);
+    return (char_u *)mapmode.ga_data;
+}
+
     static void
 showmap(mp, local)
     mapblock_T	*mp;
     int		local;	    /* TRUE for buffer-local map */
 {
-    int len = 1;
+    int		len = 1;
+    char_u	*mapchars;
 
     if (msg_didout || msg_silent != 0)
     {
@@ -3864,49 +3927,15 @@
 	if (got_int)	    /* 'q' typed at MORE prompt */
 	    return;
     }
-    if ((mp->m_mode & (INSERT + CMDLINE)) == INSERT + CMDLINE)
-	msg_putchar('!');			/* :map! */
-    else if (mp->m_mode & INSERT)
-	msg_putchar('i');			/* :imap */
-    else if (mp->m_mode & LANGMAP)
-	msg_putchar('l');			/* :lmap */
-    else if (mp->m_mode & CMDLINE)
-	msg_putchar('c');			/* :cmap */
-    else if ((mp->m_mode & (NORMAL + VISUAL + SELECTMODE + OP_PENDING))
-				 == NORMAL + VISUAL + SELECTMODE + OP_PENDING)
-	msg_putchar(' ');			/* :map */
-    else
+
+    mapchars = map_mode_to_chars(mp->m_mode);
+    if (mapchars != NULL)
     {
-	len = 0;
-	if (mp->m_mode & NORMAL)
-	{
-	    msg_putchar('n');		/* :nmap */
-	    ++len;
-	}
-	if (mp->m_mode & OP_PENDING)
-	{
-	    msg_putchar('o');		/* :omap */
-	    ++len;
-	}
-	if ((mp->m_mode & (VISUAL + SELECTMODE)) == VISUAL + SELECTMODE)
-	{
-	    msg_putchar('v');		/* :vmap */
-	    ++len;
-	}
-	else
-	{
-	    if (mp->m_mode & VISUAL)
-	    {
-		msg_putchar('x');		/* :xmap */
-		++len;
-	    }
-	    if (mp->m_mode & SELECTMODE)
-	    {
-		msg_putchar('s');		/* :smap */
-		++len;
-	    }
-	}
+	msg_puts(mapchars);
+	len = (int)STRLEN(mapchars);
+	vim_free(mapchars);
     }
+
     while (++len <= 3)
 	msg_putchar(' ');
 
@@ -3931,8 +3960,7 @@
 	msg_putchar(' ');
 
     /* Use FALSE below if we only want things like <Up> to show up as such on
-     * the rhs, and not M-x etc, TRUE gets both -- webb
-     */
+     * the rhs, and not M-x etc, TRUE gets both -- webb */
     if (*mp->m_str == NUL)
 	msg_puts_attr((char_u *)"<Nop>", hl_attr(HLF_8));
     else
@@ -4995,19 +5023,21 @@
     sourcing_name = save_name;
 }
 
-#ifdef FEAT_EVAL
+#if defined(FEAT_EVAL) || defined(PROTO)
 /*
- * Check the string "keys" against the lhs of all mappings
- * Return pointer to rhs of mapping (mapblock->m_str)
- * NULL otherwise
+ * Check the string "keys" against the lhs of all mappings.
+ * Return pointer to rhs of mapping (mapblock->m_str).
+ * NULL when no mapping found.
  */
     char_u *
-check_map(keys, mode, exact, ign_mod, abbr)
+check_map(keys, mode, exact, ign_mod, abbr, mp_ptr, local_ptr)
     char_u	*keys;
     int		mode;
     int		exact;		/* require exact match */
     int		ign_mod;	/* ignore preceding modifier */
     int		abbr;		/* do abbreviations */
+    mapblock_T	**mp_ptr;	/* return: pointer to mapblock or NULL */
+    int		*local_ptr;	/* return: buffer-local mapping or NULL */
 {
     int		hash;
     int		len, minlen;
@@ -5062,7 +5092,17 @@
 			    minlen = mp->m_keylen - 3;
 		    }
 		    if (STRNCMP(s, keys, minlen) == 0)
+		    {
+			if (mp_ptr != NULL)
+			    *mp_ptr = mp;
+			if (local_ptr != NULL)
+#ifdef FEAT_LOCALMAP
+			    *local_ptr = local;
+#else
+			    *local_ptr = 0;
+#endif
 			return mp->m_str;
+		    }
 		}
 	    }
 	}
diff -Naur vim73.orig/src/globals.h vim73/src/globals.h
--- vim73.orig/src/globals.h	2010-07-23 19:20:45.000000000 +0000
+++ vim73/src/globals.h	2011-05-17 09:39:31.607919537 +0000
@@ -510,8 +510,13 @@
 EXTERN VimClipboard clip_plus;	/* CLIPBOARD selection in X11 */
 # else
 #  define clip_plus clip_star	/* there is only one clipboard */
+#  define ONE_CLIPBOARD
 # endif
-EXTERN int	clip_unnamed INIT(= FALSE);
+
+#define CLIP_UNNAMED      1
+#define CLIP_UNNAMED_PLUS 2
+EXTERN int	clip_unnamed INIT(= 0); /* above two values or'ed */
+
 EXTERN int	clip_autoselect INIT(= FALSE);
 EXTERN int	clip_autoselectml INIT(= FALSE);
 EXTERN int	clip_html INIT(= FALSE);
@@ -1052,10 +1057,6 @@
 			;
 #endif
 
-EXTERN linenr_T	write_no_eol_lnum INIT(= 0); /* non-zero lnum when last line
-						of next binary write should
-						not have an end-of-line */
-
 #ifdef FEAT_WINDOWS
 EXTERN int	postponed_split INIT(= 0);  /* for CTRL-W CTRL-] command */
 EXTERN int	postponed_split_flags INIT(= 0);  /* args for win_split() */
@@ -1512,7 +1513,7 @@
 EXTERN char_u e_sandbox[]	INIT(= N_("E48: Not allowed in sandbox"));
 #endif
 EXTERN char_u e_secure[]	INIT(= N_("E523: Not allowed here"));
-#if defined(AMIGA) || defined(MACOS) || defined(MSWIN) || defined(RISCOS) \
+#if defined(AMIGA) || defined(MACOS) || defined(MSWIN)  \
 	|| defined(UNIX) || defined(VMS) || defined(OS2)
 EXTERN char_u e_screenmode[]	INIT(= N_("E359: Screen mode setting not supported"));
 #endif
@@ -1560,6 +1561,9 @@
 	(defined(FEAT_INS_EXPAND) && defined(FEAT_COMPL_FUNC))
 EXTERN char_u e_notset[]	INIT(= N_("E764: Option '%s' is not set"));
 #endif
+#ifndef FEAT_CLIPBOARD
+EXTERN char_u e_invalidreg[]    INIT(= N_("E850: Invalid register name"));
+#endif
 
 #ifdef MACOS_X_UNIX
 EXTERN short disallow_gui	INIT(= FALSE);
diff -Naur vim73.orig/src/gui.c vim73/src/gui.c
--- vim73.orig/src/gui.c	2010-08-08 13:01:18.000000000 +0000
+++ vim73/src/gui.c	2011-05-17 09:39:31.607919537 +0000
@@ -105,8 +105,18 @@
 
 #if defined(FEAT_GUI_GTK) || defined(FEAT_GUI_X11)
     if (gui.in_use)
+    {
+# ifdef FEAT_EVAL
+	Window	x11_window;
+	Display	*x11_display;
+
+	if (gui_get_x11_windis(&x11_window, &x11_display) == OK)
+	    set_vim_var_nr(VV_WINDOWID, (long)x11_window);
+# endif
+
 	/* Display error messages in a dialog now. */
 	display_errors();
+    }
 #endif
 
 #if defined(MAY_FORK) && !defined(__QNXNTO__)
@@ -2146,7 +2156,7 @@
 
     if (highlight_mask & (HL_INVERSE | HL_STANDOUT))
     {
-#if defined(AMIGA) || defined(RISCOS)
+#if defined(AMIGA)
 	gui_mch_set_colors(bg_color, fg_color);
 #else
 	gui_mch_set_fg_color(bg_color);
@@ -2155,7 +2165,7 @@
     }
     else
     {
-#if defined(AMIGA) || defined(RISCOS)
+#if defined(AMIGA)
 	gui_mch_set_colors(fg_color, bg_color);
 #else
 	gui_mch_set_fg_color(fg_color);
@@ -2183,7 +2193,7 @@
     if (back != 0 && ((draw_flags & DRAW_BOLD) || (highlight_mask & HL_ITALIC)))
 	return FAIL;
 
-#if defined(RISCOS) || defined(FEAT_GUI_GTK)
+#if defined(FEAT_GUI_GTK)
     /* If there's no italic font, then fake it.
      * For GTK2, we don't need a different font for italic style. */
     if (hl_mask_todo & HL_ITALIC)
@@ -2352,7 +2362,7 @@
     if (draw_sign)
 	/* Draw the sign on top of the spaces. */
 	gui_mch_drawsign(gui.row, col, gui.highlight_mask);
-# if defined(FEAT_NETBEANS_INTG) && (defined(FEAT_GUI_MOTIF) \
+# if defined(FEAT_NETBEANS_INTG) && (defined(FEAT_GUI_X11) \
 	|| defined(FEAT_GUI_GTK) || defined(FEAT_GUI_W32))
     if (multi_sign)
 	netbeans_draw_multisign_indicator(gui.row);
@@ -2975,26 +2985,11 @@
 	    did_clip = TRUE;
 	}
 	/* Allow the left button to start the selection */
-	else if (button ==
-# ifdef RISCOS
-		/* Only start a drag on a drag event. Otherwise
-		 * we don't get a release event. */
-		    MOUSE_DRAG
-# else
-		    MOUSE_LEFT
-# endif
-				)
-	{
-	    clip_start_selection(X_2_COL(x), Y_2_ROW(y), repeated_click);
-	    did_clip = TRUE;
-	}
-# ifdef RISCOS
 	else if (button == MOUSE_LEFT)
 	{
-	    clip_clear_selection();
+	    clip_start_selection(X_2_COL(x), Y_2_ROW(y), repeated_click);
 	    did_clip = TRUE;
 	}
-# endif
 
 	/* Always allow pasting */
 	if (button != MOUSE_MIDDLE)
@@ -4893,7 +4888,7 @@
 		if (STRLEN(p) > 2000)
 		    STRCPY(p + 2000 - 14, "...(truncated)");
 		(void)do_dialog(VIM_ERROR, (char_u *)_("Error"),
-					      p, (char_u *)_("&Ok"), 1, NULL);
+				       p, (char_u *)_("&Ok"), 1, NULL, FALSE);
 		break;
 	    }
 	ga_clear(&error_ga);
diff -Naur vim73.orig/src/gui.h vim73/src/gui.h
--- vim73.orig/src/gui.h	2010-07-17 19:40:58.000000000 +0000
+++ vim73/src/gui.h	2011-05-17 09:39:31.611919093 +0000
@@ -52,10 +52,6 @@
 # include <SegLoad.h>*/
 #endif
 
-#ifdef RISCOS
-# include "gui_riscos.h"
-#endif
-
 #ifdef FEAT_GUI_PHOTON
 # include <Ph.h>
 # include <Pt.h>
@@ -151,7 +147,7 @@
 #define DRAW_BOLD		0x02	/* draw bold text */
 #define DRAW_UNDERL		0x04	/* draw underline text */
 #define DRAW_UNDERC		0x08	/* draw undercurl text */
-#if defined(RISCOS) || defined(FEAT_GUI_GTK)
+#if defined(FEAT_GUI_GTK)
 # define DRAW_ITALIC		0x10	/* draw italic text */
 #endif
 #define DRAW_CURSOR		0x20	/* drawing block cursor (win32) */
@@ -219,9 +215,6 @@
 #ifdef FEAT_GUI_MAC
     ControlHandle id;		/* A handle to the scrollbar */
 #endif
-#ifdef RISCOS
-    int		id;		/* Window handle of scrollbar window */
-#endif
 #ifdef FEAT_GUI_PHOTON
     PtWidget_t	*id;
 #endif
@@ -450,14 +443,6 @@
     int		visibility;	    /* Is window partially/fully obscured? */
 #endif
 
-#ifdef RISCOS
-    int		window_handle;
-    char_u	*window_title;
-    int		window_title_size;
-    int		fg_colour;		/* in 0xBBGGRR format */
-    int		bg_colour;
-#endif
-
 #ifdef FEAT_GUI_PHOTON
     PtWidget_t	*vimWindow;		/* PtWindow */
     PtWidget_t	*vimTextArea;		/* PtRaw */
diff -Naur vim73.orig/src/gui_athena.c vim73/src/gui_athena.c
--- vim73.orig/src/gui_athena.c	2010-08-08 13:01:39.000000000 +0000
+++ vim73/src/gui_athena.c	2011-05-17 09:36:14.481798035 +0000
@@ -2117,13 +2117,14 @@
 }
 
     int
-gui_mch_dialog(type, title, message, buttons, dfltbutton, textfield)
+gui_mch_dialog(type, title, message, buttons, dfltbutton, textfield, ex_cmd)
     int		type UNUSED;
     char_u	*title;
     char_u	*message;
     char_u	*buttons;
     int		dfltbutton UNUSED;
     char_u	*textfield;
+    int		ex_cmd UNUSED;
 {
     char_u		*buts;
     char_u		*p, *next;
diff -Naur vim73.orig/src/gui_gtk.c vim73/src/gui_gtk.c
--- vim73.orig/src/gui_gtk.c	2010-07-20 11:15:22.000000000 +0000
+++ vim73/src/gui_gtk.c	2011-05-17 09:36:14.481798035 +0000
@@ -1268,7 +1268,8 @@
 	       char_u	*message,   /* message text */
 	       char_u	*buttons,   /* names of buttons */
 	       int	def_but,    /* default button */
-	       char_u	*textfield) /* text for textfield or NULL */
+	       char_u	*textfield, /* text for textfield or NULL */
+	       int	ex_cmd UNUSED)
 {
     GtkWidget	*dialog;
     GtkWidget	*entry = NULL;
@@ -1287,6 +1288,9 @@
 	entry = gtk_entry_new();
 	gtk_widget_show(entry);
 
+	/* Make Enter work like pressing OK. */
+        gtk_entry_set_activates_default(GTK_ENTRY(entry), TRUE);
+
 	text = CONVERT_TO_UTF8(textfield);
 	gtk_entry_set_text(GTK_ENTRY(entry), (const char *)text);
 	CONVERT_TO_UTF8_FREE(text);
@@ -1795,7 +1799,6 @@
     char_u		*repl_text;
     gboolean		direction_down;
     SharedFindReplace	*sfr;
-    int			rc;
 
     flags = (int)(long)data;	    /* avoid a lint warning here */
 
@@ -1821,7 +1824,7 @@
 
     repl_text = CONVERT_FROM_UTF8(repl_text);
     find_text = CONVERT_FROM_UTF8(find_text);
-    rc = gui_do_findrepl(flags, find_text, repl_text, direction_down);
+    gui_do_findrepl(flags, find_text, repl_text, direction_down);
     CONVERT_FROM_UTF8_FREE(repl_text);
     CONVERT_FROM_UTF8_FREE(find_text);
 }
diff -Naur vim73.orig/src/gui_gtk_x11.c vim73/src/gui_gtk_x11.c
--- vim73.orig/src/gui_gtk_x11.c	2010-08-15 11:52:15.000000000 +0000
+++ vim73/src/gui_gtk_x11.c	2011-05-17 09:37:27.149732729 +0000
@@ -86,9 +86,10 @@
 
 #ifdef HAVE_X11_SUNKEYSYM_H
 # include <X11/Sunkeysym.h>
-static guint32 clipboard_event_time = CurrentTime;
 #endif
 
+static guint32 clipboard_event_time = CurrentTime;
+
 /*
  * Easy-to-use macro for multihead support.
  */
@@ -3093,7 +3094,7 @@
     gtk_drag_dest_set(gui.drawarea,
 		      GTK_DEST_DEFAULT_ALL,
 		      targets, n_targets,
-		      GDK_ACTION_COPY);
+		      GDK_ACTION_COPY | GDK_ACTION_MOVE);
 }
 
 /*
@@ -5419,7 +5420,7 @@
 	}
 
 #if defined(FEAT_NETBEANS_INTG)
-	/* Process the queued netbeans messages. */
+	/* Process any queued netbeans messages. */
 	netbeans_parse_messages();
 #endif
 
diff -Naur vim73.orig/src/gui_mac.c vim73/src/gui_mac.c
--- vim73.orig/src/gui_mac.c	2010-08-14 19:39:54.000000000 +0000
+++ vim73/src/gui_mac.c	2011-05-17 09:36:14.485797591 +0000
@@ -1480,7 +1480,7 @@
  *
  *  Returns the index inside the menu wher
  */
-    short /* Shoulde we return MenuItemIndex? */
+    short /* Should we return MenuItemIndex? */
 gui_mac_get_menu_item_index(vimmenu_T *pMenu)
 {
     short	index;
@@ -1823,7 +1823,7 @@
 	p.h += gui.scrollbar_width;
     if (gui.which_scrollbars[SBAR_RIGHT])
 	p.h += gui.scrollbar_width;
-    /* ideal height is as heigh as we can get */
+    /* ideal height is as high as we can get */
     p.v = 15 * 1024;
 
     thePart = IsWindowInStandardState(whichWindow, &p, &r)
@@ -4481,7 +4481,7 @@
 	 * event arrives.  No need to check for input_buf_full because we are
 	 * returning as soon as it contains a single char.
 	 */
-	/* TODO: reduce wtime accordinly???  */
+	/* TODO: reduce wtime accordingly???  */
 	if (wtime > -1)
 	    sleeppyTick = 60 * wtime / 1000;
 	else
@@ -5583,7 +5583,8 @@
     char_u	*message,
     char_u	*buttons,
     int		dfltbutton,
-    char_u	*textfield)
+    char_u	*textfield,
+    int		ex_cmd)
 {
     Handle	buttonDITL;
     Handle	iconDITL;
@@ -5723,13 +5724,13 @@
     iconDITL = GetResource('DITL', 131);
     switch (type)
     {
-	case VIM_GENERIC:  useIcon = kNoteIcon;
-	case VIM_ERROR:    useIcon = kStopIcon;
-	case VIM_WARNING:  useIcon = kCautionIcon;
-	case VIM_INFO:     useIcon = kNoteIcon;
-	case VIM_QUESTION: useIcon = kNoteIcon;
-	default:      useIcon = kStopIcon;
-    };
+	case VIM_GENERIC:
+	case VIM_INFO:
+	case VIM_QUESTION: useIcon = kNoteIcon; break;
+	case VIM_WARNING:  useIcon = kCautionIcon; break;
+	case VIM_ERROR:    useIcon = kStopIcon; break;
+	default:           useIcon = kStopIcon;
+    }
     AppendDITL(theDialog, iconDITL, overlayDITL);
     ReleaseResource(iconDITL);
     GetDialogItem(theDialog, iconItm.idx, &itemType, &itemHandle, &box);
@@ -5892,7 +5893,7 @@
 
     return itemHit;
 /*
- * Usefull thing which could be used
+ * Useful thing which could be used
  * SetDialogTimeout(): Auto click a button after timeout
  * SetDialogTracksCursor() : Get the I-beam cursor over input box
  * MoveDialogItem():	    Probably better than SetDialogItem
@@ -6100,7 +6101,7 @@
 #endif
 
 /*
- * Transfered from os_mac.c for MacOS X using os_unix.c prep work
+ * Transferred from os_mac.c for MacOS X using os_unix.c prep work
  */
 
     int
@@ -6543,7 +6544,7 @@
 static ControlRef dataBrowser = NULL;
 
 // when the tabline is hidden, vim doesn't call update_tabline(). When
-// the tabline is shown again, show_tabline() is called before upate_tabline(),
+// the tabline is shown again, show_tabline() is called before update_tabline(),
 // and because of this, the tab labels and vims internal tabs are out of sync
 // for a very short time. to prevent inconsistent state, we store the labels
 // of the tabs, not pointers to the tabs (which are invalid for a short time).
diff -Naur vim73.orig/src/gui_motif.c vim73/src/gui_motif.c
--- vim73.orig/src/gui_motif.c	2010-08-08 13:04:15.000000000 +0000
+++ vim73/src/gui_motif.c	2011-05-17 09:36:14.485797591 +0000
@@ -2549,13 +2549,14 @@
 #endif
 
     int
-gui_mch_dialog(type, title, message, button_names, dfltbutton, textfield)
+gui_mch_dialog(type, title, message, button_names, dfltbutton, textfield, ex_cmd)
     int		type UNUSED;
     char_u	*title;
     char_u	*message;
     char_u	*button_names;
     int		dfltbutton;
     char_u	*textfield;		/* buffer of size IOSIZE */
+    int		ex_cmd UNUSED;
 {
     char_u		*buts;
     char_u		*p, *next;
diff -Naur vim73.orig/src/gui_photon.c vim73/src/gui_photon.c
--- vim73.orig/src/gui_photon.c	2010-05-15 11:04:08.000000000 +0000
+++ vim73/src/gui_photon.c	2011-05-17 09:36:14.485797591 +0000
@@ -1502,7 +1502,8 @@
 	char_u	*message,
 	char_u	*buttons,
 	int	default_button,
-	char_u	*textfield)
+	char_u	*textfield,
+	int	ex_cmd)
 {
     char_u	*str;
     char_u	**button_array;
diff -Naur vim73.orig/src/gui_riscos.c vim73/src/gui_riscos.c
--- vim73.orig/src/gui_riscos.c	2010-05-15 11:04:09.000000000 +0000
+++ vim73/src/gui_riscos.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,3558 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-
-#include "vim.h"
-#include <string.h>
-
-/*
- * gui_riscos.c
- *
- * Thomas Leonard <tal197@ecs.soton.ac.uk>
- * Updated by Andy Wingate <andy@sparse.net>
- */
-
-extern int time_of_last_poll;
-
-int task_handle = 0;		/* Zero means we are not yet a Wimp task */
-int child_handle = 0;		/* Task handle of our child process (zero if none). */
-int *wimp_menu = (int *) -1;	/* Pointer to a Wimp menu structure (or -1) */
-int save_window = -1;		/* Save As window handle */
-
-int *redraw_block = NULL;	/* NULL means not in a redraw loop. */
-int ro_return_early = FALSE;	/* Break out of gui_mch_wait_for_chars() */
-
-int leaf_ref = 0;		/* Wimp message number - send via Wimp$Scrap */
-char_u *leaf_name = NULL;	/* Leaf name from DataSave */
-
-int default_columns = 120;	/* These values are used if the --rows and --columns */
-int default_rows = 32;		/* options aren't used on startup. */
-
-#define DRAG_FALSE	    0
-#define DRAG_SELECTION	    1
-#define DRAG_RESIZE_WINDOW  2
-int ro_dragging = DRAG_FALSE;
-int drag_button;
-int drag_modifiers;
-int drag_x_offset;
-int drag_y_offset;
-
-int nested_wimp = FALSE;	/* Bool - can we use the new wimp? */
-
-int changed_mode = FALSE;
-int x_eigen_factor;
-int y_eigen_factor;
-
-/* If ro_current_font is non-zero then use the outline font with that handle,
- * otherwise, if zap_redraw is TRUE then use ZapRedraw, otherwise use the
- * system font.
- *
- * If zap_redraw is TRUE then zap_file[] contains valid Zap font file
- * pointers (or NULLs).
- */
-int ro_current_font = 0;	/* 0 is system font, or ZapRedraw */
-int font_x_offset   = 0;	/* Where to position each char in its box */
-int font_y_offset   = 0;
-
-int zap_redraw	    = FALSE;
-int double_height   = FALSE;	/* Plot each line twice? */
-
-#define grgb(r,g,b) ((b<<16) + (g<<8) + (r))
-#define UNUSED_COLOUR (gui.back_pixel)
-
-#define RO_LOAD_CLIPBOARD -2	/* Internal handle for DataSave message. */
-
-/* Changes by John Kortink, 22-23 July 1998
- *
- * Stuff to make redraw a lot faster. Almost all of it is right here below,
- * elsewhere changes are marked with 'JK230798'. Apart from a small change in
- * 'gui.c' all changes are limited to this file, 'gui_riscos.c'. The change in
- * 'gui.c' is to make Vim stop being 'smart' not redrawing characters that are
- * 'already there' (i.e. from the previous line, by coincidence). This caused a
- * lot more calls to the redraw code, which we want to avoid because a few nice
- * big strings at a time is a lot faster than a truckload of small ones. ('Dear
- * Bram ...').
- */
-
-/* The ZapRedraw structure */
-
-static struct
-{
-    int		r_flags;
-    int		r_minx;
-    int		r_miny;
-    int		r_maxx;
-    int		r_maxy;
-    int		r_screen;
-    int		r_bpl;
-    int		r_bpp;
-    int		r_charw;
-    int		r_charh;
-    char	*r_caddr;
-    int		r_cbpl;
-    int		r_cbpc;
-    int		r_linesp;
-    int		r_data;
-    int		r_scrollx;
-    int		r_scrolly;
-    int		*r_palette;
-    int		r_for;
-    int		r_bac;
-    char	*r_workarea;
-    int		r_magx;
-    int		r_magy;
-    int		r_xsize;
-    int		r_ysize;
-    int		r_mode;
-}
-zap_redraw_block;
-
-/* Other globals */
-
-static int	zap_redraw_initialised = FALSE;
-static int	zap_redraw_update_colours;
-static int	zap_redraw_colours[2];
-static int	zap_redraw_palette[16];
-
-/* Holds the current Zap font file(s).
- * The font is recreated from this block on a mode change.
- * When using zap, element ZAP_NORMAL is always valid, but
- * the others can be NULL.
- */
-
-#define ZAP_NORMAL  0
-#define ZAP_BOLD    1
-#define ZAP_ITALIC  2
-#define ZAP_BITALIC 3
-#define ZAP_STYLES  4
-
-/* Zap font file format data */
-static char	*zap_file[ZAP_STYLES] = {NULL, NULL, NULL, NULL};
-
-/* r_caddr format for current mode */
-static char	*zap_caddr[ZAP_STYLES] = {NULL, NULL, NULL, NULL};
-
-static void ro_remove_menu(int *menu);
-
-/*
- * Initialise all the ZapRedraw stuff.
- * Call this when changing font and after each mode change.
- * zap_redraw_bitmap must contain a valid Zap font file (possibly
- * created from the system font).
- *
- * Return FAIL to revert to system font (if we can't use ZapRedraw).
- */
-    int
-ro_zap_redraw_initialise()
-{
-    int	    bytes_per_bitmap_char;
-    int	    first, last;
-    int	    i;
-
-    /* Can't have initialisers for struct members :-(, ok, this way then ... */
-    if (!zap_redraw_initialised)
-    {
-	zap_redraw_block.r_workarea = NULL;
-	zap_redraw_initialised = TRUE;
-    }
-
-    /* We redraw in DSA mode */
-    zap_redraw_block.r_flags = 0x0;
-
-    /* Let ZapRedraw get the screen address for us */
-    zap_redraw_block.r_screen = 0;
-
-    /* Read the font width and height from the font file header.
-     * Assume that all styles are the same size.
-     * ZAP_NORMAL is always present.
-     */
-    zap_redraw_block.r_charw = ((int *) zap_file[ZAP_NORMAL])[2];
-    zap_redraw_block.r_charh = ((int *) zap_file[ZAP_NORMAL])[3];
-
-    /* We have no linespacing */
-    zap_redraw_block.r_linesp = 0;
-
-    /* Fix foreground = colour 1 */
-    zap_redraw_block.r_for = 1;
-
-    /* Fix background = colour 0 */
-    zap_redraw_block.r_bac = 0;
-
-    /* Colour mask buffer */
-    zap_redraw_block.r_palette = zap_redraw_palette;
-
-    /* Allocate local workspace (for the few calls following here) */
-    if (zap_redraw_block.r_workarea != NULL)
-	free(zap_redraw_block.r_workarea);
-    zap_redraw_block.r_workarea = (char*) malloc(128);
-    if (!zap_redraw_block.r_workarea)
-	return FAIL;	/* Out of memory */
-
-    /* Fill in VDU variables */
-    if (xswi(ZapRedraw_ReadVduVars, 0, &zap_redraw_block) & v_flag)
-	return FAIL;	    /* Can't find ZapRedraw module - use VDU instead */
-
-    /* Determine cbpl and cbpc */
-    swi(ZapRedraw_CachedCharSize, zap_redraw_block.r_bpp, 0,
-	zap_redraw_block.r_charw, zap_redraw_block.r_charh);
-    zap_redraw_block.r_cbpl = r2;
-    zap_redraw_block.r_cbpc = r3;
-
-    /* Allocate general workspace (for the calls outside) */
-    if (zap_redraw_block.r_workarea != NULL)
-	free(zap_redraw_block.r_workarea);
-    zap_redraw_block.r_workarea = (char*) malloc(128 + zap_redraw_block.r_cbpl);
-    if (!zap_redraw_block.r_workarea)
-	return FAIL;	/* Out of memory */
-
-    /* Now convert the 1 bpp character data ready for the current mode */
-
-    bytes_per_bitmap_char = (zap_redraw_block.r_charw * zap_redraw_block.r_charh + 7) / 8;
-
-    /* Convert the fonts from 1bpp to a format suitable for the
-     * current mode.
-     */
-    for (i = 0; i < ZAP_STYLES; i++)
-    {
-	first = ((int *) zap_file[i])[4];
-	last  = ((int *) zap_file[i])[5];
-
-	if (last > 255)
-	    last = 255;	/* Don't convert cursors (overwrites memory!) */
-
-	/* Allocate the font cache */
-	vim_free(zap_caddr[i]);
-	if (zap_file[i])
-	    zap_caddr[i] = (char*) malloc(zap_redraw_block.r_cbpc * 256);
-	else
-	    zap_caddr[i] = NULL;    /* No file for this style */
-
-	if (zap_caddr[i])
-	{
-	    zap_redraw_block.r_caddr = zap_caddr[i];
-
-	    swi(ZapRedraw_ConvertBitmap, 0, &zap_redraw_block,
-		    first, last,		/* Range of characters to convert */
-		    zap_file[i] + 0x20	/* Addr of first char provided by font */
-		    - first * bytes_per_bitmap_char);
-	}
-    }
-
-    if (!zap_caddr[ZAP_NORMAL])
-    {
-	zap_redraw = FALSE;	/* Out of memory */
-	return FAIL;
-    }
-
-    /* Next time we need them, we have to update the colour masks */
-    zap_redraw_update_colours = TRUE;
-
-    return OK;
-}
-
-/*
- * Redraw a string at OS coordinates <x,y> (top-left, x inclusive, y exclusive).
- * Graphics clip window is window[0..3] as in R1+28..40 of Wimp_RedrawWindow.
- * Returns (possibly modified) flags.
- */
-    int
-ro_zap_redraw_draw_string(x, y, string, length, flags, clip)
-    int	    x;
-    int	    y;
-    char    *string;
-    int	    length;
-    int	    flags;	/* DRAW_TRANSP, DRAW_BOLD, DRAW_UNDERL, DRAW_ITALIC */
-    int	    *clip;
-{
-    char redraw_data[1024];
-    int clip_minx;
-    int clip_miny;
-    int clip_maxx;
-    int clip_maxy;
-    int os_xshift = zap_redraw_block.r_magx;
-    int os_yshift = zap_redraw_block.r_magy;
-
-    if (flags & DRAW_TRANSP)
-	return flags;	/* We don't do transparent plotting yet. */
-
-    if (flags & DRAW_BOLD)
-    {
-	if (flags & DRAW_ITALIC && zap_caddr[ZAP_BITALIC])
-	    zap_redraw_block.r_caddr = zap_caddr[ZAP_BITALIC];
-	else
-	    zap_redraw_block.r_caddr = zap_caddr[ZAP_BOLD];
-    }
-    else
-    {
-	if (flags & DRAW_ITALIC)
-	    zap_redraw_block.r_caddr = zap_caddr[ZAP_ITALIC];
-	else
-	    zap_redraw_block.r_caddr = zap_caddr[ZAP_NORMAL];
-    }
-    if (!zap_redraw_block.r_caddr)
-    {
-	zap_redraw_block.r_caddr = zap_caddr[ZAP_NORMAL];
-	flags |= DRAW_UNDERL;	    /* Style missing - we can always underline */
-    }
-
-    /* Set the vertical scaling flag */
-    if (double_height)
-	zap_redraw_block.r_flags = 1 << 1;
-    else
-	zap_redraw_block.r_flags = 0;
-
-    /* Update the colour masks (if needed) */
-    if (zap_redraw_update_colours)
-    {
-	swi(ZapRedraw_CreatePalette, 2,
-		&zap_redraw_block,
-		zap_redraw_colours,
-		zap_redraw_block.r_palette, 2);
-	zap_redraw_update_colours = FALSE;
-    }
-
-    /* Target rectangle in ZapRedraw rectangle coordinates (pixels, Y-min/max reversed !!!) */
-    zap_redraw_block.r_minx = x >> os_xshift;					/* inclusive */
-    zap_redraw_block.r_miny = zap_redraw_block.r_ysize - (y >> os_yshift);	/* inclusive */
-    zap_redraw_block.r_maxx = (x + length * gui.char_width) >> os_xshift;	/* exclusive */
-    zap_redraw_block.r_maxy = zap_redraw_block.r_ysize - ((y - gui.char_height) >> os_yshift);
-										/* exclusive */
-
-    /* Clip rectangle in ZapRedraw rectangle coordinates (pixels, Y-min/max reversed !!!) */
-    clip_minx = clip[0] >> os_xshift;					/* inclusive */
-    clip_miny = zap_redraw_block.r_ysize - (clip[3] >> os_yshift);	/* inclusive */
-    clip_maxx = clip[2] >> os_xshift;					/* exclusive */
-    clip_maxy = zap_redraw_block.r_ysize - (clip[1] >> os_yshift);	/* exclusive */
-
-    /* Clip target rectangle against the current graphics window */
-    if (zap_redraw_block.r_minx < clip_minx)
-    {
-	zap_redraw_block.r_scrollx = clip_minx - zap_redraw_block.r_minx;
-	zap_redraw_block.r_minx = clip_minx;
-    }
-    else
-	zap_redraw_block.r_scrollx = 0;
-    if (zap_redraw_block.r_miny < clip_miny)
-    {
-	zap_redraw_block.r_scrolly = clip_miny - zap_redraw_block.r_miny;
-	zap_redraw_block.r_miny = clip_miny;
-    }
-    else
-	zap_redraw_block.r_scrolly = 0;
-    if (zap_redraw_block.r_maxx > clip_maxx)
-	zap_redraw_block.r_maxx = clip_maxx;
-    if (zap_redraw_block.r_maxy > clip_maxy)
-	zap_redraw_block.r_maxy = clip_maxy;
-
-    /* Fill in the character data structure */
-    if (length > (sizeof(redraw_data) - 2 * 4 - 2))
-	length = sizeof(redraw_data) - 2 * 4 - 2;
-    ((int*) redraw_data)[0] = 2 * 4;
-    ((int*) redraw_data)[1] = 0;
-    strncpy(redraw_data + 2 * 4, string, length);
-    redraw_data[2 * 4 + length + 0] = '\0';
-    redraw_data[2 * 4 + length + 1] = '\x2';
-    zap_redraw_block.r_data = (int) redraw_data;
-
-    /* Perform the draw */
-    swi(ZapRedraw_RedrawArea, 0, &zap_redraw_block);
-
-    return flags;
-}
-
-/*
- * Okay that was it from me, back to Thomas ...
- */
-
-/*
- * Parse the GUI related command-line arguments.  Any arguments used are
- * deleted from argv, and *argc is decremented accordingly.  This is called
- * when vim is started, whether or not the GUI has been started.
- */
-    void
-gui_mch_prepare(int *argc, char **argv)
-{
-    int	    arg = 1;
-
-    while (arg < *argc - 1)
-    {
-	if (strcmp(argv[arg], "--rows") == 0 || strcmp(argv[arg], "--columns") == 0)
-	{
-	    int	    value;
-
-	    value = atoi(argv[arg + 1]);
-
-	    if (argv[arg][2] == 'r')
-		default_rows = value;
-	    else
-		default_columns = value;
-
-	    /* Delete argument from argv[]. (hope this is read/write!) */
-
-	    *argc -= 2;
-	    if (*argc > arg)
-	    mch_memmove(&argv[arg], &argv[arg + 2], (*argc - arg)
-		    * sizeof(char *));
-	}
-	else
-	    arg++;
-    }
-}
-
-/* Fatal error on initialisation - report it and die. */
-    void
-ro_die(error)
-    char_u *error;	/* RISC OS error block */
-{
-    swi(Wimp_ReportError, error, 5, "GVim");
-    exit(EXIT_FAILURE);
-}
-
-/* Find the sizes of the window tools:
- *
- * Create a test window.
- * Find inner and outer sizes.
- * Find the difference.
- * Delete window.
- *
- * While we're here, find the eigen values too.
- */
-    void
-ro_measure_tools()
-{
-    int block[10];
-    int vdu[] = { 4, 5, -1};
-    int test_window[] =
-	{
-	    -100, -100,		/* Visible area : min X,Y */
-	    -50, -50,		/*		  max X,Y */
-	    0,   0,		/* Scroll offsets */
-	    -1,			/* Window in front */
-	    0xd0800150,		/* Window flags */
-	    0xff070207,		/* Colours */
-	    0x000c0103,		/* More colours */
-	    0, -0x4000,		/* Workarea extent */
-	    0x4000, 0,		/* max X,Y */
-	    0x00000000,		/* No title */
-	    0 << 12,		/* No workarea button type */
-	    1,			/* Wimp sprite area */
-	    0x00010001,		/* Minimum width, height */
-	    0, 0, 0,		/* Title data (none) */
-	    0			/* No icons */
-	};
-    int inner_max_x, inner_min_y;
-
-    swi(Wimp_CreateWindow, 0, test_window);
-
-    block[0] = r0;
-    /* Open the window (and read state).
-     * GetWindowOutline needs it too if the wimp isn't nested.
-     */
-    swi(Wimp_OpenWindow, 0, block);
-    inner_max_x = block[3];
-    inner_min_y = block[2];
-
-    swi(Wimp_GetWindowOutline, 0, block);
-
-    gui.scrollbar_width = block[3] - inner_max_x;
-    gui.scrollbar_height = inner_min_y - block[2];
-
-    swi(Wimp_DeleteWindow, 0, block);
-
-    /* Read the size of one pixel. */
-    swi(OS_ReadVduVariables, vdu, vdu);
-    x_eigen_factor = vdu[0];
-    y_eigen_factor = vdu[1];
-}
-
-/* Load a template from the current templates file.
- * Create the window and return its handle.
- */
-    int
-ro_load_template(str_name, title, title_size)
-    char_u  *str_name;      /* Identifier of window in file (max 12 chars)   */
-    char_u  **title;	    /* If not NULL then return pointer to title here */
-    int     *title_size;    /* If not NULL then return the title length here */
-{
-    int     *window;
-    char    *data;
-    int     name[4];
-
-    strcpy( (char *) name, str_name);
-
-    /* Find how big we must make the buffers */
-
-    if (xswi(Wimp_LoadTemplate, 0, 0, 0, 0, -1, name, 0) & v_flag)
-	ro_die( (char *) r0);
-
-    window = malloc(r1);	/* Don't print text messages from alloc() */
-    data = malloc(r2);
-    if (window == NULL || data == NULL)
-	ro_die("\0\0\0\0Out of memory - Can't load templates");
-
-    /* Load the template into the buffers */
-
-    swi(Wimp_LoadTemplate, 0,
-				window,		/* Temp block */
-				data,		/* Icon data */
-				data + r2 + 1,	/* End of icon data */
-				-1,		/* No fonts */
-				name, 0);	/* First match */
-    if (r6 == 0)
-	ro_die("\0\0\0\0Can't find window in Templates file");
-
-    /* Create the window */
-
-    if (xswi(Wimp_CreateWindow, 0, window) & v_flag)
-	ro_die( (char *) r0);
-
-    if (title)
-	*title = (char_u *) window[18];
-    if (title_size)
-	*title_size = window[20];
-
-    free(window);	/* Free temp block */
-    return r0;		/* Return the window handle */
-}
-
-/*
- * Check if the GUI can be started.  Called before gvimrc is sourced.
- * Return OK or FAIL.
- */
-    int
-gui_mch_init_check()
-{
-    return OK;		/* TODO: GUI can always be started? */
-}
-
-/*
- * Initialise the RISC OS GUI.
- * Create all the windows.
- * Returns OK for success, FAIL when the GUI can't be started.
- */
-    int
-gui_mch_init()
-{
-    int     messages[] = {
-	    1, 2, 3, 4,	/* DataSave, DataSaveAck, DataLoad, DataLoadAck */
-	    8,		/* PreQuit */
-	    0xf,	/* ClaimEntity (for clipboard) */
-	    0x10,	/* DataRequest (for clipboard) */
-	    0x400c1,	/* Mode change */
-	    0x400c3,	/* TaskCloseDown */
-	    0x400c9,	/* MenusDeleted */
-	    0x808c1,	/* TW_Output */
-	    0x808c2,    /* TW_Ego */
-	    0x808c3,	/* TW_Morio */
-	    0x808c4,	/* TW_Morite */
-	    0};		/* End-of-list. */
-
-
-    /* There may have been some errors reported in the
-     * command window before we get here. Wait if so.
-     */
-    swi(Wimp_ReadSysInfo, 3);
-    if (r0 == 0)
-	swi(Wimp_CommandWindow, 0);	/* Window opened - close with prompt */
-
-    if (xswi(Wimp_Initialise, 310, 0x4b534154, "GVim", messages) & v_flag)
-	return FAIL;
-    nested_wimp = r0 >= 397;
-    task_handle = r1;
-
-    /* Load the templates. */
-
-    if (xswi(Wimp_OpenTemplate, 0, "Vim:Templates") & v_flag)
-	ro_die( (char *) r0);
-
-    gui.window_handle = ro_load_template("editor",
-	    &gui.window_title,
-	    &gui.window_title_size);
-
-    save_window = ro_load_template("save", NULL, NULL);
-
-    swi(Wimp_CloseTemplate);
-
-    /* Set default foreground and background colours. */
-
-    gui.norm_pixel = gui.def_norm_pixel;
-    gui.back_pixel = gui.def_back_pixel;
-
-    /* Get the colours from the "Normal" and "Menu" group (set in syntax.c or
-     * in a vimrc file) */
-
-    set_normal_colors();
-
-    /*
-     * Check that none of the colors are the same as the background color
-     */
-
-    gui_check_colors();
-
-    /* Get the colours for the highlight groups (gui_check_colors() might have
-     * changed them) */
-
-    highlight_gui_started();		/* re-init colours and fonts */
-
-    /* Set geometry based on values read on initialisation. */
-
-    gui.num_cols = Columns = default_columns;
-    gui.num_rows = Rows    = default_rows;
-
-    /* Get some information about our environment. */
-
-    ro_measure_tools();
-
-    return OK;
-}
-
-/*
- * Called when the foreground or background colour has been changed.
- */
-    void
-gui_mch_new_colors()
-{
-}
-
-/*
- * Open the GUI window which was created by a call to gui_mch_init().
- */
-    int
-gui_mch_open(void)
-{
-    int block[10];
-
-    block[0] = gui.window_handle;
-    swi(Wimp_GetWindowState, 0, block);
-    block[7] = -1;		    /* Open at the top of the stack */
-    swi(Wimp_OpenWindow, 0, block);
-
-    /* Give the new window the input focus */
-    swi(Wimp_SetCaretPosition, gui.window_handle, -1, 0, 0, -1, -1);
-
-    if (gui_win_x != -1 && gui_win_y != -1)
-	gui_mch_set_winpos(gui_win_x, gui_win_y);
-
-    return OK;
-}
-
-    void
-gui_mch_exit(int rc)
-{
-    int	    block[64];
-
-    /* Close window. Stops us from getting troublesome events
-     * if we take a while to die.
-     */
-    block[0] = gui.window_handle;
-    swi(Wimp_CloseWindow, 0, block);
-
-    if (child_handle)
-    {
-	/* We still have a sub-task running - kill it */
-	block[0] = 20;
-	block[3] = 0;
-	block[4] = 0;	    /* Quit */
-	if ((xswi(Wimp_SendMessage, 17, block, child_handle) & v_flag) == 0)
-	{
-	    /* Idle until child dies. */
-	    while (child_handle)
-	    {
-		process_event(wimp_poll(1, block), block);
-	    }
-	}
-    }
-
-    exit(rc);
-}
-
-/*
- * Get the position of the top left corner of the window.
- */
-    int
-gui_mch_get_winpos(int *x, int *y)
-{
-    /* TODO */
-    return FAIL;
-}
-
-/*
- * Set the position of the top left corner of the window to the given
- * coordinates.
- */
-    void
-gui_mch_set_winpos(int x, int y)
-{
-    /* TODO */
-}
-
-    void
-gui_mch_set_shellsize(width, height, min_width, min_height, base_width, base_height, direction)
-    int width;		/* In OS units */
-    int height;
-    int min_width;	/* Smallest permissible window size (ignored) */
-    int min_height;
-    int base_width;	/* Space for scroll bars, etc */
-    int base_height;
-    int direction;
-{
-    int s_width, s_height;
-    int block[] = {
-	gui.window_handle,
-	0,
-	-height + 1,
-	width,
-	1};
-
-    gui_mch_get_screen_dimensions(&s_width, &s_height);
-    s_width -= base_width;
-    s_height -= base_height;		    /* Underestimate - ignores titlebar */
-
-    swi(Wimp_GetWindowState, 0, block);
-    block[3]  = block[1] + width;
-    block[2]  = block[4] - height;
-    if (block[3] > s_width)
-    {
-	block[3] = s_width;
-	block[1] = block[3] - width;
-    }
-    if (block[2] < gui.scrollbar_height)
-    {
-	block[2] = gui.scrollbar_height;
-	block[4] = block[2] + height;
-    }
-    swi(Wimp_OpenWindow, 0, block);
-    swi(Wimp_ForceRedraw, gui.window_handle, 0, -height, width, 0);
-}
-
-    void
-gui_mch_get_screen_dimensions(int *screen_w, int *screen_h)
-{
-    int block[] = {4, 5, 11, 12, -1};
-
-    swi(OS_ReadVduVariables, block, block);
-    *screen_w = (block[2] + 1) << block[0];
-    *screen_h = (block[3] + 1) << block[1];
-}
-
-/* Take a font name with options and return a font handle, or
- * zero for failure.
- * Replace extension with 'Bold' or 'Italic' depending on modifiers.
- */
-    int
-ro_get_font(fullname, weight)
-    char_u	*fullname;
-    int		weight;		/* Initial weights:
-				 * BIT	    MEANING
-				 * 0	    bold
-				 * 1	    italic
-				 */
-{
-    char_u	*arg;
-    char_u	font[41];
-    int		width = -1;
-    int		height = -1;
-    int		name_len;
-    int		i;
-    char_u	c;
-
-    for (i = 0; i < 39;)
-    {
-	c = fullname[i];
-	if (c == ':' || c == NUL || c == '.')
-	    break;
-	font[i++] = c;
-    }
-
-    /* find the first modifier, NULL if none */
-    arg = strchr(fullname + i, ':');
-
-    while (arg)
-    {
-	switch (*++arg)
-	{
-	    case 'h':
-		height = strtol(arg + 1, (char **) &arg, 10);
-		break;
-	    case 'w':
-		width = strtol(arg + 1, (char **) &arg, 10);
-		break;
-	    case 'b':
-		weight |= 1;
-		break;
-	    case 'i':
-		weight |= 2;
-		break;
-	    default:
-		return 0;
-	}
-	arg = strchr(arg, ':');
-    }
-
-    if ((weight & 1) && i < 35)
-    {
-	/* Bold goes instead of given suffix */
-	strncpy(font + i, ".Bold", 5);
-	i += 5;
-    }
-    else
-    {
-	/* Copy rest of name unless we are using Bold */
-	while (i < 39)
-	{
-	    c = fullname[i];
-	    if (c == ':' || c == NUL)
-		break;
-	    font[i++] = c;
-	}
-    }
-    if ((weight & 2) && i < 32)
-    {
-	strncpy(font + i, ".Oblique", 8);
-	i += 8;
-    }
-
-    font[i] = 0;
-
-    if (height < 1 && width < 1)
-	height = width = 10;	/* Default to 10pt */
-    else if (height < 1)
-	height = width;
-    else if (width < 1)
-	width = height;
-
-    if (xswi(Font_FindFont, 0, font, width << 4, height << 4, 0, 0) & v_flag)
-	return NOFONT;		/* Can't find font */
-
-    return r0;
-}
-
-/* Load a file into allocated memory and check it is valid.
- * Return a pointer to the allocated block on success.
- */
-    char    *
-zap_load_file(name, style)
-    char_u  *name;	    /* Name of directory containing styles */
-    char_u  *style;	    /* Name of style within directory */
-{
-    char_u  fname[256];
-    char_u  *file;
-
-    if (strlen(name) + strlen(style) > 254)
-	return NULL;	    /* Names too long */
-
-    sprintf(fname, "%s.%s", name, style);
-
-    /* Load the named font in 1bpp format. */
-    if (xswi(OS_File, 13, fname, 0, 0, "VimFonts:") & v_flag || r0 != 1)
-	return NULL;	    /* Error reading file info, or not a file */
-
-    /* Allocate enough memory to load the whole file */
-    file = (char *) alloc(r4);
-    if (!file)
-	return NULL;	/* Out of memory */
-
-    if (xswi(OS_File, 12, fname, file, 0, "VimFonts:") & v_flag)
-	return NULL;	/* Unable to load file */
-
-    if (strncmp(file, "ZapFont\015", 8) == 0)
-	return file;	/* Loaded OK! */
-
-    vim_free(file);
-    return NULL;	/* Not a valid font file */
-}
-
-/* Load and convert the named font.
- * If name is NULL or a null string then convert the system font.
- * Return OK on success; FAIL and we revert to using the VDU drivers.
- *
- * 'name' is the name of a directory.
- * Tries to load 'name.0', 'name.B', 'name.I' and 'name.IB'.
- */
-    int
-zap_load_font(name)
-    char_u  *name;
-{
-    int	    i;
-
-    /* Free the existing font files, if any */
-    for (i = 0; i < ZAP_STYLES; i++)
-    {
-	vim_free(zap_file[i]);
-	zap_file[i] = NULL;
-    }
-
-    if (name && *name == '!')
-    {
-	name++;
-	double_height = TRUE;
-    }
-    else
-	double_height = FALSE;
-
-    if (name && *name)
-    {
-	zap_file[ZAP_NORMAL]	= zap_load_file(name, "0");
-	if (!zap_file[ZAP_NORMAL])
-	    return FAIL;	/* Can't load the 'normal' style - error */
-
-	zap_file[ZAP_BOLD]	= zap_load_file(name, "B");
-	zap_file[ZAP_ITALIC]	= zap_load_file(name, "I");
-	zap_file[ZAP_BITALIC]	= zap_load_file(name, "IB");
-    }
-    else
-    {
-	int	*header;
-	char	workarea[16];
-	char	*old_wa;
-
-	/* Allocate memory for system font (8 x 8 x 256 bits, plus header) */
-	header = (int *) alloc(0x20 + 8 * 256);
-	if (header == NULL)
-	    return FAIL;
-	zap_file[ZAP_NORMAL] = (char *) header;
-
-	/* Store details about the system font */
-	header[2] = 8;	    /* Width */
-	header[3] = 8;	    /* Height */
-	header[4] = 0;	    /* First char */
-	header[5] = 255;    /* Last char */
-	header[6] = header[7] = 0;  /* Reserved */
-
-	/* Get system font bitmap */
-	old_wa = zap_redraw_block.r_workarea;
-	zap_redraw_block.r_workarea = workarea;
-	swi(ZapRedraw_ReadSystemChars, zap_file[ZAP_NORMAL] + 0x20, &zap_redraw_block);
-	zap_redraw_block.r_workarea = old_wa;
-    }
-
-    return ro_zap_redraw_initialise();
-}
-
-/*
- * Initialise vim to use the font with the given name.
- * Return FAIL if the font could not be loaded, OK otherwise.
- */
-    int
-gui_mch_init_font(char_u *font_name, int fontset)
-{
-    int	    new_handle	= 0;	    /* Use the system font by default */
-
-    if (font_name[0] == '!')
-    {
-	/* Select a ZapRedraw font */
-	if (zap_load_font(font_name + 1))
-	    zap_redraw = TRUE;
-	else
-	{
-	    EMSG2(_("E610: Can't load Zap font '%s'"), font_name);
-	    font_name = "System";   /* Error - use system font */
-	    zap_redraw = FALSE;
-	}
-    }
-    else
-    {
-	zap_redraw = FALSE;
-
-	if (font_name)
-	{
-	    /* Extract any extra details about the font */
-	    new_handle = ro_get_font(font_name, 0);
-	    if (!new_handle)
-		return FAIL;
-	}
-	else
-	    font_name = "System";
-    }
-
-    /* Free the previous font, if any */
-    gui_mch_free_font(gui.norm_font);
-    gui.norm_font = new_handle;
-    gui.char_ascent = 0;
-
-    if (new_handle)
-    {
-	/* Read details about the chosen font */
-	swi(Font_ReadInfo, new_handle);
-
-	gui.char_width	= r3 - r1;
-	gui.char_height = r4 - r2;
-
-	font_x_offset = -r1;	/* Where to position each char in its box */
-	font_y_offset = -r4;
-
-	/* Try to load other fonts for bold, italic, and bold-italic */
-	gui_mch_free_font(gui.bold_font);
-	gui.bold_font = ro_get_font(font_name, 1);
-	gui_mch_free_font(gui.ital_font);
-	gui.ital_font = ro_get_font(font_name, 2);
-	gui_mch_free_font(gui.boldital_font);
-	gui.boldital_font = ro_get_font(font_name, 3);
-    }
-    else
-    {
-	/* Use the system font or ZapRedraw. */
-	if (zap_redraw)
-	{
-	    gui.char_width	= zap_redraw_block.r_charw << zap_redraw_block.r_magx;
-	    gui.char_height	= zap_redraw_block.r_charh << zap_redraw_block.r_magy;
-	    if (double_height)
-		gui.char_height <<= 1;
-	}
-	else
-	{
-	    gui.char_width	= 16;
-	    gui.char_height	= 32;
-	}
-
-	gui_mch_free_font(gui.bold_font);
-	gui.bold_font = 0;
-	gui_mch_free_font(gui.ital_font);
-	gui.ital_font = 0;
-	gui_mch_free_font(gui.boldital_font);
-	gui.boldital_font = 0;
-    }
-    hl_set_font_name(font_name);
-
-    must_redraw = CLEAR;
-    return OK;
-}
-
-/*
- * Adjust gui.char_height (after 'linespace' was changed).
- */
-    int
-gui_mch_adjust_charheight()
-{
-    return FAIL;
-}
-
-/*
- * Get a font structure for highlighting.
- */
-    GuiFont
-gui_mch_get_font(name, giveErrorIfMissing)
-    char_u	*name;
-    int		giveErrorIfMissing;
-{
-    int		handle;
-
-    if (!name)
-	return NOFONT;		/* System font if no name */
-
-    handle = ro_get_font(name, 0);
-    if (!handle)
-    {
-	if (giveErrorIfMissing)
-	    EMSG2(_("E611: Can't use font %s"), name);
-	return NOFONT;
-    }
-
-    return handle;
-}
-
-#if defined(FEAT_EVAL) || defined(PROTO)
-/*
- * Return the name of font "font" in allocated memory.
- * Don't know how to get the actual name, thus use the provided name.
- */
-    char_u *
-gui_mch_get_fontname(font, name)
-    GuiFont font;
-    char_u  *name;
-{
-    if (name == NULL)
-	return NULL;
-    return vim_strsave(name);
-}
-#endif
-
-/*
- * Set the current text font.
- */
-    void
-gui_mch_set_font(GuiFont font)
-{
-    ro_current_font = font;
-
-    if (font)
-    {
-	/* Not the system font or ZapRedraw font - select it */
-	swi(Font_SetFont, font);
-    }
-}
-
-/*
- * If a font is not going to be used, free its structure.
- */
-    void
-gui_mch_free_font(GuiFont font)
-{
-    if (font)
-	swi(Font_LoseFont, font);
-}
-
-/*
- * Return the Pixel value (colour) for the given colour name.
- * Return INVALCOLOR for error.
- * NB: I've changed Green for now, since it looked really sick
- */
-    guicolor_T
-gui_mch_get_color(char_u *name)
-{
-    int		i;
-    struct colour
-    {
-	char_u		*name;
-	guicolor_T	value;
-    } colours[] =
-    {
-	{ "Red",		grgb(255,	0,	0)	},
-	{ "LightRed",		grgb(255,	0,	0)	},
-	{ "DarkRed",		grgb(139,	0,	0)	},
-
-	{ "Green",		grgb(50,	200,	50)	},
-	{ "LightGreen",		grgb(144,	238,	144)	},
-	{ "DarkGreen",		grgb(0,		100,	0)	},
-	{ "SeaGreen",		grgb(46,	139,	87)	},
-
-	{ "Blue",		grgb(0,		0,	255)	},
-	{ "LightBlue",		grgb(173,	216,	230)	},
-	{ "DarkBlue",		grgb(0,		0,	139)	},
-	{ "SlateBlue",		grgb(160,	90,	205)	},
-
-	{ "Cyan",		grgb(0,		255,	255)	},
-	{ "LightCyan",		grgb(224,	255,	255)	},
-	{ "DarkCyan",		grgb(0,		139,	139)	},
-
-	{ "Magenta",		grgb(255,	0,	255)	},
-	{ "LightMagenta",	grgb(255,	224,	255)	},
-	{ "DarkMagenta",	grgb(139,	0,	139)	},
-
-	{ "Yellow",		grgb(255,	255,	0)	},
-	{ "LightYellow",	grgb(255,	255,	224)	},
-	{ "DarkYellow",		grgb(139,	139,	0)	},
-	{ "Brown",		grgb(165,	42,	42)	},
-
-	{ "Gray",		grgb(190,	190,	190)	},
-	{ "Grey",		grgb(190,	190,	190)	},
-	{ "LightGray",		grgb(211,	211,	211)	},
-	{ "LightGrey",		grgb(211,	211,	211)	},
-	{ "DarkGray",		grgb(169,	169,	169)	},
-	{ "DarkGrey",		grgb(169,	169,	169)	},
-	{ "Gray10",		grgb(26,	26,	26)	},
-	{ "Grey10",		grgb(26,	26,	26)	},
-	{ "Gray20",		grgb(51,	51,	51)	},
-	{ "Grey20",		grgb(51,	51,	51)	},
-	{ "Gray30",		grgb(77,	77,	77)	},
-	{ "Grey30",		grgb(77,	77,	77)	},
-	{ "Gray40",		grgb(102,	102,	102)	},
-	{ "Grey40",		grgb(102,	102,	102)	},
-	{ "Gray50",		grgb(127,	127,	127)	},
-	{ "Grey50",		grgb(127,	127,	127)	},
-	{ "Gray60",		grgb(153,	153,	153)	},
-	{ "Grey60",		grgb(153,	153,	153)	},
-	{ "Gray70",		grgb(179,	179,	179)	},
-	{ "Grey70",		grgb(179,	179,	179)	},
-	{ "Gray80",		grgb(204,	204,	204)	},
-	{ "Grey80",		grgb(204,	204,	204)	},
-	{ "Gray90",		grgb(229,	229,	229)	},
-	{ "Grey90",		grgb(229,	229,	229)	},
-
-	{ "Black",		grgb(0,		0,	0)	},
-	{ "White",		grgb(255,	255,	255)	},
-
-	{ "Orange",		grgb(255,	165,	0)	},
-	{ "Purple",		grgb(160,	32,	240)	},
-	{ "Violet",		grgb(238,	130,	238)	},
-	{NULL, 0}
-    };
-
-    if (name[0] == '#')
-    {
-	char	    *end;
-	int	    c;
-
-	c = strtol(name + 1, &end, 16);
-	return (guicolor_T) ((c >> 16) & 0xff) | (c & 0xff00) | ((c & 0xff) << 16);
-    }
-
-    for (i = 0; colours[i].name != NULL; i++)
-    {
-	if (STRICMP(name, colours[i].name) == 0)
-	    return colours[i].value;
-    }
-    if (strnicmp(name, "grey", 4) == 0 || strnicmp(name, "gray", 4) == 0)
-    {
-	int level = (255 * atoi(name + 4)) / 100;
-	return (guicolor_T) grgb(level, level, level);
-    }
-    return INVALCOLOR;
-}
-
-/*
- * Set the current text colours.
- * If we are using fonts then set the antialiasing colours too.
- */
-    void
-gui_mch_set_colors(guicolor_T fg, guicolor_T bg)
-{
-    zap_redraw_colours[0] = bg << 8;	/* JK230798, register new background colour */
-    zap_redraw_colours[1] = fg << 8;	/* JK230798, register new foreground colour */
-    zap_redraw_update_colours = TRUE;	/* JK230798, need update of colour masks */
-
-    swi(ColourTrans_ReturnGCOL, fg << 8);
-    gui.fg_colour = r0;
-    swi(ColourTrans_ReturnGCOL, bg << 8);
-    gui.bg_colour = r0;
-
-    if (ro_current_font)
-	swi(ColourTrans_SetFontColours, 0, bg << 8, fg << 8, 14);
-}
-
-    void
-ro_draw_string(x, y, s, len, flags, clip)
-    int	    x;		/* Top-left coord to plot at (x incl, y excl) */
-    int	    y;		/* (screen coords) */
-    char_u  *s;		/* String to plot */
-    int	    len;	/* Length of string */
-    int	    flags;	/* DRAW_TRANSP, DRAW_BOLD, DRAW_UNDERL */
-    int*    clip;	/* JK230798, added clip window */
-{
-    if (ro_current_font)
-    {
-	int	fx;
-	int	flen = len;	/* Preserve for underline */
-
-	/* Use the Font manager to paint the string.
-	 * Must do one char at a time to get monospacing.
-	 */
-
-	if (flags & DRAW_ITALIC && !gui.ital_font)
-	    flags |= DRAW_UNDERL;	/* No italic - underline instead */
-
-	if ((flags & DRAW_TRANSP) == 0)
-	{
-	    swi(ColourTrans_SetColour, gui.bg_colour, 0, 0, 0, 0);
-	    swi(OS_Plot, 4, x, y - gui.char_height);
-	    swi(OS_Plot, 96 + 5, x + len * gui.char_width - 1, y - 1);
-	}
-
-	fx = x + font_x_offset;
-	while (flen--)
-	{
-	    swi(Font_Paint, 0, s++, 0x90, fx, y + font_y_offset, 0, 0, 1);
-	    fx += gui.char_width;
-	}
-    }
-    else
-    {
-	if (zap_redraw)
-	{
-	    /* Using fast Zap redraw. */
-	    flags = ro_zap_redraw_draw_string(x, y, s, len, flags, clip);
-	}
-	else
-	{
-	    /* Using the system font */
-	    if (flags & DRAW_ITALIC)
-		flags |= DRAW_UNDERL;
-
-	    if ((flags & DRAW_TRANSP) == 0)
-	    {
-		swi(ColourTrans_SetColour, gui.bg_colour, 0, 0, 0, 0);
-		swi(OS_Plot, 4, x, y - gui.char_height);
-		swi(OS_Plot, 96 + 5, x + len * gui.char_width - 1, y - 1);
-	    }
-	    swi(OS_Plot, 4,			/* Move the drawing cursor */
-		    x,
-		    y - 1);
-	    swi(ColourTrans_SetColour, gui.fg_colour, 0, 0, 0, 0);
-	    swi(OS_WriteN, s, len);
-
-	    if (flags & DRAW_BOLD)
-	    {
-		swi(OS_Plot, 4, x + (1 << x_eigen_factor), y - 1);
-		swi(OS_WriteN, s, len);
-	    }
-	}
-    }
-
-    if (flags & DRAW_UNDERL)
-    {
-	if (ro_current_font || zap_redraw)
-	    swi(ColourTrans_SetColour, gui.fg_colour, 0, 0, 0, 0);
-	/* Underlined is the same with all plotting methods */
-	swi(OS_Plot, 4, x, y - gui.char_height);
-	swi(OS_Plot, 1, gui.char_width * len, 0);
-    }
-}
-
-    void
-gui_mch_draw_string(int row, int col, char_u *s, int len, int flags)
-{
-    int x, y;		/* Workarea x,y */
-    x = col * gui.char_width;
-    y = -row * gui.char_height;
-
-    if (redraw_block)
-    {
-	ro_draw_string(x + redraw_block[1], y + redraw_block[4],
-			s, len, flags, &redraw_block[7]);	/* JK230798, added clip window */
-    }
-    else
-    {
-	int block[44];
-	block[0] = gui.window_handle;
-	block[1] = x;
-	block[2] = y - gui.char_height;
-	block[3] = (col + len) * gui.char_width;
-	block[4] = y;
-	swi(Wimp_UpdateWindow, 0, block);
-	while (r0)
-	{
-	    ro_draw_string(x + block[1], y + block[4],
-			s, len, flags, &block[7]);	/* JK230798, added clip window */
-	    swi(Wimp_GetRectangle, 0, block);
-	}
-    }
-}
-
-/*
- * Return OK if the key with the termcap name "name" is supported.
- */
-    int
-gui_mch_haskey(char_u *name)
-{
-    return FAIL;
-}
-
-    void
-gui_mch_beep(void)
-{
-    swi(OS_WriteI + 7);
-}
-
-/*
- * Visual bell.
- */
-    void
-gui_mch_flash(int msec)
-{
-    /* TODO */
-}
-
-
-/*
- * Plot a solid rectangle using the given plot action and colour.
- * Coordinates are inclusive and window-relative.
- */
-    void
-plot_rectangle(plot, colour, minx, miny, maxx, maxy)
-    int plot;		/* OS_Plot action */
-    int colour;
-    int minx;
-    int miny;
-    int maxx;
-    int maxy;
-{
-    if (redraw_block)
-    {
-	swi(ColourTrans_SetColour, colour, 0, 0, 0, 0);
-	swi(OS_Plot, 4, minx + redraw_block[1], miny + redraw_block[4]);
-	swi(OS_Plot, plot, maxx + redraw_block[1], maxy + redraw_block[4]);
-    }
-    else
-    {
-	int block[44];
-	block[0] = gui.window_handle;
-	block[1] = minx;
-	block[2] = miny;
-	block[3] = maxx + 1;
-	block[4] = maxy + 1;
-	swi(Wimp_UpdateWindow, 0, block);
-	while (r0)
-	{
-	    swi(ColourTrans_SetColour, colour, 0, 0, 0, 0);
-	    swi(OS_Plot, 4, minx + block[1], miny + block[4]);
-	    swi(OS_Plot, plot, maxx + block[1], maxy + block[4]);
-	    swi(Wimp_GetRectangle, 0, block);
-	}
-    }
-}
-
-/*
- * Invert a rectangle from row r, column c, for nr rows and nc columns.
- */
-    void
-gui_mch_invert_rectangle(int r, int c, int nr, int nc)
-{
-    plot_rectangle(96 + 6, 0, FILL_X(c), -FILL_Y(r + nr), FILL_X(c + nc), -FILL_Y(r));
-}
-
-/*
- * Iconify the GUI window.
- */
-    void
-gui_mch_iconify(void)
-{
-}
-
-#if defined(FEAT_EVAL) || defined(PROTO)
-/*
- * Bring the Vim window to the foreground.
- */
-    void
-gui_mch_set_foreground()
-{
-    /* TODO */
-}
-#endif
-
-/* Draw a hollow rectangle relative to the current
- * graphics cursor position, with the given width
- * and height. Start position is top-left.
- */
-    void
-draw_hollow(w, h)
-    int	w;
-    int	h;
-{
-    swi(OS_Plot, 1, w - 1, 0);
-    swi(OS_Plot, 1, 0, 1 - h);
-    swi(OS_Plot, 1, 1 - w, 0);
-    swi(OS_Plot, 1, 0, h - 1);
-}
-
-/*
- * Draw a cursor without focus.
- */
-    void
-gui_mch_draw_hollow_cursor(guicolor_T colour)
-{
-    int x = FILL_X(gui.cursor_col);	/* Window relative, top-left */
-    int y = -FILL_Y(gui.cursor_row);
-    if (redraw_block == NULL)
-    {
-	int block[11];
-
-	block[0] = gui.window_handle;
-	block[1] = x;
-	block[2] = y - gui.char_height;
-	block[3] = x + gui.char_width;
-	block[4] = y;
-	swi(Wimp_UpdateWindow, 0, block);
-	while (r0)
-	{
-	    swi(ColourTrans_SetGCOL, colour << 8, 0, 0, 0, 0);
-
-	    swi(OS_Plot, 4, x + block[1], y + block[4] - 1);
-	    draw_hollow(gui.char_width, gui.char_height);
-
-	    swi(Wimp_GetRectangle, 0, block);
-	}
-    }
-    else
-    {
-	swi(ColourTrans_SetGCOL, colour << 8, 0, 0, 0, 0);
-
-	swi(OS_Plot, 4, x + redraw_block[1], y + redraw_block[4] - 1);
-	draw_hollow(gui.char_width, gui.char_height);
-    }
-}
-
-/*
- * Draw part of a cursor, "w" pixels wide, and "h" pixels high, using
- * color "color".
- */
-    void
-gui_mch_draw_part_cursor(w, h, colour)
-    int w;
-    int h;
-    guicolor_T colour;
-{
-    int x = FILL_X(gui.cursor_col);
-    int y = -FILL_Y(gui.cursor_row);
-    swi(ColourTrans_ReturnGCOL, colour << 8);
-    plot_rectangle(96 + 5, r0, x, y - h, x + w - 1, y - 1);
-}
-
-/*
- * Catch up with any queued events.  This may put keyboard input into the
- * input buffer, call resize call-backs, trigger timers etc.
- * If there is nothing in the event queue(& no timers pending), then we return
- * immediately (well, after a Wimp_Poll).
- */
-    void
-gui_mch_update(void)
-{
-    int block[64];
-    int reason;
-
-    swi(OS_ReadMonotonicTime);
-    if ((r0 - time_of_last_poll) < 50)
-	return;			    /* Don't return too often */
-
-    reason = wimp_poll(0, block);
-    if (reason)
-	process_event(reason, block);
-    ro_return_early = FALSE;		/* We're returning anyway. */
-}
-
-    void
-redraw_window(block)
-    int *block;
-{
-    int x, y;			/* Vim workarea coords */
-    int width, height;
-    int blank_col;
-
-    swi(ColourTrans_ReturnGCOL, UNUSED_COLOUR << 8, 0, 0, 1<<7, 0);
-    blank_col = r0;
-
-    swi(Wimp_RedrawWindow, 0, block);
-    redraw_block = block;
-    while (r0)
-    {
-	x = block[7] - block[1];
-	y = block[4] - block[10];
-	width  = block[9]  - block[7];
-	height = block[10] - block[8];
-
-	if (height + y > Rows * gui.char_height)
-	{
-	    /* Blank everything off the bottom. */
-	    plot_rectangle(96 + 5, blank_col,
-				0, block[8] - block[4],
-				block[9] - block[1], -FILL_Y(Rows) - 1);
-	    height = Rows * gui.char_height;
-	}
-	if (width + x> Columns * gui.char_width)
-	{
-	    /* Blank everything off to the right. */
-	    plot_rectangle(96 + 5, blank_col,
-				FILL_X(Columns), block[8] - block[4],
-				block[9] - block[1], 0);
-	    width = Columns * gui.char_width;
-	}
-	gui_redraw(x , y, width, height);
-	swi(Wimp_GetRectangle, 0, block);
-    }
-    redraw_block = NULL;
-}
-
-/* Check if we have modified data.
- * If we do then ack the message to stop the shutdown.
- * Otherwise, ignore the message.
- */
-    void
-ro_prequit(block)
-    int	    *block;
-{
-    if (!ro_ok_to_quit())
-    {
-	/* Not OK to quit - stop shutdown */
-	block[3] = block[2];
-	swi(Wimp_SendMessage, 19, block, block[1]);
-    }
-    /* Do nothing. We may get a Message_Quit later. */
-}
-
-/* If there is unsaved data then ask the user if they mind losing it.
- * Return TRUE if we can quit without saving, FALSE to halt the
- * shutdown.
- */
-    int
-ro_ok_to_quit()
-{
-    int	    old_confirm = cmdmod.confirm;
-
-    cmdmod.confirm = FALSE;	    /* Use our own, single tasking, box */
-
-    if (check_changed_any(FALSE))
-    {
-	swi(Wimp_ReportError,
-		"\0\0\0\0Vim contains unsaved data - quit anyway?",
-		0x17,
-		"Vim");
-	cmdmod.confirm = old_confirm;
-	if (r1 != 1)
-	    return FALSE;
-    }
-    cmdmod.confirm = old_confirm;
-    return TRUE;
-}
-
-/* Quit without checking for unsaved data. */
-    void
-ro_quit()
-{
-    exiting = TRUE;
-    getout(0);
-
-    exiting = FALSE;		    /* probably can't get here */
-    setcursor();		    /* position cursor */
-    out_flush();
-}
-
-/* Insent the given vim special code into the input buffer */
-    void
-ro_press(a, b, modifier)
-    char a;
-    char b;
-    int modifier;	/* %<Ctrl><Shift> 0000 0000 */
-{
-    char_u buf[6];
-    int	    vim_mod;
-    int	    key;
-
-
-    /* Convert RISC OS modifier to Vim modifier. */
-    vim_mod = ((modifier & 0x10) ? MOD_MASK_SHIFT : 0)
-	       | ((modifier & 0x20) ? MOD_MASK_CTRL : 0);
-    key = simplify_key(TERMCAP2KEY(a, b), &vim_mod);
-
-    buf[3] = CSI;
-    buf[4] = KEY2TERMCAP0(key);
-    buf[5] = KEY2TERMCAP1(key);
-    if (vim_mod)
-    {
-	buf[0] = CSI;
-	buf[1] = KS_MODIFIER;
-	buf[2] = vim_mod;
-	add_to_input_buf(buf, 6);
-    }
-    else
-	add_to_input_buf(buf + 3, 3);
-}
-
-/* Take a wimp key code and insert the vim equivalent
- * into vim's input buffer.
- * CTRL-C also sets got_int.
- */
-    void
-ro_insert_key(code)
-    char_u *code;		/* Wimp_ProcessKey code (4 bytes) */
-{
-    char a = code[0];
-    char b = code[1];
-    int base, modifier;
-
-    if (a == 3 && ctrl_c_interrupts)
-	got_int = TRUE;
-
-    /* Is it a normal key? */
-    if (a > 31 && a < 127)
-    {
-	add_to_input_buf(code, 1);
-	return;
-    }
-
-    /* We should pass any unrecognised keys on, but
-     * for now just pass on F12 combinations.
-     */
-    switch (b)
-    {
-	case 0:
-	    /* Home and Delete are the only special cases */
-	    switch (a)
-	    {
-		case 0x1e:
-		    ro_press('k','h', 0);	/* Home */
-		    return;
-		case 0x7f:
-		    ro_press('k','D', 0);	/* Delete */
-		    return;
-		case CSI:
-		    {
-			/* Turn CSI into K_CSI.  Untested! */
-			char_u string[3] = {CSI, KS_EXTRA, KE_CSI};
-
-			add_to_input_buf(string, 3);
-			return;
-		    }
-		default:
-		    add_to_input_buf(code, 1);
-		    return;
-	    }
-	case 1:
-	    if ((a & 0xcf) == 0xcc)
-	    {
-		/* F12 pressed - pass it on (quick hack) */
-		swi(Wimp_ProcessKey, a | 0x100);
-		return;
-	    }
-	    base = a & 0xcf;
-	    modifier = a & 0x30;
-	    switch (base)
-	    {
-		case 0x8a:	/* Tab */
-		    add_to_input_buf("\011", 1);
-		    return;
-		case 0x8b:	/* Copy (End) */
-		    return ro_press('@', '7', modifier);
-		case 0x8c:	/* Left */
-		    return ro_press('k', 'l', modifier);
-		case 0x8d:	/* Right */
-		    return ro_press('k', 'r', modifier);
-		case 0x8e:	/* Down */
-		    if (modifier & 0x10)
-			return ro_press('k', 'N', modifier ^ 0x10);
-		    else
-			return ro_press('k', 'd', modifier);
-		case 0x8f:	/* Up */
-		    if (modifier & 0x10)
-			return ro_press('k', 'P', modifier ^ 0x10);
-		    else
-			return ro_press('k', 'u', modifier);
-		case 0xca:	/* F10 */
-		    return ro_press('k', ';', modifier);
-		case 0xcb:	/* F11 */
-		    return ro_press('F', '1', modifier);
-		case 0xcd:	/* Insert */
-		    return ro_press('k', 'I', modifier);
-		default:
-		    if (base > 0x80 && base < 0x18a)
-		    {
-			/* One of the other function keys */
-			return ro_press('k', '0' + (base & 15), modifier);
-		    }
-	    }
-    }
-}
-
-/* Process a mouse event. */
-    void
-ro_mouse(block)
-    int *block;
-{
-    int x, y, button, vim_button;
-    int modifiers = 0;
-    int min_x, min_y;		/* Visible area of editor window */
-    int max_x, max_y;
-
-    if (block[3] != gui.window_handle || ro_dragging)
-	return;			/* Not our window or ignoring clicks*/
-
-    x = block[0];		/* Click position - screen coords */
-    y = block[1];
-    button = block[2];
-
-    block[0] = gui.window_handle;
-    swi(Wimp_GetWindowState, 0, block);
-    min_x = block[1];
-    min_y = block[2];
-    max_x = block[3];
-    max_y = block[4];
-
-    if (block[3] - x < gui.scrollbar_width)
-    {
-	/* Click in that blank area under the scrollbars */
-
-	if (button & 0x444)
-	{
-	    int	    front_block[10];
-	    /* Dragging with Select - bring window to front first */
-	    front_block[0] = gui.window_handle;
-	    swi(Wimp_GetWindowState, 0, front_block);
-	    front_block[7] = -1;
-	    ro_open_main(front_block);
-	}
-
-	block[0] = gui.window_handle;
-	block[1] = 7;			/* Drag point */
-	block[2] = block[4] = 0;	/* Coords of point. */
-	block[3] = block[5] = 0;
-	drag_x_offset = max_x - x;
-	drag_y_offset = min_y - y;
-
-	/* Parent box. */
-	block[6] = min_x +
-			gui.scrollbar_width * 2 +
-			MIN_COLUMNS * gui.char_width;
-	block[7] = 0;
-	gui_mch_get_screen_dimensions(&block[8], &block[9]);
-	block[9] = max_y -
-			4 * gui.char_height -
-			gui.scrollbar_height;
-
-	swi(Wimp_DragBox, 0, block);
-	ro_dragging = DRAG_RESIZE_WINDOW;
-	drag_button = vim_button;
-	drag_modifiers = modifiers;
-	return;
-    }
-
-    if (button & 0x111)
-	vim_button = MOUSE_RIGHT;
-    else if (button & 0x222)
-	vim_button = MOUSE_MIDDLE;
-    else
-	vim_button = MOUSE_LEFT;
-
-    swi(OS_Byte, 121, 0x80);
-    if (r1 == 0xff)
-	modifiers |= MOUSE_SHIFT;
-    swi(OS_Byte, 121, 0x81);
-    if (r1 == 0xff)
-	modifiers |= MOUSE_CTRL;
-    swi(OS_Byte, 121, 0x82);
-    if (r1 == 0xff)
-	modifiers |= MOUSE_ALT;
-
-    if (button == 2)
-    {
-	/* Menu click:
-	 * If shift was pressed then do the paste action.
-	 * If not, then open the pop-up menu.
-	 */
-	modifiers ^= MOUSE_SHIFT;
-	if (modifiers && MOUSE_SHIFT)
-	{
-	    vimmenu_T	main;
-	    /* Shift was NOT pressed - show menu */
-	    main.dname = (char_u *) "Vim";
-	    main.children = root_menu;
-	    gui_mch_show_popupmenu(&main);
-	    return;
-	}
-    }
-
-    /* Gain the input focus */
-    swi(Wimp_SetCaretPosition, gui.window_handle, -1, 0, 0, -1, -1);
-
-    if (button & 0xf0)
-    {
-	/* Drag operation:
-	 *
-	 * Tell the Wimp to start a drag.
-	 * Monitor null events.
-	 */
-	block[1] = 7;			/* Drag a point. */
-	block[2] = block[4] = x;	/* Coords of point. */
-	block[3] = block[5] = y;
-	block[6] = 0;			/* Coords of bounding box. */
-	block[7] = 0;
-	gui_mch_get_screen_dimensions(&block[8], &block[9]);
-
-	drag_x_offset = drag_y_offset = 0;
-
-	swi(Wimp_DragBox, 0, block);
-	ro_dragging = DRAG_SELECTION;
-	drag_button = vim_button;
-	drag_modifiers = modifiers;
-
-	vim_button |= MOUSE_DRAG;
-    }
-
-    gui_send_mouse_event(
-		vim_button,
-		x - min_x,
-		max_y - y,
-		button & 0xf ? TRUE : FALSE,	/* dclick */
-		modifiers);
-}
-
-    void
-ro_continue_drag(block)
-    int *block;			/* Just used as scrap. */
-{
-    int x, y;
-
-    /* Get screen coords of pointer. */
-    swi(Wimp_GetPointerInfo, 0, block);
-    x = block[0] + drag_x_offset;
-    y = block[1] + drag_y_offset;
-
-    block[0] = gui.window_handle;
-    swi(Wimp_GetWindowState, 0, block);
-
-    if (ro_dragging == DRAG_RESIZE_WINDOW)
-    {
-	/* Resizeing the main window. */
-	block[2] = y;
-	block[3] = x;
-	ro_open_main(block);
-    }
-    else
-    {
-	/* Selecting some text. */
-	gui_send_mouse_event(
-	    drag_button | MOUSE_DRAG,	/* Always report the same button */
-	    x - block[1],
-	    block[4] - y,
-	    FALSE,			/* Not a double click. */
-	    drag_modifiers);
-    }
-}
-
-/* User has released all mouse buttons, marking the end of a drag. */
-    void
-ro_drag_finished(block)
-    int *block;
-{
-    int x;
-    int y;
-    int width, height;
-
-    /* I don't trust the box returned by Wimp_Poll; look at the pointer
-     * ourselves.
-     */
-    swi(Wimp_GetPointerInfo, 0, block);
-    x = block[0] + drag_x_offset;
-    y = block[1] + drag_y_offset;
-
-    if (ro_dragging == DRAG_RESIZE_WINDOW)
-    {
-	block[0] = gui.window_handle;
-	swi(Wimp_GetWindowState, 0, block);
-	block[2] = y;
-	block[3] = x;
-	ro_open_main(block);
-
-	width = (block[3] - block[1]);
-	height = (block[4] - block[2]);
-
-	swi(Wimp_ForceRedraw, gui.window_handle, 0, -height, width, 0);
-	gui_resize_shell(width, height);
-    }
-    else
-    {
-	block[0] = gui.window_handle;
-	swi(Wimp_GetWindowState, 0, block);
-	gui_send_mouse_event(
-		MOUSE_RELEASE,
-		x - block[1],
-		block[4] - y,
-		FALSE,			/* not a double click */
-		drag_modifiers);
-    }
-    ro_dragging = DRAG_FALSE;
-}
-
-/* Load the file/pathname given in block into a [new] buffer.
- *
- * Modifier	Action
- *
- * None		:confirm e <file>
- * Ctrl		:sp <file>
- * Shift	<file>
- *
- * Insert into typebuf, at the start.
- * If loading from !Scrap then use saved leafname instead, and
- * delete the scrap file. Also, ignore shift key.
- *
- * NB: Doesn't send DataLoadAck (other app might delete temp file?).
- */
-    void
-ro_dataload(block)
-    int	    *block;
-{
-    char_u  new_path[MAXPATHL];
-    char_u  *path = ((char_u *) block) + 44;
-    int	    scrap = FALSE;
-
-    if (block[3] == leaf_ref && leaf_name)
-	scrap = TRUE;
-
-    switch (get_real_state() & 0xff)
-    {
-	case INSERT:
-	case CMDLINE:
-	case CMDLINE+LANGMAP:
-	    /* For insert mode we can only insert the pathname (currently)
-	     * Make sure Shift is pressed.
-	     */
-	    swi(OS_Byte, 121, 0x80);	    /* Is Shift pressed? */
-	    if (r1 == 0xff)
-	    {
-		ins_typebuf(" ", REMAP_NONE, 0, TRUE, FALSE);
-		ins_typebuf(path, REMAP_NONE, 0, TRUE, FALSE);
-		ro_return_early = TRUE;		    /* Return even though nothing was typed. */
-	    }
-	    else
-		swi(Wimp_ReportError,
-			"\0\0\0\0Sorry, you can only load text in normal mode", 5, "Vim");
-	    break;
-
-	case NORMAL:
-	    ro_return_early = TRUE;	    /* Return even though nothing was typed. */
-
-	    if (scrap)			    /* Remove <Wimp$Scrap>. Later. */
-		ins_typebuf(":!~remove <Wimp$Scrap>\r", REMAP_NONE, 0, TRUE, FALSE);
-
-	    /* Insert {:sp ,:confirm e }[+f\ <leaf> ]<file><CR> */
-	    ins_typebuf("\r", REMAP_NONE, 0, TRUE, FALSE);
-	    ins_typebuf(path, REMAP_NONE, 0, TRUE, FALSE);
-	    ins_typebuf(" ", REMAP_NONE, 0, TRUE, FALSE);
-
-	    if (scrap)
-	    {
-		/* Loading via !Scrap - change pathname to stored leafname */
-		ins_typebuf(leaf_name, REMAP_NONE, 0, TRUE, FALSE);
-		ins_typebuf(" +f\\ ", REMAP_NONE, 0, TRUE, FALSE);
-		leaf_ref = 0;
-		vim_free(leaf_name);
-		leaf_name = NULL;
-	    }
-
-	    swi(OS_Byte, 121, 0x81);	    /* Is Ctrl pressed? */
-	    if (r1 == 0xff)
-		/* Yes, split window */
-		ins_typebuf(":sp", REMAP_NONE, 0, TRUE, FALSE);
-	    else
-		ins_typebuf(":confirm e", REMAP_NONE, 0, TRUE, FALSE);
-	    break;
-
-	default:
-	    swi(Wimp_ReportError, "\0\0\0\0You can only load text in normal mode.", 5, "Vim");
-    }
-    /* Send DataSaveAck so other program doesn't think we died
-     * and delete <Wimp$Scrap>.
-     */
-    block[3] = block[2];
-    block[4] = 4;
-    swi(Wimp_SendMessage, 17, block, block[1]);
-}
-
-    void
-ro_datasave(block)
-    int	    *block;
-{
-    char_u *path = ((char_u *) block) + 44;
-
-    /* Preserve the name given so we can use it, not <Wimp$Scrap> */
-    if (leaf_name)
-	vim_free(leaf_name);
-    leaf_name = vim_strsave(path);
-
-    block[9] = -1;	    /* File is unsafe. */
-    strcpy(path, "<Wimp$Scrap>");
-    block[0] = 60;
-    block[3] = block[2];
-    block[4] = 2;
-    swi(Wimp_SendMessage, 17, block, block[1]);
-
-    leaf_ref = block[2];
-}
-
-    void
-ro_message(block)
-    int *block;
-{
-    char_u	*buffer;
-    long_u	len;
-
-    if (block[1] == task_handle)
-	return;			    /* Don't talk to ourself! */
-    switch (block[4])
-    {
-	case 0:		/* Quit. */
-	    if (block[4] == 0)
-		ro_quit();
-	    break;
-	case 1:	/* DataSave */
-	    ro_datasave(block);
-	    break;
-	case 2:		/* DataSaveAck. */
-	    if (clip_convert_selection(&buffer, &len, &clip_star) == -1)
-		return;
-
-	    /* Save the clipboard contents to a file. */
-	    swi(OS_File, 10, ((char_u *) block) + 44, 0xfff, 0, buffer, buffer + len);
-
-	    /* Ack with DataLoad message. */
-	    block[3] = block[2];
-	    block[4] = 3;
-	    block[9] = len;
-	    swi(Wimp_SendMessage, 17, block, block[1]);
-
-	    vim_free(buffer);
-	    break;
-	case 3:		/* DataLoad */
-	    ro_dataload(block);
-	    break;
-	case 8:		/* PreQuit */
-	    ro_prequit(block);
-	    break;
-	case 0xf:	/* Lose clipboard. */
-	    if (block[5] & 4)
-	    {
-		clip_free_selection(&clip_star);
-		clip_star.owned = FALSE;
-	    }
-	    break;
-	case 0x10:	/* DataRequest (clip_star) */
-	    if (clip_star.owned)
-	    {
-		int rows;
-
-		/* Tell other program that we have the clipboard. */
-		block[0] = 52;
-		block[3] = block[2];	    /* Copy myref to yourref. */
-		block[4] = 1;		    /* DataSave message. */
-		/* Create an estimate for the size (larger or same as true
-		 * value) */
-		rows = clip_star.end.lnum - clip_star.start.lnum;
-		if (rows < 0)
-		    rows = -rows;
-		block[9] = (rows + 1) * Columns + 1; /* Add one for possible
-							final newline. */
-		block[10] = 0xfff;	    /* Clipboard is text. */
-		strcpy( ((char_u *) block) + 44, "VimClip");
-		swi(Wimp_SendMessage, 17, block, block[1]);
-	    }
-	    break;
-	case 0x400c1:	/* Mode change */
-	    changed_mode = TRUE;		/* Flag - update on next OpenWindow */
-	    if (zap_redraw)
-	    {
-		/* JK230798, re-initialise ZapRedraw stuff */
-		if (ro_zap_redraw_initialise() == FAIL)
-		    zap_redraw = FALSE;
-	    }
-	    break;
-	case 0x400c3:	/* TaskCloseDown */
-	    if (block[1] == child_handle)
-		child_handle = 0;
-	    break;
-    }
-}
-
-/*
- * Converts a scrollbar's window handle into a scrollbar pointer.
- * NULL on failure.
- */
-    scrollbar_T *
-ro_find_sbar(id)
-    int		id;
-{
-    win_T	*wp;
-
-    if (gui.bottom_sbar.id == id)
-	return &gui.bottom_sbar;
-    FOR_ALL_WINDOWS(wp)
-    {
-	if (wp->w_scrollbars[SBAR_LEFT].id == id)
-	    return &wp->w_scrollbars[SBAR_LEFT];
-	if (wp->w_scrollbars[SBAR_RIGHT].id == id)
-	    return &wp->w_scrollbars[SBAR_RIGHT];
-    }
-    return NULL;
-}
-
-    void
-scroll_to(line, sb)
-    int sb;	/* Scrollbar number */
-    int line;
-{
-    char_u code[8];
-
-    /* Don't put events in the input queue now. */
-    if (hold_gui_events)
-	return;
-
-    /* Send a scroll event:
-     *
-     * A scrollbar event is CSI (NOT K_SPECIAL), KS_VER_SCROLLBAR,
-     * KE_FILLER followed by:
-     * one byte representing the scrollbar number, and then four bytes
-     * representing a long_u which is the new value of the scrollbar.
-     */
-    code[0] = CSI;
-    code[1] = KS_VER_SCROLLBAR;
-    code[2] = KE_FILLER;
-    code[3] = sb;
-    code[4] = line >> 24;
-    code[5] = line >> 16;
-    code[6] = line >> 8;
-    code[7] = line;
-    add_to_input_buf(code, 8);
-}
-
-    void
-h_scroll_to(col)
-    int col;
-{
-    char_u code[8];
-
-    /* Don't put events in the input queue now. */
-    if (hold_gui_events)
-	return;
-
-    /* Send a scroll event:
-     *
-     * A scrollbar event is CSI (NOT K_SPECIAL)
-     *
-     * A horizontal scrollbar event is K_SPECIAL, KS_HOR_SCROLLBAR,
-     * KE_FILLER followed by four bytes representing a long_u which is the
-     * new value of the scrollbar.
-     */
-    code[0] = CSI;
-    code[1] = KS_HOR_SCROLLBAR;
-    code[2] = KE_FILLER;
-    code[4] = col >> 24;
-    code[5] = col >> 16;
-    code[6] = col >> 8;
-    code[7] = col;
-    add_to_input_buf(code, 8);
-}
-
-    void
-ro_scroll(block)
-    int		*block;
-{
-    scrollbar_T	*sb;
-    int		offset;
-    win_T	*wp;
-
-    /* Block is ready for Wimp_OpenWindow, and also contains:
-     *
-     * +32 = scroll X direction (-2 .. +2)
-     * +36 = scroll Y direction (-2 .. +2)
-     */
-
-    sb = ro_find_sbar(block[0]);
-    if (!sb)
-	return;		/* Window not found (error). */
-
-    wp = sb-> wp;
-
-    if (wp == NULL)
-    {
-	/* Horizontal bar. */
-	offset = block[8];
-	if (offset == -2)
-	    offset = (block[1] - block[3]) / gui.char_width;
-	else if (offset == 2)
-	    offset = (block[3] - block[1]) / gui.char_width;
-
-	block[5] += offset * gui.char_width;
-
-	gui_drag_scrollbar(sb, block[5] / gui.char_width, FALSE);
-
-	swi(Wimp_OpenWindow, 0, block);
-    }
-    else
-    {
-	offset = -block[9];
-	if (offset == -2)
-	    offset = -(wp -> w_height - 1);
-	else if (offset == 2)
-	    offset = wp -> w_height - 1;
-
-	/* Possibly we should reposition the scrollbar?
-	 * Vim seems to update the bar anyway...
-	 */
-	gui_drag_scrollbar(sb, offset - (block[6] / gui.char_height), FALSE);
-    }
-}
-
-/* Move a window by a given offset. Used to simulate the function of the
- * nested wimp.
- */
-    void
-ro_move_child(window, x, y, pos_wanted, pos_got)
-    int	window;
-    int x,y;		/* offset to move by */
-    int	pos_wanted, pos_got;
-{
-    int	block[10];
-
-    block[0] = window;
-    swi(Wimp_GetWindowState, 0, block);
-    block[1] += x;
-    block[2] += y;
-    block[3] += x;
-    block[4] += y;
-    if (pos_wanted == -1)
-	block[7] = -1;
-    else if (pos_wanted == -2)
-	block[7] = pos_got;
-    swi(Wimp_OpenWindow, 0, block);
-}
-
-/* Open the main window. Also updates scrollbars if we are not
- * using the nested Wimp.
- * If we have just changed mode then re-read all values.
- */
-    void
-ro_open_main(block)
-    int	    *block;
-{
-    int	    toggle_size;
-
-    /* Find out if the user clicked on the toggle size icon. */
-    block[20] = block[0];
-    swi(Wimp_GetWindowState, 0, block + 20);
-    toggle_size = block[28] & (1 << 19);
-
-    if (nested_wimp)
-    {
-	swi(Wimp_OpenWindow, 0, block);
-    }
-    else
-    {
-	int	old[10];
-	int	x_offset, y_offset;	    /* Move children same as parent. */
-	int	pos_wanted, pos_got;
-	int	left_bar  = gui.which_scrollbars[SBAR_LEFT];
-	int	right_bar = gui.which_scrollbars[SBAR_RIGHT];
-	win_T	*wp;
-
-	/* Three cases to think about:
-	 * 1) Move to top. Open each window at the top.
-	 * 2) Same stack position. Open each with same position.
-	 * 3) Open at bottom. Open children with parent's new position.
-	 */
-
-	old[0] = block[0];
-	swi(Wimp_GetWindowState, 0, old);
-	pos_wanted = block[7];
-	swi(Wimp_OpenWindow, 0, block);
-	/* Block updated by OpenWindow? I don't think so! */
-	swi(Wimp_GetWindowState, 0, block);
-	pos_got = block[7];
-
-	x_offset = block[1] - old[1];
-	y_offset = block[4] - old[4];
-	if (x_offset || y_offset || pos_wanted == -1 || pos_wanted == -2)
-	{
-	    /* If parent has moved, re-open all the child windows. */
-	    FOR_ALL_WINDOWS(wp)
-	    {
-		/* Reopen scrollbars for this window. */
-		if (left_bar)
-		    ro_move_child(wp -> w_scrollbars[SBAR_LEFT].id,
-				x_offset, y_offset,
-				pos_wanted, pos_got);
-		if (right_bar)
-		    ro_move_child(wp -> w_scrollbars[SBAR_RIGHT].id,
-				x_offset, y_offset,
-				pos_wanted, pos_got);
-	    }
-	}
-    }
-    if (changed_mode || toggle_size)
-    {
-	int	width, height;
-
-	if (changed_mode)
-	    ro_measure_tools();
-	block[0] = gui.window_handle;
-	swi(Wimp_GetWindowState, 0, block);
-
-	width = block[3] - block[1];
-	height = block[4] - block[2];
-	swi(Wimp_ForceRedraw, gui.window_handle, 0, -height, width, 0);
-	gui_resize_shell(width, height);
-	changed_mode = FALSE;
-    }
-}
-
-    void
-ro_open_window(block)
-    int		*block;
-{
-    int		pos;
-    scrollbar_T *sb;
-
-    if (block[0] == gui.window_handle)
-	ro_open_main(block);
-    else
-    {
-	swi(Wimp_OpenWindow, 0, block);
-	if (block[0] != gui.window_handle)
-	{
-	    sb = ro_find_sbar(block[0]);
-	    if (sb)
-	    {
-		if (sb-> wp != NULL)
-		    gui_drag_scrollbar(sb, -block[6] / gui.char_height, FALSE);
-		else
-		    gui_drag_scrollbar(sb, block[5] / gui.char_width, FALSE);
-	    }
-	}
-    }
-}
-
-    void
-ro_menu_selection(block)
-    int		*block;
-{
-    int		*item = wimp_menu + 7;
-    vimmenu_T	*menu;
-    /* wimp_menu points to a wimp menu structure */
-
-    for (;;)
-    {
-	while (block[0]--)
-	    item += 6;
-	if (block[1] == -1)
-	    break;
-	item = ((int *) item[1]) + 7;
-	block++;
-    }
-    /* item points to the wimp menu item structure chosen */
-    menu = (vimmenu_T *) item[5];
-
-    swi(Wimp_GetPointerInfo, 0, block);
-    if (block[2] == 1)
-	/* Adjust used - keep menu open */
-	swi(Wimp_CreateMenu, 0, wimp_menu);
-
-    if (menu-> cb)
-	menu-> cb(menu);
-}
-
-    void
-ro_open_parent()
-{
-    int head;
-    char_u *i = curbuf-> b_ffname;
-    char_u  buffer[256];
-
-    head = 0;
-    for (; *i; i++)
-    {
-	if (*i == '.')
-	    head = i - curbuf-> b_ffname;
-    }
-
-    /* Append head chars to buffer */
-    if (head < 240 && curbuf-> b_ffname && head)
-    {
-	strcpy(buffer, "%filer_opendir ");
-	strncpy(buffer + 15, curbuf-> b_ffname, head);
-	buffer[15 + head] = '\0';
-	swi(OS_CLI, buffer);
-    }
-}
-
-    void
-process_event(event, block)
-    int event;
-    int *block;
-{
-    switch (event)
-    {
-	case 0:		/* Nothing - update drag state. */
-	    if (ro_dragging)
-		ro_continue_drag(block);
-	    break;
-	case 1:		/* Redraw window. */
-	    redraw_window(block);
-	    break;
-	case 2:		/* Open window. */
-	    ro_open_window(block);
-	    break;
-	case 3:		/* Close window. */
-	    swi(Wimp_GetPointerInfo, 0, block + 1);
-	    if (block[3] == 1)
-		ro_open_parent();
-	    else
-		if (ro_ok_to_quit())
-		    ro_quit();
-	    break;
-	case 6:		/* Mouse click. */
-	    ro_mouse(block);
-	    break;
-	case 7:		/* Finished drag. */
-	    ro_drag_finished(block);
-	    break;
-	case 8:		/* Key pressed. */
-	    ro_insert_key((char_u *) &block[6]);
-	    break;
-	case 9:
-	    ro_menu_selection(block);
-	    break;
-	case 10:	/* Scroll request. */
-	    ro_scroll(block);
-	    break;
-	case 11:	/* Lose caret. */
-	    if (block[0] == gui.window_handle)
-		gui_focus_change(FALSE);
-	    break;
-	case 12:	/* Gain caret. */
-	    if (block[0] == gui.window_handle)
-		gui_focus_change(TRUE);
-	    break;
-	case 17:	/* User message. */
-	case 18:	/* User message recorded. */
-	    ro_message(block);
-	    break;
-    }
-}
-
-/*
- * GUI input routine called by gui_wait_for_chars().  Waits for a character
- * from the keyboard.
- *  wtime == -1	    Wait forever.
- *  wtime == 0	    This should never happen.
- *  wtime > 0	    Wait wtime milliseconds for a character.
- * Returns OK if a character was found to be available within the given time,
- * or FAIL otherwise.
- */
-    int
-gui_mch_wait_for_chars(long wtime)
-{
-    int block[64];
-    int	reason;
-    int start_time = -1;
-    int ctime = wtime / 10;	/* delay in cs */
-
-    if (wtime != -1)
-    {
-	swi(OS_ReadMonotonicTime);
-	start_time = r0;
-    }
-
-    for (;;)
-    {
-	if (ro_dragging)
-	    reason = wimp_poll(0, block);	/* Always return immediately */
-	else if (wtime == -1)
-	    reason = wimp_poll(1, block);
-	else
-	    reason = wimp_pollidle(0, block, start_time + ctime);
-
-	process_event(reason, block);
-
-	if (input_available() || ro_return_early)
-	{
-	    ro_return_early = FALSE;
-	    return OK;	    /* There is something to process (key / menu event) */
-	}
-
-	if (wtime != -1)
-	{
-	    swi(OS_ReadMonotonicTime);
-	    if (r0 - start_time > ctime)
-		return FAIL;	/* We've been waiting too long - return failure */
-	}
-    }
-}
-
-/* Flush any output to the screen */
-    void
-gui_mch_flush(void)
-{
-}
-
-/*
- * Clear a rectangular region of the screen from text pos(row1, col1) to
- * (row2, col2) inclusive.
- */
-    void
-gui_mch_clear_block(int row1, int col1, int row2, int col2)
-{
-    swi(ColourTrans_ReturnGCOL, gui.back_pixel << 8, 0, 0, 1<<7, 0);
-    plot_rectangle(96 + 5, r0,
-			FILL_X(col1), -FILL_Y(row2 + 1),
-			FILL_X(col2 + 1), -FILL_Y(row1));
-}
-
-    void
-gui_mch_clear_all(void)
-{
-    if (redraw_block)
-    {
-	swi(ColourTrans_SetGCOL, gui.back_pixel << 8, 0, 0, 1<<7, 0);
-	swi(OS_WriteI + 16);
-    }
-    else
-    {
-	int block[44];
-	block[0] = gui.window_handle;
-	block[1] = 0;
-	block[2] = -gui.num_rows * gui.char_height;
-	block[3] = gui.num_cols * gui.char_width;
-	block[4] = 0;
-	swi(Wimp_UpdateWindow, 0, block);
-	while (r0)
-	{
-	    swi(ColourTrans_SetGCOL, gui.back_pixel << 8, 0, 0, 1<<7, 0);
-	    swi(OS_WriteI + 16);
-	    swi(Wimp_GetRectangle, 0, block);
-	}
-    }
-}
-
-/*
- * Delete the given number of lines from the given row, scrolling up any
- * text further down within the scroll region.
- */
-    void
-gui_mch_delete_lines(int row, int num_lines)
-{
-    int top_from = -row - num_lines;
-    int bot_from = -gui.scroll_region_bot - 1;
-    int bot_to   = bot_from + num_lines;
-
-    swi(ColourTrans_SetGCOL, gui.back_pixel << 8, 0, 0, 0x80, 0);
-
-    /* Changed without checking! */
-    swi(Wimp_BlockCopy, gui.window_handle,
-			    gui.scroll_region_left * gui.char_width,
-			    bot_from * gui.char_height,
-			    (gui.scroll_region_right - gui.scroll_region_left
-							+ 1) * gui.char_width,
-			    top_from * gui.char_height,
-
-			    gui.scroll_region_left * gui.char_width,
-			    bot_to * gui.char_height);
-
-    gui_clear_block(gui.scroll_region_bot - num_lines + 1,
-						       gui.scroll_region_left,
-	gui.scroll_region_bot, gui.scroll_region_right);
-}
-
-/*
- * Insert the given number of lines before the given row, scrolling down any
- * following text within the scroll region.
- */
-    void
-gui_mch_insert_lines(int row, int num_lines)
-{
-    int top_from = -row;
-    int bot_to   = -gui.scroll_region_bot - 1;
-    int bot_from = bot_to + num_lines;
-
-    swi(ColourTrans_SetGCOL, gui.back_pixel << 8, 0, 0, 0x80, 0);
-
-    swi(Wimp_BlockCopy, gui.window_handle,
-			    gui.scroll_region_left * gui.char_width,
-			    bot_from * gui.char_height,
-			    (gui.scroll_region_right - gui.scroll_region_left
-							+ 1) * gui.char_width,
-			    top_from * gui.char_height,
-
-			    gui.scroll_region_left * gui.char_width,
-			    bot_to * gui.char_height);
-
-    gui_clear_block(row, gui.scroll_region_left,
-				row + num_lines - 1, gui.scroll_region_right);
-}
-
-/* Put selection in clipboard buffer.
- * Should we become the new owner?
- */
-    void
-clip_mch_request_selection(VimClipboard *cbd)
-{
-    int		block[64];	/* Will be used in Wimp_Poll. */
-    int		reason;
-    char_u	*buffer;
-    long_u	length;
-
-    block[0] = 48;			/* Size of block. */
-    block[3] = 0;			/* Orinial message. */
-    block[4] = 0x10;			/* Data request. */
-    block[5] = gui.window_handle;
-    block[6] = RO_LOAD_CLIPBOARD;	/* Internal handle. */
-    block[7] = block[8] = 0;		/* (x,y) not used. */
-    block[9] = 4;
-    block[10] = 0xfff;	    /* We want text files if possible, I think. */
-    block[11] = -1;	    /* End of list. */
-    swi(Wimp_SendMessage, 17, block, 0);    /* Broadcast request. */
-
-    /* OK, we've sent the request. Poll until we get a null poll (failure) or
-     * we load the clipboard.
-     * If we receive a DataSave event with icon handle = -2 then put it on the
-     * clipboard. RISC OS should ensure that key events will not be delivered
-     * until the clipboard operation completes (unless the owner starts idling
-     * - we can't wait forever!).
-     */
-    for (;;)
-    {
-	reason = wimp_poll(0, block);
-	if (reason == 0)
-	    return;	    /* Failed to get clipboard. */
-	if ((reason == 17 || reason == 18) &&
-		block[4] == 1 && block[6] == RO_LOAD_CLIPBOARD)
-	    break;	    /* Got it - stop waiting. */
-	process_event(reason, block);
-	if (ro_return_early)
-	    return;
-    }
-    /* Tell owner to save data in <Wimp$Scrap>. */
-    block[0] = 60;
-    block[3] = block[2];   /* Copy myref -> yourref */
-    block[4] = 2;	    /* DataSaveAck. */
-    block[9] = -1;	    /* Data is unsafe. */
-    strcpy( ((char_u *) block) + 44, "<Wimp$Scrap>");
-    swi(Wimp_SendMessage, 17, block, block[1]);
-
-    /* Wait again for reply. */
-    for (;;)
-    {
-	reason = wimp_poll(0, block);
-	if (reason == 0)
-	    return;	/* Other program has given up! */
-	if ((reason == 17 || reason == 18) && block[4] == 3 && block[6] == RO_LOAD_CLIPBOARD)
-	    break;	/* Clipboard data saved to <Wimp$Scrap> */
-	process_event(reason, block);
-	if (ro_return_early)
-	    return;
-    }
-
-    /* <Wimp$Scrap> contains clipboard - load it. */
-    if (xswi(OS_File, 17, "<Wimp$Scrap>") & v_flag)
-	return;		/* Error! */
-    if (r0 != 1 && r0 != 3)
-	return;
-    length = r4;
-
-    buffer = lalloc(length, TRUE);  /* Claim memory (and report errors). */
-    if (buffer == NULL)
-	return;
-
-    if (xswi(OS_File, 16, "<Wimp$Scrap>", buffer, 0) & v_flag)
-	return;
-
-    clip_yank_selection(MCHAR, buffer, length, cbd);
-
-    vim_free(buffer);
-
-    swi(OS_FSControl, 27, "<Wimp$Scrap>", 0, 0);    /* Delete temp file. */
-
-    block[4] = 4;		    /* Send DataLoadAck. */
-    block[3] = block[2];	    /* Copy myref -> yourref. */
-    swi(Wimp_SendMessage, 17, block, block[1]);
-}
-
-/* Not sure what this means under RISC OS. */
-    void
-clip_mch_lose_selection(VimClipboard *cbd)
-{
-}
-
-/* Tell everyone that we now own the clipboard.
- * Return OK if our claim is accepted (always, under RISC OS)
- */
-    int
-clip_mch_own_selection(VimClipboard *cbd)
-{
-    int block[6];
-    block[0] = 24;	/* Length of block.  */
-    block[3] = 0;	/* Original message. */
-    block[4] = 0xf;	/* ClaimEntity. */
-    block[5] = 0x4;	/* Claim clipboard only. */
-    swi(Wimp_SendMessage, 17, block, 0);
-    return OK;
-}
-
-/*
- * Send the current selection to the clipboard.  Do nothing for X because we
- * will fill in the selection only when requested by another app. Sounds good
- * for RISC OS too.
- */
-    void
-clip_mch_set_selection(VimClipboard *cbd)
-{
-    clip_get_selection(cbd);
-}
-
-/*
- * Make a menu either grey or not grey.
- */
-    void
-gui_mch_menu_grey(vimmenu_T *menu, int grey)
-{
-    menu-> greyed_out = grey;
-}
-
-/*
- * Make menu item hidden or not hidden
- */
-    void
-gui_mch_menu_hidden(vimmenu_T *menu, int hidden)
-{
-    menu-> hidden = hidden;
-}
-
-/*
- * This is called after setting all the menus to grey/hidden or not.
- */
-    void
-gui_mch_draw_menubar(void)
-{
-    swi(Wimp_CreateMenu, 0, -1);
-    if (wimp_menu != (int *) -1)
-    {
-	ro_remove_menu(wimp_menu);
-	wimp_menu = (int *) -1;
-    }
-}
-
-/* Add or remove a scrollbar. Note that this is only called when
- * the scrollbar state is changing.
- * The scroll bar window has already been created.
- * We can't do anything except remove the scroll bar
- * until we know what size to use.
- */
-    void
-gui_mch_enable_scrollbar(sb, flag)
-    scrollbar_T	*sb;
-    int		flag;
-{
-    if (!flag)
-	swi(Wimp_CloseWindow, 0, & (sb->id) );
-    return;
-}
-
-    void
-gui_mch_set_blinking(long waittime, long on, long off)
-{
-}
-
-/*
- * Stop the cursor blinking.  Show the cursor if it wasn't shown.
- */
-    void
-gui_mch_stop_blink(void)
-{
-}
-
-/*
- * Start the cursor blinking.  If it was already blinking, this restarts the
- * waiting time and shows the cursor.
- */
-    void
-gui_mch_start_blink(void)
-{
-}
-
-/*
- * Return the RGB value of a pixel as a long.
- */
-    long_u
-gui_mch_get_rgb(guicolor_T pixel)
-{
-    return (long_u)pixel;
-}
-
-    void
-gui_mch_set_text_area_pos(int x, int y, int w, int h)
-{
-}
-
-    void
-gui_mch_enable_menu(int flag)
-{
-}
-
-    void
-gui_mch_set_menu_pos(int x, int y, int w, int h)
-{
-}
-
-    void
-gui_mch_add_menu(vimmenu_T *menu, int idx)
-{
-}
-
-    void
-gui_mch_add_menu_item(vimmenu_T *menu, int idx)
-{
-}
-
-    void
-gui_mch_new_menu_colors(void)
-{
-}
-
-    void
-gui_mch_destroy_menu(vimmenu_T *menu)
-{
-}
-
-/* Size of buffer has changed.
- * Add one to max since gui.c subtracts one more than it should!
- */
-    void
-gui_mch_set_scrollbar_thumb(sb, val, size, max)
-    scrollbar_T	*sb;
-    long	val;
-    long	size;
-    long	max;
-{
-    int		block[10], width, height;
-
-    width = (max + 1) * gui.char_width;
-    height = (max + 1 + W_STATUS_HEIGHT(sb->wp)) * gui.char_height;
-
-    block[0] = block[3] = 0;
-    block[1] = -height + (1 << y_eigen_factor);
-    block[2] = width;
-
-    swi(Wimp_SetExtent, sb -> id, block);
-
-    block[0] = sb -> id;
-    swi(Wimp_GetWindowState, 0, block);
-    block[5] = val * gui.char_width;
-    block[6] = -val * gui.char_height;
-    swi(Wimp_OpenWindow, 0, block, 0x4b534154,
-			gui.window_handle,	/* Parent window handle. */
-			(CHILD_FIX_TO_RIGHT  << CHILD_LEFT  )   |
-			(CHILD_FIX_TO_RIGHT  << CHILD_RIGHT )   |
-			(CHILD_FIX_TO_BOTTOM << CHILD_TOP   )   |
-			(CHILD_FIX_TO_BOTTOM << CHILD_BOTTOM)   |
-			(CHILD_SELF_SCROLL   << CHILD_SCROLL_X) |
-			(CHILD_SELF_SCROLL   << CHILD_SCROLL_Y)
-			);
-}
-
-/* Set the position of the scrollbar within the editor
- * window. Note that, for vertical scrollbars, x and w
- * are ignored. For horizontal bars y and h are ignored.
- */
-    void
-gui_mch_set_scrollbar_pos(sb, x, y, w, h)
-    scrollbar_T *sb;
-    int		x;		/* Horizontal sb position */
-    int		y;		/* Top of scroll bar */
-    int		w;		/* Width */
-    int		h;		/* Height */
-{
-    int		block[24];
-    int		px1, py1;	/* Parent window min coords */
-    int		px2, py2;	/* Parent window max coords */
-
-    /* Find where the parent window is. */
-    block[0] = gui.window_handle;
-    swi(Wimp_GetWindowState, 0, block);
-    px1 = block[1];
-    py1 = block[2];
-    px2 = block[3];
-    py2 = block[4];
-
-    block[0] = sb -> id;
-
-    /* Find out how big the scroll window is at the moment. */
-    swi(Wimp_GetWindowInfo, 0, ((char_u *)block) + 1);
-
-    if (block[13] < w || block[12] > -h)
-    {
-	/* Current window is too small! */
-	if (block[12] > -h)
-	    block[12] = -h;
-	if (block[13] < w)
-	    block[13] = w;
-	swi(Wimp_SetExtent, block[0], block + 11);
-    }
-
-    /* This works better on the nested_wimp. */
-    if (sb-> wp)
-    {
-	/* This is a vertical scrollbar. */
-	block[1] = block[3] = px2 - gui.scrollbar_width + (1 << x_eigen_factor);
-	block[2] = 1 + py2 - (y + h) + (1 << y_eigen_factor);
-	block[4] = 1 + py2 - y;
-    }
-    else
-    {
-	/* This is a horizontal scrollbar. */
-	block[2] = block[4] = py1 + gui.scrollbar_height;
-	block[1] = px1;
-	block[3] = px2 - gui.scrollbar_width;
-    }
-
-    block[5] = 0;
-    block[6] = 0;
-    block[7] = -1;
-
-    swi(Wimp_OpenWindow, 0, block, 0x4b534154,
-	    gui.window_handle,	/* Parent window handle. */
-	    (CHILD_FIX_TO_RIGHT  << CHILD_LEFT  )   |
-	    (CHILD_FIX_TO_RIGHT  << CHILD_RIGHT )   |
-	    (CHILD_FIX_TO_BOTTOM << CHILD_TOP   )   |
-	    (CHILD_FIX_TO_BOTTOM << CHILD_BOTTOM)   |
-	    (CHILD_SELF_SCROLL   << CHILD_SCROLL_X) |
-	    (CHILD_SELF_SCROLL   << CHILD_SCROLL_Y)
-       );
-}
-
-/* Create a window with no workarea to place inside editor window.
- * (what happens without the nested wimp?)
- * Data for scrollbar is invalid.
- */
-    void
-gui_mch_create_scrollbar(sb, orient)
-    scrollbar_T *sb;
-    int		orient;	/* orient is SBAR_HORIZ or SBAR_VERT */
-{
-    int bar[] =
-	{
-	    0,   0,		/* Visible area : min X,Y */
-	    100, 100,		/*		  max X,Y */
-	    0,   0,		/* Scroll offsets */
-	    -1,			/* Window in front */
-	    0x80800150 | (orient == SBAR_HORIZ ? (1 << 30) : (1 << 28)),
-	    0xff070207,		/* Colours */
-	    0x000c0103,		/* More colours */
-	    0, -0x4000,		/* Workarea extent */
-	    0x4000, 0,		/* max X,Y */
-	    0x00000000,		/* No title */
-	    0 << 12,		/* No workarea button type */
-	    1,			/* Wimp sprite area */
-	    0x00010001,		/* Minimum width, height */
-	    0, 0, 0,		/* Title data (none) */
-	    0			/* No icons */
-	};
-    swi(Wimp_CreateWindow, 0, bar);
-    sb -> id = r0;
-}
-
-#if defined(FEAT_WINDOWS) || defined(PROTO)
-    void
-gui_mch_destroy_scrollbar(scrollbar_T *sb)
-{
-    swi(Wimp_DeleteWindow, 0, & (sb->id));
-    sb -> id = -1;
-}
-#endif
-
-    void
-gui_mch_set_scrollbar_colors(scrollbar_T *sb)
-{
-    /* Always use default RO colour scheme. */
-}
-
-/*
- * Get current mouse coordinates in text window.
- * Note: (0,0) is the bottom left corner, positive y is UP.
- */
-    void
-gui_mch_getmouse(x, y)
-    int *x;
-    int *y;
-{
-    int left;
-    int top;
-    int block[10];
-
-    block[0] = gui.window_handle;
-    swi(Wimp_GetWindowState, 0, block);
-    left = block[1];
-    top = block[4];
-
-    swi(Wimp_GetPointerInfo, 0, block);
-    *x = block[0] - left;
-    *y = top - block[1];
-}
-
-/* MouseTo(x, y) */
-    void
-gui_mch_setmouse(x, y)
-    int		x;
-    int		y;
-{
-}
-
-    void
-gui_mch_toggle_tearoffs(enable)
-    int		enable;
-{
-    /* no tearoff menus */
-}
-
-/* Redraw a window's title.
- * For the nested wimp we use the new 'redraw-title-bar' reason code.
- * For older wimps we mark the area of the screen where the title bar
- * is as invalid.
- */
-    void
-ro_redraw_title(window)
-    int window;
-{
-    if (nested_wimp)
-    {
-	swi(Wimp_ForceRedraw, window, 0x4b534154, 3);
-    }
-    else
-    {
-	int block[10];
-	int miny;
-
-	block[0] = window;
-	swi(Wimp_GetWindowState, 0, block);
-	miny = block[4];
-	swi(Wimp_GetWindowOutline, 0, block);
-	swi(Wimp_ForceRedraw, -1,
-			block[1], miny,
-			block[3], block[4]);
-    }
-}
-
-/* Turn a vimmenu_T structure into a wimp menu structure.
- * -1 if resulting menu is empty.
- * Only the children and dname items in the root menu are used.
- */
-    int *
-ro_build_menu(menu)
-    vimmenu_T	*menu;
-{
-    int		*wimp_menu;
-    int		width = 4;
-    int		w;
-    int		size = 28;
-    vimmenu_T	*item;
-    int		*wimp_item;
-
-    /* Find out how big the menu is so we can allocate memory for it */
-    for (item = menu-> children; item; item = item-> next)
-    {
-	if (item-> hidden == FALSE && !menu_is_separator(item->name))
-	    size += 24;
-    }
-
-    if (size <= 28)
-	return (int *) -1;		/* No children - shouldn't happen */
-
-    wimp_menu = (int *) alloc(size);
-
-    wimp_menu[0] = (int) menu-> dname;
-    wimp_menu[1] = -1;
-    wimp_menu[2] = 0;
-    wimp_menu[3] = 0x00070207;
-    wimp_menu[5] = 44;
-    wimp_menu[6] = 0;
-
-    wimp_item = wimp_menu + 7;
-
-    for (item = menu-> children; item; item = item-> next)
-    {
-	if (menu_is_separator(item-> name))
-	{
-	    /* This menu entry is actually a separator. If it is not the first
-	     * menu entry then mark the previous menu item as needing a dotted
-	     * line after it.
-	     */
-	    if (wimp_item > wimp_menu + 7)
-		wimp_item[-6] |= 0x2;
-	}
-	else if (item-> hidden == FALSE)
-	{
-	    wimp_item[0] = 0;
-	    wimp_item[1] = item-> children ? (int) ro_build_menu(item) : -1;
-	    wimp_item[2] = 0x07009131 | (item-> greyed_out << 22);
-	    wimp_item[3] = (int) item-> dname;
-	    wimp_item[4] = -1;
-	    wimp_item[5] = (int) item;  /* Stuff the menu address in this unused space */
-
-	    w = strlen(item-> dname) + 1;
-	    if (w > width)
-		width = w;
-	    wimp_item += 6;
-	}
-    }
-
-    wimp_menu[4] = (width + 2) * 16;
-    wimp_menu[7]  |= 0x100;	    /* Menu title is indirected */
-    wimp_item[-6] |= 0x080;	    /* Last entry in menu */
-    return wimp_menu;
-}
-
-    static void
-ro_remove_menu(menu)
-    int	    *menu;
-{
-    int	    *item = menu + 7;
-
-    if (menu == NULL || menu == (int *) -1)
-	return;
-
-    for (;;)
-    {
-	if (item[1] != -1)
-	    ro_remove_menu((int *) item[1]);	/* Remove sub-menu */
-	if (item[0] & 0x80)
-	    break;			/* This was the last entry */
-	item += 6;
-    }
-    vim_free(menu);
-}
-
-    void
-gui_mch_show_popupmenu(menu)
-    vimmenu_T	*menu;
-{
-    int		block[10];
-
-    /* Remove the existing menu, if any */
-    if (wimp_menu != (int *) -1)
-    {
-	swi(Wimp_CreateMenu, 0, -1);
-	ro_remove_menu(wimp_menu);
-	wimp_menu = (int *) -1;
-    }
-
-    wimp_menu = ro_build_menu(menu);
-    if (wimp_menu != (int *) -1)
-    {
-	swi(Wimp_GetPointerInfo, 0, block);
-	swi(Wimp_CreateMenu, 0, wimp_menu, block[0] - 64, block[1] + 64);
-    }
-}
-
-/* Run a command using the TaskWindow module.
- * If SHELL_FILTER is set then output is not echoed to the screen,
- * If it is not set, then \r is not sent to the output file.
- */
-    int
-gui_mch_call_shell(cmd, options)
-    char_u  *cmd;
-    int	    options;	/* SHELL_FILTER if called by do_filter() */
-			/* SHELL_COOKED if term needs cooked mode */
-{
-    char_u  task_cmd[256];	/* Contains *TaskWindow command. */
-    int	    block[64];
-    int	    reason;
-    char_u  *out;
-    char_u  c;
-    int	    old_msg_col;
-    char_u  *out_redir;
-    int	    length;
-    FILE    *out_file = NULL;
-
-    out_redir = strstr(cmd, " > ");
-    if (out_redir == NULL)
-	length = strlen(cmd);	/* No redirection. */
-    else
-    {
-	length = out_redir - cmd;
-	out_file = fopen(out_redir + 3, "wb");
-	if (out_file == NULL)
-	    smsg("WARNING : Can't open file %s for writing\n", out_redir + 3);
-    }
-
-    if (length > 180)
-    {
-	if (out_file)
-	    fclose(out_file);
-	return FAIL;		/* Command too long. */
-    }
-
-    strcpy(task_cmd, "TaskWindow \"");
-    strncpy(task_cmd + 12, cmd, length);
-    sprintf(task_cmd + 12 + length,
-	    "\" -task &%08x -ctrl -quit -name \"Vim command\"",
-	    task_handle);
-
-    if (options & SHELL_COOKED)
-	settmode(TMODE_COOK);
-
-    if (xswi(Wimp_StartTask, task_cmd) & v_flag)
-    {
-	/* Failed to even start a new task (out of memory?) */
-	settmode(TMODE_RAW);
-	if (out_file)
-	    fclose(out_file);
-	return FAIL;
-    }
-
-    /* Wait for the child process to initialise. */
-    child_handle = 0;
-    while (!child_handle)
-    {
-	reason = wimp_poll(0, block);
-	if ((reason == 17 || reason == 18) && block[4] == 0x808c2)
-	    child_handle = block[1];
-	else
-	    process_event(reason, block);
-    }
-
-    /* Block until finished */
-    while (child_handle)
-    {
-	reason = wimp_poll(1, block);
-	if (reason == 3 || (reason == 8 && block[6] == 3))
-	{
-	    /* Close window request or CTRL-C - kill child task. */
-	    block[0] = 20;
-	    block[3] = 0;
-	    block[4] = 0x808c4;	    /* Morite */
-	    swi(Wimp_SendMessage, 17, block, child_handle);
-	    MSG_PUTS(_("\nSending message to terminate child process.\n"));
-	    continue;
-	}
-	else if (reason == 8)
-	{
-	    block[0] = 28;
-	    block[3] = 0;
-	    block[4] = 0x808c0;	    /* Input */
-	    block[5] = 1;
-	    /* Block[6] is OK as it is! */
-	    swi(Wimp_SendMessage, 17, block, child_handle);
-	    continue;
-	}
-	else if (reason == 17 || reason == 18)
-	{
-	    if (block[4] == 0x808c1)
-	    {
-		/* Ack message. */
-		block[3] = block[2];
-		swi(Wimp_SendMessage, 19, block, block[1]);
-		out = (char_u *)block + 24;
-		old_msg_col = msg_col;
-		while (block[5]--)
-		{
-		    c = *out++;
-		    if (out_file && (c != '\r' || (options & SHELL_FILTER)))
-			fputc(c, out_file);
-		    if ((options & SHELL_FILTER) == 0)
-		    {
-			if (c == 127)
-			    msg_puts("\b \b");
-			else if (c > 31)
-			    msg_putchar(c);
-			else if (c == 10)
-			{
-			    lines_left = 8;	/* Don't do More prompt! */
-			    msg_putchar(10);
-			}
-		    }
-		}
-		/* Flush output to the screen. */
-		windgoto(msg_row, msg_col);
-		out_flush();
-		continue;
-	    }
-	}
-	process_event(reason, block);
-    }
-    msg_putchar('\n');
-    settmode(TMODE_RAW);
-    if (out_file)
-	fclose(out_file);
-    return OK;
-}
-
-/* Like strsave(), but stops at any control char */
-    char_u *
-wimp_strsave(str)
-    char    *str;
-{
-    int	    strlen = 0;
-    char_u  *retval;
-    while (str[strlen] > 31)
-	strlen++;
-    retval = alloc(strlen + 1);
-    if (retval)
-    {
-	memcpy(retval, str, strlen);
-	retval[strlen] = '\0';
-    }
-    return retval;
-}
-
-/* If we are saving then pop up a standard RISC OS save box.
- * Otherwise, open a directory viewer on the given directory (and return NULL)
- * The string we return will be freed later.
- */
-    char_u *
-gui_mch_browse(saving, title, dflt, ext, initdir, filter)
-    int		saving;		/* write action */
-    char_u	*title;		/* title for the window */
-    char_u	*dflt;		/* default file name */
-    char_u	*ext;		/* extension added */
-    char_u	*initdir;	/* initial directory, NULL for current dir */
-    char_u	*filter;	/* file name filter */
-{
-    char command[256];
-    int length;
-
-    if (saving)
-    {
-	int	block[64];
-	int	reason;
-	int	done_save = FALSE;
-	char_u	*retval = NULL;
-	char_u  *sprname;
-	char_u	*fname;
-	int	dragging_icon = FALSE;
-	int	filetype;
-
-	if (!dflt)
-	    dflt = "TextFile";
-
-	block[0] = save_window;
-	block[1] = 0;
-	swi(Wimp_GetIconState, 0, block);
-	sprname = ((char_u *) block[7]);
-	block[1] = 1;
-	swi(Wimp_GetIconState, 0, block);
-	fname = ((char *) block[7]);
-	strncpy(fname, dflt, 255);
-
-	if (xswi(OS_FSControl, 31, curbuf->b_p_oft) & v_flag)
-	{
-	    filetype = 0xfff;
-	    strcpy(sprname + 5, "xxx");
-	}
-	else
-	{
-	    filetype = r2;
-	    sprintf(sprname + 5, "%03x", filetype);
-	}
-
-	/* Open the save box */
-
-	swi(Wimp_GetPointerInfo, 0, block);
-	swi(Wimp_CreateMenu, 0, save_window, block[0] - 64, block[1] + 64);
-	swi(Wimp_SetCaretPosition, save_window, 1, 0, 0, -1, -1);
-
-	while (!done_save)
-	{
-	    reason = wimp_poll(1, block);
-	    switch (reason)
-	    {
-		case 1:
-		    redraw_window(block);
-		    break;
-		case 2:
-		    if (block[0] == save_window)
-			swi(Wimp_OpenWindow, 0, block);
-		    else
-			ro_open_window(block);
-		    break;
-		case 3:
-		    done_save = TRUE;
-		    break;
-		case 6:
-		    if (block[3] != save_window)
-			done_save = TRUE;
-		    else
-		    {
-			int drag_box[4];
-			int min_x, max_y;
-
-			switch (block[4])
-			{
-			    case    0: /* Start drag */
-				block[0] = save_window;
-				swi(Wimp_GetWindowState, 0, block);
-				min_x = block[1];
-				max_y = block[4];
-				block[1] = 0;
-				swi(Wimp_GetIconState, 0, block);
-				drag_box[0] = block[2] + min_x;
-				drag_box[1] = block[3] + max_y;
-				drag_box[2] = block[4] + min_x;
-				drag_box[3] = block[5] + max_y;
-
-				swi(DragASprite_Start,
-					0x45,
-					1,
-					sprname,
-					drag_box);
-				dragging_icon = TRUE;
-				break;
-			    case    2: /* OK */
-				retval = wimp_strsave(fname);
-				done_save = TRUE;
-				break;
-			    case    3: /* Cancel */
-				done_save = TRUE;
-				break;
-			}
-		    }
-		    break;
-		case 7:
-		    if (dragging_icon)
-		    {
-			int len = 0;
-
-			dragging_icon = FALSE;
-			swi(Wimp_GetPointerInfo, 0, block);
-			block[5] = block[3];
-			block[6] = block[4];
-			block[7] = block[0];
-			block[8] = block[1];
-			block[9] = 0;		/* Don't know the size */
-			block[10] = filetype;
-
-			while (fname[len] > 31)
-			{
-			    if (fname[len] == '.')
-			    {
-				fname += len + 1;
-				len = 0;
-			    }
-			    else
-				len++;
-			}
-			if (len > 211)
-			    len = 211;
-
-			memcpy(((char_u *) block) + 44, fname, len);
-			((char_u *)block)[44 + len] = '\0';
-
-			block[0] = (len + 48) & 0xfc;
-			block[3] = 0;
-			block[4] = 1;	    /* DataSave */
-
-			swi(Wimp_SendMessage, 17, block, block[5], block[6]);
-		    }
-		    else
-			ro_drag_finished(block);
-		    break;
-		case 8:
-		    if (block[6] == 13)
-		    {
-			retval = wimp_strsave(fname);
-			done_save = TRUE;
-		    }
-		    else if (block[6] == 0x1b)
-			done_save = TRUE;
-		    else
-			swi(Wimp_ProcessKey, block[6]);
-		    break;
-		case 17:
-		case 18:
-		    if (block[4] == 2 && block[9] != -1)
-		    {
-			/* DataSaveAck from dragging icon. */
-			retval = wimp_strsave(((char_u *) block) + 44);
-			done_save = TRUE;
-		    }
-		    else if (block[4] == 0x400c9)
-		    {
-			/* MenusDeleted */
-			done_save = TRUE;
-		    }
-		    else
-			ro_message(block);
-		    break;
-	    }
-	}
-	block[0] = save_window;
-	swi(Wimp_CloseWindow, 0, block);
-	swi(Wimp_GetCaretPosition, 0, block);
-	if (block[0] == -1)
-	    swi(Wimp_SetCaretPosition, gui.window_handle, -1, 0, 0, -1, -1);
-
-	return retval;
-    }
-    else if (initdir)
-    {
-	/* Open a directory viewer */
-	length = strlen(initdir);
-
-	if (length > 240)
-	    return NULL;	/* Path too long! */
-
-	length = sprintf(command, "Filer_OpenDir %s", initdir);
-	while (command[length - 1] == '.')
-	    length--;
-	command[length] = '\0';
-	swi(OS_CLI, command);
-    }
-    return NULL;
-}
diff -Naur vim73.orig/src/gui_riscos.h vim73/src/gui_riscos.h
--- vim73.orig/src/gui_riscos.h	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/gui_riscos.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,32 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- */
-
-#define FEAT_BROWSE
-
-#define TASK 0x4b534154
-
-/* Nested wimp flags: */
-#define CHILD_FIX_TO_WORKAREA	0
-#define CHILD_FIX_TO_LEFT	1
-#define CHILD_FIX_TO_BOTTOM	1
-#define CHILD_FIX_TO_RIGHT	2
-#define CHILD_FIX_TO_TOP	2
-
-#define CHILD_SELF_SCROLL	0
-#define CHILD_PARENT_SCROLL	1
-
-#define CHILD_LEFT		16
-#define CHILD_BOTTOM		18
-#define CHILD_RIGHT		20
-#define CHILD_TOP		22
-#define CHILD_SCROLL_X		24
-#define CHILD_SCROLL_Y		26
-
-int wimp_poll(int mask, int *block);
-int wimp_poll_idle(int mask, int *block, int end_time);
-void ro_open_main(int *block);
diff -Naur vim73.orig/src/gui_w16.c vim73/src/gui_w16.c
--- vim73.orig/src/gui_w16.c	2010-07-18 13:03:38.000000000 +0000
+++ vim73/src/gui_w16.c	2011-05-17 09:36:14.489797147 +0000
@@ -1098,7 +1098,8 @@
     char_u	*message,
     char_u	*buttons,
     int		 dfltbutton,
-    char_u	*textfield)
+    char_u	*textfield,
+    int		ex_cmd)
 {
     FARPROC	dp;
     LPWORD	p, pnumitems;
diff -Naur vim73.orig/src/gui_w32.c vim73/src/gui_w32.c
--- vim73.orig/src/gui_w32.c	2010-08-08 13:05:26.000000000 +0000
+++ vim73/src/gui_w32.c	2011-05-17 09:36:14.489797147 +0000
@@ -289,13 +289,13 @@
 
 #ifdef FEAT_MENU
 static UINT	s_menu_id = 100;
+#endif
 
 /*
  * Use the system font for dialogs and tear-off menus.  Remove this line to
  * use DLG_FONT_NAME.
  */
-# define USE_SYSMENU_FONT
-#endif
+#define USE_SYSMENU_FONT
 
 #define VIM_NAME	"vim"
 #define VIM_CLASS	"Vim"
@@ -1260,7 +1260,7 @@
 
     /* try and load the user32.dll library and get the entry points for
      * multi-monitor-support. */
-    if ((user32_lib = LoadLibrary("User32.dll")) != NULL)
+    if ((user32_lib = vimLoadLib("User32.dll")) != NULL)
     {
 	pMonitorFromWindow = (TMonitorFromWindow)GetProcAddress(user32_lib,
 							 "MonitorFromWindow");
@@ -1573,6 +1573,11 @@
 # endif
 #endif
 
+#ifdef FEAT_EVAL
+    /* set the v:windowid variable */
+    set_vim_var_nr(VV_WINDOWID, (long)s_hwnd);
+#endif
+
 theend:
     /* Display any pending error messages */
     display_errors();
@@ -3000,7 +3005,8 @@
     char_u	*message,
     char_u	*buttons,
     int		 dfltbutton,
-    char_u	*textfield)
+    char_u	*textfield,
+    int		ex_cmd)
 {
     WORD	*p, *pdlgtemplate, *pnumitems;
     DWORD	*dwp;
@@ -4188,7 +4194,7 @@
     static void
 dyn_imm_load(void)
 {
-    hLibImm = LoadLibrary("imm32.dll");
+    hLibImm = vimLoadLib("imm32.dll");
     if (hLibImm == NULL)
 	return;
 
diff -Naur vim73.orig/src/gui_w48.c vim73/src/gui_w48.c
--- vim73.orig/src/gui_w48.c	2010-07-27 19:46:04.000000000 +0000
+++ vim73/src/gui_w48.c	2011-05-17 09:33:35.467447179 +0000
@@ -1810,7 +1810,8 @@
 		 * mapped we want to use the mapping instead. */
 		if (vk == VK_F10
 			&& gui.menu_is_active
-			&& check_map(k10, State, FALSE, TRUE, FALSE) == NULL)
+			&& check_map(k10, State, FALSE, TRUE, FALSE,
+							  NULL, NULL) == NULL)
 		    break;
 #endif
 		if (GetKeyState(VK_SHIFT) & 0x8000)
@@ -1924,7 +1925,8 @@
     /* Check for <F10>: Default effect is to select the menu.  When <F10> is
      * mapped we need to stop it here to avoid strange effects (e.g., for the
      * key-up event) */
-    if (vk != VK_F10 || check_map(k10, State, FALSE, TRUE, FALSE) == NULL)
+    if (vk != VK_F10 || check_map(k10, State, FALSE, TRUE, FALSE,
+							  NULL, NULL) == NULL)
 #endif
 	DispatchMessage(&msg);
 }
diff -Naur vim73.orig/src/gui_x11.c vim73/src/gui_x11.c
--- vim73.orig/src/gui_x11.c	2010-08-08 13:05:45.000000000 +0000
+++ vim73/src/gui_x11.c	2011-05-17 09:34:37.612549577 +0000
@@ -2895,6 +2895,11 @@
 	    focus = gui.in_focus;
 	}
 
+#if defined(FEAT_NETBEANS_INTG)
+	/* Process any queued netbeans messages. */
+	netbeans_parse_messages();
+#endif
+
 	/*
 	 * Don't use gui_mch_update() because then we will spin-lock until a
 	 * char arrives, instead we use XtAppProcessEvent() to hang until an
diff -Naur vim73.orig/src/gui_xmdlg.c vim73/src/gui_xmdlg.c
--- vim73.orig/src/gui_xmdlg.c	2010-06-26 03:53:50.000000000 +0000
+++ vim73/src/gui_xmdlg.c	2011-05-17 09:36:14.477798479 +0000
@@ -688,7 +688,7 @@
 	    do_dialog(VIM_ERROR,
 		    (char_u *)_("Error"),
 		    (char_u *)_("Invalid font specification"),
-		    (char_u *)_("&Dismiss"), 1, NULL);
+		    (char_u *)_("&Dismiss"), 1, NULL, FALSE);
 
 	return True;
     }
@@ -807,7 +807,7 @@
 	do_dialog(VIM_ERROR,
 		(char_u *)_("Error"),
 		(char_u *)_("Invalid font specification"),
-		(char_u *)_("&Dismiss"), 1, NULL);
+		(char_u *)_("&Dismiss"), 1, NULL, FALSE);
 	XFreeFontNames(name);
     }
     else
diff -Naur vim73.orig/src/hardcopy.c vim73/src/hardcopy.c
--- vim73.orig/src/hardcopy.c	2010-07-31 14:10:59.000000000 +0000
+++ vim73/src/hardcopy.c	2011-05-17 09:38:29.890769275 +0000
@@ -1759,18 +1759,25 @@
     char	*name;
     struct prt_ps_resource_S *resource;
 {
-    char_u	buffer[MAXPATHL + 1];
+    char_u	*buffer;
+    int		retval;
 
-    STRCPY(resource->name, name);
+    buffer = alloc(MAXPATHL + 1);
+    if (buffer == NULL)
+	return FALSE;
+
+    vim_strncpy(resource->name, (char_u *)name, 63);
     /* Look for named resource file in runtimepath */
     STRCPY(buffer, "print");
     add_pathsep(buffer);
-    STRCAT(buffer, name);
-    STRCAT(buffer, ".ps");
+    vim_strcat(buffer, (char_u *)name, MAXPATHL);
+    vim_strcat(buffer, (char_u *)".ps", MAXPATHL);
     resource->filename[0] = NUL;
-    return (do_in_runtimepath(buffer, FALSE, prt_resource_name,
+    retval = (do_in_runtimepath(buffer, FALSE, prt_resource_name,
 							   resource->filename)
 	    && resource->filename[0] != NUL);
+    vim_free(buffer);
+    return retval;
 }
 
 /* PS CR and LF characters have platform independent values */
@@ -2848,15 +2855,33 @@
     double      right;
     double      top;
     double      bottom;
-    struct prt_ps_resource_S res_prolog;
-    struct prt_ps_resource_S res_encoding;
+    struct prt_ps_resource_S *res_prolog;
+    struct prt_ps_resource_S *res_encoding;
     char	buffer[256];
     char_u      *p_encoding;
     char_u	*p;
 #ifdef FEAT_MBYTE
-    struct prt_ps_resource_S res_cidfont;
-    struct prt_ps_resource_S res_cmap;
+    struct prt_ps_resource_S *res_cidfont;
+    struct prt_ps_resource_S *res_cmap;
+#endif
+    int		retval = FALSE;
+
+    res_prolog = (struct prt_ps_resource_S *)
+				      alloc(sizeof(struct prt_ps_resource_S));
+    res_encoding = (struct prt_ps_resource_S *)
+				      alloc(sizeof(struct prt_ps_resource_S));
+#ifdef FEAT_MBYTE
+    res_cidfont = (struct prt_ps_resource_S *)
+				      alloc(sizeof(struct prt_ps_resource_S));
+    res_cmap = (struct prt_ps_resource_S *)
+				      alloc(sizeof(struct prt_ps_resource_S));
+#endif
+    if (res_prolog == NULL || res_encoding == NULL
+#ifdef FEAT_MBYTE
+	    || res_cidfont == NULL || res_cmap == NULL
 #endif
+       )
+	goto theend;
 
     /*
      * PS DSC Header comments - no PS code!
@@ -2932,27 +2957,27 @@
 #endif
 
     /* Search for external resources VIM supplies */
-    if (!prt_find_resource("prolog", &res_prolog))
+    if (!prt_find_resource("prolog", res_prolog))
     {
 	EMSG(_("E456: Can't find PostScript resource file \"prolog.ps\""));
 	return FALSE;
     }
-    if (!prt_open_resource(&res_prolog))
+    if (!prt_open_resource(res_prolog))
 	return FALSE;
-    if (!prt_check_resource(&res_prolog, PRT_PROLOG_VERSION))
+    if (!prt_check_resource(res_prolog, PRT_PROLOG_VERSION))
 	return FALSE;
 #ifdef FEAT_MBYTE
     if (prt_out_mbyte)
     {
 	/* Look for required version of multi-byte printing procset */
-	if (!prt_find_resource("cidfont", &res_cidfont))
+	if (!prt_find_resource("cidfont", res_cidfont))
 	{
 	    EMSG(_("E456: Can't find PostScript resource file \"cidfont.ps\""));
 	    return FALSE;
 	}
-	if (!prt_open_resource(&res_cidfont))
+	if (!prt_open_resource(res_cidfont))
 	    return FALSE;
-	if (!prt_check_resource(&res_cidfont, PRT_CID_PROLOG_VERSION))
+	if (!prt_check_resource(res_cidfont, PRT_CID_PROLOG_VERSION))
 	    return FALSE;
     }
 #endif
@@ -2968,7 +2993,7 @@
 #endif
 	p_encoding = enc_skip(p_penc);
 	if (*p_encoding == NUL
-		|| !prt_find_resource((char *)p_encoding, &res_encoding))
+		|| !prt_find_resource((char *)p_encoding, res_encoding))
 	{
 	    /* 'printencoding' not set or not supported - find alternate */
 #ifdef FEAT_MBYTE
@@ -2977,13 +3002,13 @@
 	    p_encoding = enc_skip(p_enc);
 	    props = enc_canon_props(p_encoding);
 	    if (!(props & ENC_8BIT)
-		    || !prt_find_resource((char *)p_encoding, &res_encoding))
+		    || !prt_find_resource((char *)p_encoding, res_encoding))
 		/* 8-bit 'encoding' is not supported */
 #endif
 		{
 		/* Use latin1 as default printing encoding */
 		p_encoding = (char_u *)"latin1";
-		if (!prt_find_resource((char *)p_encoding, &res_encoding))
+		if (!prt_find_resource((char *)p_encoding, res_encoding))
 		{
 		    EMSG2(_("E456: Can't find PostScript resource file \"%s.ps\""),
 			    p_encoding);
@@ -2991,7 +3016,7 @@
 		}
 	    }
 	}
-	if (!prt_open_resource(&res_encoding))
+	if (!prt_open_resource(res_encoding))
 	    return FALSE;
 	/* For the moment there are no checks on encoding resource files to
 	 * perform */
@@ -3005,13 +3030,13 @@
 	if (prt_use_courier)
 	{
 	    /* Include ASCII range encoding vector */
-	    if (!prt_find_resource(prt_ascii_encoding, &res_encoding))
+	    if (!prt_find_resource(prt_ascii_encoding, res_encoding))
 	    {
 		EMSG2(_("E456: Can't find PostScript resource file \"%s.ps\""),
 							  prt_ascii_encoding);
 		return FALSE;
 	    }
-	    if (!prt_open_resource(&res_encoding))
+	    if (!prt_open_resource(res_encoding))
 		return FALSE;
 	    /* For the moment there are no checks on encoding resource files to
 	     * perform */
@@ -3034,44 +3059,44 @@
     if (prt_out_mbyte && prt_custom_cmap)
     {
 	/* Find user supplied CMap */
-	if (!prt_find_resource(prt_cmap, &res_cmap))
+	if (!prt_find_resource(prt_cmap, res_cmap))
 	{
 	    EMSG2(_("E456: Can't find PostScript resource file \"%s.ps\""),
 								    prt_cmap);
 	    return FALSE;
 	}
-	if (!prt_open_resource(&res_cmap))
+	if (!prt_open_resource(res_cmap))
 	    return FALSE;
     }
 #endif
 
     /* List resources supplied */
-    STRCPY(buffer, res_prolog.title);
+    STRCPY(buffer, res_prolog->title);
     STRCAT(buffer, " ");
-    STRCAT(buffer, res_prolog.version);
+    STRCAT(buffer, res_prolog->version);
     prt_dsc_resources("DocumentSuppliedResources", "procset", buffer);
 #ifdef FEAT_MBYTE
     if (prt_out_mbyte)
     {
-	STRCPY(buffer, res_cidfont.title);
+	STRCPY(buffer, res_cidfont->title);
 	STRCAT(buffer, " ");
-	STRCAT(buffer, res_cidfont.version);
+	STRCAT(buffer, res_cidfont->version);
 	prt_dsc_resources(NULL, "procset", buffer);
 
 	if (prt_custom_cmap)
 	{
-	    STRCPY(buffer, res_cmap.title);
+	    STRCPY(buffer, res_cmap->title);
 	    STRCAT(buffer, " ");
-	    STRCAT(buffer, res_cmap.version);
+	    STRCAT(buffer, res_cmap->version);
 	    prt_dsc_resources(NULL, "cmap", buffer);
 	}
     }
     if (!prt_out_mbyte || prt_use_courier)
 #endif
     {
-	STRCPY(buffer, res_encoding.title);
+	STRCPY(buffer, res_encoding->title);
 	STRCAT(buffer, " ");
-	STRCAT(buffer, res_encoding.version);
+	STRCAT(buffer, res_encoding->version);
 	prt_dsc_resources(NULL, "encoding", buffer);
     }
     prt_dsc_requirements(prt_duplex, prt_tumble, prt_collate,
@@ -3114,15 +3139,15 @@
     prt_dsc_noarg("BeginProlog");
 
     /* Add required procsets - NOTE: order is important! */
-    if (!prt_add_resource(&res_prolog))
+    if (!prt_add_resource(res_prolog))
 	return FALSE;
 #ifdef FEAT_MBYTE
     if (prt_out_mbyte)
     {
 	/* Add CID font procset, and any user supplied CMap */
-	if (!prt_add_resource(&res_cidfont))
+	if (!prt_add_resource(res_cidfont))
 	    return FALSE;
-	if (prt_custom_cmap && !prt_add_resource(&res_cmap))
+	if (prt_custom_cmap && !prt_add_resource(res_cmap))
 	    return FALSE;
     }
 #endif
@@ -3132,7 +3157,7 @@
 #endif
 	/* There will be only one Roman font encoding to be included in the PS
 	 * file. */
-	if (!prt_add_resource(&res_encoding))
+	if (!prt_add_resource(res_encoding))
 	    return FALSE;
 
     prt_dsc_noarg("EndProlog");
@@ -3248,7 +3273,17 @@
     prt_dsc_noarg("EndSetup");
 
     /* Fail if any problems writing out to the PS file */
-    return !prt_file_error;
+    retval = !prt_file_error;
+
+theend:
+    vim_free(res_prolog);
+    vim_free(res_encoding);
+#ifdef FEAT_MBYTE
+    vim_free(res_cidfont);
+    vim_free(res_cmap);
+#endif
+
+    return retval;
 }
 
     void
diff -Naur vim73.orig/src/if_cscope.c vim73/src/if_cscope.c
--- vim73.orig/src/if_cscope.c	2010-07-25 14:32:31.000000000 +0000
+++ vim73/src/if_cscope.c	2011-05-17 09:38:55.383939882 +0000
@@ -13,16 +13,10 @@
 
 #if defined(FEAT_CSCOPE) || defined(PROTO)
 
-#include <string.h>
-#include <errno.h>
-#include <assert.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #if defined(UNIX)
 # include <sys/wait.h>
-#else
-    /* not UNIX, must be WIN32 */
-# include "vimio.h"
 #endif
 #include "if_cscope.h"
 
@@ -1274,9 +1268,7 @@
 		{
 		    win_split(postponed_split > 0 ? postponed_split : 0,
 						       postponed_split_flags);
-#  ifdef FEAT_SCROLLBIND
-		    curwin->w_p_scb = FALSE;
-#  endif
+		    RESET_BINDING(curwin);
 		    postponed_split = 0;
 		}
 # endif
@@ -1353,7 +1345,7 @@
 		       "       g: Find this definition\n"
 		       "       i: Find files #including this file\n"
 		       "       s: Find this C symbol\n"
-		       "       t: Find assignments to\n"));
+		       "       t: Find this text string\n"));
 
 	cmdp++;
     }
@@ -1420,17 +1412,15 @@
 {
     short	i, j;
 #ifndef UNIX
-    HANDLE	hFile;
     BY_HANDLE_FILE_INFORMATION bhfi;
 
-    vim_memset(&bhfi, 0, sizeof(bhfi));
     /* On windows 9x GetFileInformationByHandle doesn't work, so skip it */
     if (!mch_windows95())
     {
-	hFile = CreateFile(fname, FILE_READ_ATTRIBUTES, 0, NULL, OPEN_EXISTING,
-						 FILE_ATTRIBUTE_NORMAL, NULL);
-	if (hFile == INVALID_HANDLE_VALUE)
+	switch (win32_fileinfo(fname, &bhfi))
 	{
+	case FILEINFO_ENC_FAIL:		/* enc_to_utf16() failed */
+	case FILEINFO_READ_FAIL:	/* CreateFile() failed */
 	    if (p_csverbose)
 	    {
 		char *cant_msg = _("E625: cannot open cscope database: %s");
@@ -1446,15 +1436,12 @@
 		    (void)EMSG2(cant_msg, fname);
 	    }
 	    return -1;
-	}
-	if (!GetFileInformationByHandle(hFile, &bhfi))
-	{
-	    CloseHandle(hFile);
+
+	case FILEINFO_INFO_FAIL:    /* GetFileInformationByHandle() failed */
 	    if (p_csverbose)
 		(void)EMSG(_("E626: cannot get cscope database information"));
 	    return -1;
 	}
-	CloseHandle(hFile);
     }
 #endif
 
@@ -1664,7 +1651,7 @@
 /*
  * PRIVATE: cs_make_vim_style_matches
  *
- * convert the cscope output into into a ctags style entry (as might be found
+ * convert the cscope output into a ctags style entry (as might be found
  * in a ctags tags file).  there's one catch though: cscope doesn't tell you
  * the type of the tag you are looking for.  for example, in Darren Hiebert's
  * ctags (the one that comes with vim), #define's use a line number to find the
diff -Naur vim73.orig/src/if_lua.c vim73/src/if_lua.c
--- vim73.orig/src/if_lua.c	2010-08-12 20:12:04.000000000 +0000
+++ vim73/src/if_lua.c	2011-05-17 09:36:12.098062605 +0000
@@ -9,12 +9,11 @@
  * See README.txt for an overview of the Vim source code.
  */
 
-#include <stdio.h>
-#include <string.h>
+#include "vim.h"
+
 #include <lua.h>
 #include <lualib.h>
 #include <lauxlib.h>
-#include "vim.h"
 
 /* Only do the following when the feature is enabled.  Needed for "make
  * depend". */
@@ -49,7 +48,7 @@
 # define symbol_from_dll dlsym
 # define close_dll dlclose
 #else
-# define load_dll LoadLibrary
+# define load_dll vimLoadLib
 # define symbol_from_dll GetProcAddress
 # define close_dll FreeLibrary
 #endif
diff -Naur vim73.orig/src/if_mzsch.c vim73/src/if_mzsch.c
--- vim73.orig/src/if_mzsch.c	2010-06-26 03:56:17.000000000 +0000
+++ vim73/src/if_mzsch.c	2011-05-17 09:34:14.935066585 +0000
@@ -556,8 +556,8 @@
 
     if (hMzGC && hMzSch)
 	return OK;
-    hMzSch = LoadLibrary(sch_dll);
-    hMzGC = LoadLibrary(gc_dll);
+    hMzSch = vimLoadLib(sch_dll);
+    hMzGC = vimLoadLib(gc_dll);
 
     if (!hMzSch)
     {
@@ -794,9 +794,16 @@
 #endif
 }
 
+#if MZSCHEME_VERSION_MAJOR >= 500 && defined(WIN32) && defined(USE_THREAD_LOCAL)
+static __declspec(thread) void *tls_space;
+#endif
+
     void
 mzscheme_main(void)
 {
+#if MZSCHEME_VERSION_MAJOR >= 500 && defined(WIN32) && defined(USE_THREAD_LOCAL)
+    scheme_register_tls_space(&tls_space, 0);
+#endif
 #if defined(MZ_PRECISE_GC) && MZSCHEME_VERSION_MAJOR >= 400
     /* use trampoline for precise GC in MzScheme >= 4.x */
     scheme_main_setup(TRUE, mzscheme_env_main, 0, NULL);
diff -Naur vim73.orig/src/if_perl.xs vim73/src/if_perl.xs
--- vim73.orig/src/if_perl.xs	2010-07-22 09:33:37.000000000 +0000
+++ vim73/src/if_perl.xs	2011-05-17 09:33:40.054938001 +0000
@@ -106,7 +106,7 @@
 #define close_dll dlclose
 #else
 #define PERL_PROC FARPROC
-#define load_dll LoadLibrary
+#define load_dll vimLoadLib
 #define symbol_from_dll GetProcAddress
 #define close_dll FreeLibrary
 #endif
diff -Naur vim73.orig/src/if_py_both.h vim73/src/if_py_both.h
--- vim73.orig/src/if_py_both.h	2010-08-08 11:06:29.000000000 +0000
+++ vim73/src/if_py_both.h	2011-05-17 09:37:45.435703211 +0000
@@ -33,7 +33,9 @@
 
 static PyObject *OutputWrite(PyObject *, PyObject *);
 static PyObject *OutputWritelines(PyObject *, PyObject *);
+static PyObject *OutputFlush(PyObject *, PyObject *);
 
+/* Function to write a line, points to either msg() or emsg(). */
 typedef void (*writefn)(char_u *);
 static void writer(writefn fn, char_u *str, PyInt n);
 
@@ -46,9 +48,10 @@
 
 static struct PyMethodDef OutputMethods[] = {
     /* name,	    function,		calling,    documentation */
-    {"write",	    OutputWrite,	1,	    "" },
-    {"writelines",  OutputWritelines,	1,	    "" },
-    { NULL,	    NULL,		0,	    NULL }
+    {"write",	    OutputWrite,	1,	    ""},
+    {"writelines",  OutputWritelines,	1,	    ""},
+    {"flush",       OutputFlush,        1,          ""},
+    { NULL,	    NULL,		0,	    NULL}
 };
 
 #define PyErr_SetVim(str) PyErr_SetString(VimError, str)
@@ -122,52 +125,28 @@
     return Py_None;
 }
 
-static char_u *buffer = NULL;
-static PyInt buffer_len = 0;
-static PyInt buffer_size = 0;
-
-static writefn old_fn = NULL;
-
-    static void
-buffer_ensure(PyInt n)
+    static PyObject *
+OutputFlush(PyObject *self UNUSED, PyObject *args UNUSED)
 {
-    PyInt new_size;
-    char_u *new_buffer;
-
-    if (n < buffer_size)
-	return;
-
-    new_size = buffer_size;
-    while (new_size < n)
-	new_size += 80;
-
-    if (new_size != buffer_size)
-    {
-	new_buffer = alloc((unsigned)new_size);
-	if (new_buffer == NULL)
-	    return;
+    /* do nothing */
+    Py_INCREF(Py_None);
+    return Py_None;
+}
 
-	if (buffer)
-	{
-	    memcpy(new_buffer, buffer, buffer_len);
-	    vim_free(buffer);
-	}
 
-	buffer = new_buffer;
-	buffer_size = new_size;
-    }
-}
+/* Buffer IO, we write one whole line at a time. */
+static garray_T io_ga = {0, 0, 1, 80, NULL};
+static writefn old_fn = NULL;
 
     static void
 PythonIO_Flush(void)
 {
-    if (old_fn && buffer_len)
+    if (old_fn != NULL && io_ga.ga_len > 0)
     {
-	buffer[buffer_len] = 0;
-	old_fn(buffer);
+	((char_u *)io_ga.ga_data)[io_ga.ga_len] = NUL;
+	old_fn((char_u *)io_ga.ga_data);
     }
-
-    buffer_len = 0;
+    io_ga.ga_len = 0;
 }
 
     static void
@@ -175,30 +154,34 @@
 {
     char_u *ptr;
 
-    if (fn != old_fn && old_fn != NULL)
+    /* Flush when switching output function. */
+    if (fn != old_fn)
 	PythonIO_Flush();
-
     old_fn = fn;
 
+    /* Write each NL separated line.  Text after the last NL is kept for
+     * writing later. */
     while (n > 0 && (ptr = memchr(str, '\n', n)) != NULL)
     {
 	PyInt len = ptr - str;
 
-	buffer_ensure(buffer_len + len + 1);
+	if (ga_grow(&io_ga, (int)(len + 1)) == FAIL)
+	    break;
 
-	memcpy(buffer + buffer_len, str, len);
-	buffer_len += len;
-	buffer[buffer_len] = 0;
-	fn(buffer);
+	mch_memmove(((char *)io_ga.ga_data) + io_ga.ga_len, str, (size_t)len);
+	((char *)io_ga.ga_data)[io_ga.ga_len + len] = NUL;
+	fn((char_u *)io_ga.ga_data);
 	str = ptr + 1;
 	n -= len + 1;
-	buffer_len = 0;
+	io_ga.ga_len = 0;
     }
 
-    /* Put the remaining text into the buffer for later printing */
-    buffer_ensure(buffer_len + n + 1);
-    memcpy(buffer + buffer_len, str, n);
-    buffer_len += n;
+    /* Put the remaining text into io_ga for later printing. */
+    if (n > 0 && ga_grow(&io_ga, (int)(n + 1)) == OK)
+    {
+	mch_memmove(((char *)io_ga.ga_data) + io_ga.ga_len, str, (size_t)n);
+	io_ga.ga_len += (int)n;
+    }
 }
 
 /***************/
diff -Naur vim73.orig/src/if_python.c vim73/src/if_python.c
--- vim73.orig/src/if_python.c	2010-08-13 13:59:41.000000000 +0000
+++ vim73/src/if_python.c	2011-05-17 09:37:52.482921058 +0000
@@ -102,7 +102,7 @@
 #  include <dlfcn.h>
 #  define FARPROC void*
 #  define HINSTANCE void*
-#  ifdef PY_NO_RTLD_GLOBAL
+#  if defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)
 #   define load_dll(n) dlopen((n), RTLD_LAZY)
 #  else
 #   define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)
@@ -110,7 +110,7 @@
 #  define close_dll dlclose
 #  define symbol_from_dll dlsym
 # else
-#  define load_dll LoadLibrary
+#  define load_dll vimLoadLib
 #  define close_dll FreeLibrary
 #  define symbol_from_dll GetProcAddress
 # endif
@@ -165,9 +165,11 @@
 # define PySys_SetObject dll_PySys_SetObject
 # define PySys_SetArgv dll_PySys_SetArgv
 # define PyType_Type (*dll_PyType_Type)
+# define PyType_Ready (*dll_PyType_Ready)
 # define Py_BuildValue dll_Py_BuildValue
 # define Py_FindMethod dll_Py_FindMethod
 # define Py_InitModule4 dll_Py_InitModule4
+# define Py_SetPythonHome dll_Py_SetPythonHome
 # define Py_Initialize dll_Py_Initialize
 # define Py_Finalize dll_Py_Finalize
 # define Py_IsInitialized dll_Py_IsInitialized
@@ -223,9 +225,11 @@
 static int(*dll_PySys_SetObject)(char *, PyObject *);
 static int(*dll_PySys_SetArgv)(int, char **);
 static PyTypeObject* dll_PyType_Type;
+static int (*dll_PyType_Ready)(PyTypeObject *type);
 static PyObject*(*dll_Py_BuildValue)(char *, ...);
 static PyObject*(*dll_Py_FindMethod)(struct PyMethodDef[], PyObject *, char *);
 static PyObject*(*dll_Py_InitModule4)(char *, struct PyMethodDef *, char *, PyObject *, int);
+static void(*dll_Py_SetPythonHome)(char *home);
 static void(*dll_Py_Initialize)(void);
 static void(*dll_Py_Finalize)(void);
 static int(*dll_Py_IsInitialized)(void);
@@ -303,6 +307,7 @@
     {"PySys_SetObject", (PYTHON_PROC*)&dll_PySys_SetObject},
     {"PySys_SetArgv", (PYTHON_PROC*)&dll_PySys_SetArgv},
     {"PyType_Type", (PYTHON_PROC*)&dll_PyType_Type},
+    {"PyType_Ready", (PYTHON_PROC*)&dll_PyType_Ready},
     {"Py_BuildValue", (PYTHON_PROC*)&dll_Py_BuildValue},
     {"Py_FindMethod", (PYTHON_PROC*)&dll_Py_FindMethod},
 # if (PY_VERSION_HEX >= 0x02050000) && SIZEOF_SIZE_T != SIZEOF_INT
@@ -310,6 +315,7 @@
 # else
     {"Py_InitModule4", (PYTHON_PROC*)&dll_Py_InitModule4},
 # endif
+    {"Py_SetPythonHome", (PYTHON_PROC*)&dll_Py_SetPythonHome},
     {"Py_Initialize", (PYTHON_PROC*)&dll_Py_Initialize},
     {"Py_Finalize", (PYTHON_PROC*)&dll_Py_Finalize},
     {"Py_IsInitialized", (PYTHON_PROC*)&dll_Py_IsInitialized},
@@ -349,7 +355,7 @@
 {
     int i;
 
-#if !defined(PY_NO_RTLD_GLOBAL) && defined(UNIX) && defined(FEAT_PYTHON3)
+#if !(defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)) && defined(UNIX) && defined(FEAT_PYTHON3)
     /* Can't have Python and Python3 loaded at the same time.
      * It cause a crash, because RTLD_GLOBAL is needed for
      * standard C extension libraries of one or both python versions. */
@@ -543,6 +549,10 @@
 	}
 #endif
 
+#ifdef PYTHON_HOME
+	Py_SetPythonHome(PYTHON_HOME);
+#endif
+
 	init_structs();
 
 #if !defined(MACOS) || defined(MACOS_X_UNIX)
@@ -773,7 +783,7 @@
 PythonIO_Init(void)
 {
     /* Fixups... */
-    OutputType.ob_type = &PyType_Type;
+    PyType_Ready(&OutputType);
 
     return PythonIO_Init_io();
 }
@@ -1395,12 +1405,12 @@
     static char *(argv[2]) = {"/must>not&exist/foo", NULL};
 
     /* Fixups... */
-    BufferType.ob_type = &PyType_Type;
-    RangeType.ob_type = &PyType_Type;
-    WindowType.ob_type = &PyType_Type;
-    BufListType.ob_type = &PyType_Type;
-    WinListType.ob_type = &PyType_Type;
-    CurrentType.ob_type = &PyType_Type;
+    PyType_Ready(&BufferType);
+    PyType_Ready(&RangeType);
+    PyType_Ready(&WindowType);
+    PyType_Ready(&BufListType);
+    PyType_Ready(&WinListType);
+    PyType_Ready(&CurrentType);
 
     /* Set sys.argv[] to avoid a crash in warn(). */
     PySys_SetArgv(1, argv);
diff -Naur vim73.orig/src/if_python3.c vim73/src/if_python3.c
--- vim73.orig/src/if_python3.c	2010-08-13 13:59:40.000000000 +0000
+++ vim73/src/if_python3.c	2011-05-17 09:37:22.774218356 +0000
@@ -22,8 +22,8 @@
  * Adaptations to support both python3.x and python2.x
  */
 
-// uncomment this if used with the debug version of python
-// #define Py_DEBUG
+/* uncomment this if used with the debug version of python */
+/* #define Py_DEBUG */
 
 #include "vim.h"
 
@@ -74,13 +74,13 @@
 #define PyString_Size(obj) PyUnicode_GET_SIZE(obj)
 #define PyString_FromString(repr) PyUnicode_FromString(repr)
 
-#if defined(DYNAMIC_PYTHON3)
+#if defined(DYNAMIC_PYTHON3) || defined(PROTO)
 
 # ifndef WIN3264
 #  include <dlfcn.h>
 #  define FARPROC void*
 #  define HINSTANCE void*
-#  ifdef PY_NO_RTLD_GLOBAL
+#  if defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)
 #   define load_dll(n) dlopen((n), RTLD_LAZY)
 #  else
 #   define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)
@@ -88,7 +88,7 @@
 #  define close_dll dlclose
 #  define symbol_from_dll dlsym
 # else
-#  define load_dll LoadLibrary
+#  define load_dll vimLoadLib
 #  define close_dll FreeLibrary
 #  define symbol_from_dll GetProcAddress
 # endif
@@ -132,6 +132,7 @@
 # define PyType_Ready py3_PyType_Ready
 #undef Py_BuildValue
 # define Py_BuildValue py3_Py_BuildValue
+# define Py_SetPythonHome py3_Py_SetPythonHome
 # define Py_Initialize py3_Py_Initialize
 # define Py_Finalize py3_Py_Finalize
 # define Py_IsInitialized py3_Py_IsInitialized
@@ -170,6 +171,7 @@
  * Pointers for dynamic link
  */
 static int (*py3_PySys_SetArgv)(int, wchar_t **);
+static void (*py3_Py_SetPythonHome)(wchar_t *home);
 static void (*py3_Py_Initialize)(void);
 static PyObject* (*py3_PyList_New)(Py_ssize_t size);
 static PyGILState_STATE (*py3_PyGILState_Ensure)(void);
@@ -254,6 +256,7 @@
 } py3_funcname_table[] =
 {
     {"PySys_SetArgv", (PYTHON_PROC*)&py3_PySys_SetArgv},
+    {"Py_SetPythonHome", (PYTHON_PROC*)&py3_Py_SetPythonHome},
     {"Py_Initialize", (PYTHON_PROC*)&py3_Py_Initialize},
     {"PyArg_ParseTuple", (PYTHON_PROC*)&py3_PyArg_ParseTuple},
     {"PyList_New", (PYTHON_PROC*)&py3_PyList_New},
@@ -336,7 +339,7 @@
     int i;
     void *ucs_from_string, *ucs_from_string_and_size;
 
-# if !defined(PY_NO_RTLD_GLOBAL) && defined(UNIX) && defined(FEAT_PYTHON)
+# if !(defined(PY_NO_RTLD_GLOBAL) && defined(PY3_NO_RTLD_GLOBAL)) && defined(UNIX) && defined(FEAT_PYTHON)
     /* Can't have Python and Python3 loaded at the same time.
      * It cause a crash, because RTLD_GLOBAL is needed for
      * standard C extension libraries of one or both python versions. */
@@ -539,6 +542,11 @@
 
 	init_structs();
 
+
+#ifdef PYTHON3_HOME
+	Py_SetPythonHome(PYTHON3_HOME);
+#endif
+
 	/* initialise threads */
 	PyEval_InitThreads();
 
diff -Naur vim73.orig/src/if_ruby.c vim73/src/if_ruby.c
--- vim73.orig/src/if_ruby.c	2010-06-30 19:33:12.000000000 +0000
+++ vim73/src/if_ruby.c	2011-05-17 09:36:12.098062605 +0000
@@ -4,12 +4,17 @@
  *
  * Ruby interface by Shugo Maeda
  *   with improvements by SegPhault (Ryan Paul)
+ *   with improvements by Jon Maken
  *
  * Do ":help uganda"  in Vim to read copying and usage conditions.
  * Do ":help credits" in Vim to see a list of people who contributed.
  * See README.txt for an overview of the Vim source code.
  */
 
+#ifdef HAVE_CONFIG_H
+# include "auto/config.h"
+#endif
+
 #include <stdio.h>
 #include <string.h>
 
@@ -26,12 +31,12 @@
 # define RUBYEXTERN extern
 #endif
 
+#ifdef DYNAMIC_RUBY
 /*
  * This is tricky.  In ruby.h there is (inline) function rb_class_of()
  * definition.  This function use these variables.  But we want function to
  * use dll_* variables.
  */
-#ifdef DYNAMIC_RUBY
 # define rb_cFalseClass		(*dll_rb_cFalseClass)
 # define rb_cFixnum		(*dll_rb_cFixnum)
 # define rb_cNilClass		(*dll_rb_cNilClass)
@@ -46,8 +51,23 @@
  */
 #  define RUBY_EXPORT
 # endif
+
+#if !(defined(WIN32) || defined(_WIN64))
+# include <dlfcn.h>
+# define HINSTANCE void*
+# define RUBY_PROC void*
+# define load_dll(n) dlopen((n), RTLD_LAZY|RTLD_GLOBAL)
+# define symbol_from_dll dlsym
+# define close_dll dlclose
+#else
+# define RUBY_PROC FARPROC
+# define load_dll vimLoadLib
+# define symbol_from_dll GetProcAddress
+# define close_dll FreeLibrary
 #endif
 
+#endif  /* ifdef DYNAMIC_RUBY */
+
 /* suggested by Ariya Mizutani */
 #if (_MSC_VER == 1200)
 # undef _WIN32_WINNT
@@ -70,6 +90,7 @@
 # include <ruby/encoding.h>
 #endif
 
+#undef off_t	/* ruby defines off_t as _int64, Mingw uses long */
 #undef EXTERN
 #undef _
 
@@ -160,28 +181,35 @@
 #define rb_lastline_get			dll_rb_lastline_get
 #define rb_lastline_set			dll_rb_lastline_set
 #define rb_load_protect			dll_rb_load_protect
+#ifndef RUBY19_OR_LATER
 #define rb_num2long			dll_rb_num2long
+#endif
 #define rb_num2ulong			dll_rb_num2ulong
 #define rb_obj_alloc			dll_rb_obj_alloc
 #define rb_obj_as_string		dll_rb_obj_as_string
 #define rb_obj_id			dll_rb_obj_id
 #define rb_raise			dll_rb_raise
-#define rb_str2cstr			dll_rb_str2cstr
 #define rb_str_cat			dll_rb_str_cat
 #define rb_str_concat			dll_rb_str_concat
 #define rb_str_new			dll_rb_str_new
 #ifdef rb_str_new2
 /* Ruby may #define rb_str_new2 to use rb_str_new_cstr. */
 # define need_rb_str_new_cstr 1
+/* Ruby's headers #define rb_str_new_cstr to make use of GCC's
+ * __builtin_constant_p extension. */
+# undef rb_str_new_cstr
 # define rb_str_new_cstr		dll_rb_str_new_cstr
 #else
 # define rb_str_new2			dll_rb_str_new2
 #endif
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+# define rb_string_value		dll_rb_string_value
 # define rb_string_value_ptr		dll_rb_string_value_ptr
 # define rb_float_new			dll_rb_float_new
 # define rb_ary_new			dll_rb_ary_new
 # define rb_ary_push			dll_rb_ary_push
+#else
+# define rb_str2cstr			dll_rb_str2cstr
 #endif
 #ifdef RUBY19_OR_LATER
 # define rb_errinfo			dll_rb_errinfo
@@ -190,9 +218,11 @@
 #endif
 #define ruby_init			dll_ruby_init
 #define ruby_init_loadpath		dll_ruby_init_loadpath
-#define NtInitialize			dll_NtInitialize
-#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
-# define rb_w32_snprintf		dll_rb_w32_snprintf
+#ifdef WIN3264
+# define NtInitialize			dll_NtInitialize
+# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+#  define rb_w32_snprintf		dll_rb_w32_snprintf
+# endif
 #endif
 
 #ifdef RUBY19_OR_LATER
@@ -201,7 +231,9 @@
 # define rb_enc_find			dll_rb_enc_find
 # define rb_enc_str_new			dll_rb_enc_str_new
 # define rb_sprintf			dll_rb_sprintf
+# define rb_require			dll_rb_require
 # define ruby_init_stack		dll_ruby_init_stack
+# define ruby_process_options		dll_ruby_process_options
 #endif
 
 /*
@@ -246,7 +278,11 @@
 static VALUE (*dll_rb_obj_as_string) (VALUE);
 static VALUE (*dll_rb_obj_id) (VALUE);
 static void (*dll_rb_raise) (VALUE, const char*, ...);
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+static VALUE (*dll_rb_string_value) (volatile VALUE*);
+#else
 static char *(*dll_rb_str2cstr) (VALUE,int*);
+#endif
 static VALUE (*dll_rb_str_cat) (VALUE, const char*, long);
 static VALUE (*dll_rb_str_concat) (VALUE, VALUE);
 static VALUE (*dll_rb_str_new) (const char*, long);
@@ -263,7 +299,12 @@
 #endif
 static void (*dll_ruby_init) (void);
 static void (*dll_ruby_init_loadpath) (void);
+#ifdef WIN3264
 static void (*dll_NtInitialize) (int*, char***);
+# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+static int (*dll_rb_w32_snprintf)(char*, size_t, const char*, ...);
+# endif
+#endif
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
 static char * (*dll_rb_string_value_ptr) (volatile VALUE*);
 static VALUE (*dll_rb_float_new) (double);
@@ -273,9 +314,6 @@
 #ifdef RUBY19_OR_LATER
 static VALUE (*dll_rb_int2big)(SIGNED_VALUE);
 #endif
-#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
-static int (*dll_rb_w32_snprintf)(char*, size_t, const char*, ...);
-#endif
 
 #ifdef RUBY19_OR_LATER
 static void (*dll_ruby_script) (const char*);
@@ -283,7 +321,9 @@
 static rb_encoding* (*dll_rb_enc_find) (const char*);
 static VALUE (*dll_rb_enc_str_new) (const char*, long, rb_encoding*);
 static VALUE (*dll_rb_sprintf) (const char*, ...);
+static VALUE (*dll_rb_require) (const char*);
 static void (*ruby_init_stack)(VALUE*);
+static void* (*ruby_process_options)(int, char**);
 #endif
 
 #ifdef RUBY19_OR_LATER
@@ -297,12 +337,11 @@
 }
 #endif
 
-static HINSTANCE hinstRuby = 0; /* Instance of ruby.dll */
+static HINSTANCE hinstRuby = NULL; /* Instance of ruby.dll */
 
 /*
  * Table of name to function pointer of ruby.
  */
-#define RUBY_PROC FARPROC
 static struct
 {
     char *name;
@@ -347,7 +386,11 @@
     {"rb_obj_as_string", (RUBY_PROC*)&dll_rb_obj_as_string},
     {"rb_obj_id", (RUBY_PROC*)&dll_rb_obj_id},
     {"rb_raise", (RUBY_PROC*)&dll_rb_raise},
+#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+    {"rb_string_value", (RUBY_PROC*)&dll_rb_string_value},
+#else
     {"rb_str2cstr", (RUBY_PROC*)&dll_rb_str2cstr},
+#endif
     {"rb_str_cat", (RUBY_PROC*)&dll_rb_str_cat},
     {"rb_str_concat", (RUBY_PROC*)&dll_rb_str_concat},
     {"rb_str_new", (RUBY_PROC*)&dll_rb_str_new},
@@ -363,15 +406,17 @@
 #endif
     {"ruby_init", (RUBY_PROC*)&dll_ruby_init},
     {"ruby_init_loadpath", (RUBY_PROC*)&dll_ruby_init_loadpath},
+#ifdef WIN3264
     {
-#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER < 19
+# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER < 19
     "NtInitialize",
-#else
+# else
     "ruby_sysinit",
-#endif
+# endif
 			(RUBY_PROC*)&dll_NtInitialize},
-#if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
+# if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
     {"rb_w32_snprintf", (RUBY_PROC*)&dll_rb_w32_snprintf},
+# endif
 #endif
 #if defined(DYNAMIC_RUBY_VER) && DYNAMIC_RUBY_VER >= 18
     {"rb_string_value_ptr", (RUBY_PROC*)&dll_rb_string_value_ptr},
@@ -386,7 +431,9 @@
     {"rb_enc_find", (RUBY_PROC*)&dll_rb_enc_find},
     {"rb_enc_str_new", (RUBY_PROC*)&dll_rb_enc_str_new},
     {"rb_sprintf", (RUBY_PROC*)&dll_rb_sprintf},
+    {"rb_require", (RUBY_PROC*)&dll_rb_require},
     {"ruby_init_stack", (RUBY_PROC*)&dll_ruby_init_stack},
+    {"ruby_process_options", (RUBY_PROC*)&dll_ruby_process_options},
 #endif
     {"", NULL},
 };
@@ -399,8 +446,8 @@
 {
     if (hinstRuby)
     {
-	FreeLibrary(hinstRuby);
-	hinstRuby = 0;
+	close_dll(hinstRuby);
+	hinstRuby = NULL;
     }
 }
 
@@ -416,7 +463,7 @@
 
     if (hinstRuby)
 	return OK;
-    hinstRuby = LoadLibrary(libname);
+    hinstRuby = load_dll(libname);
     if (!hinstRuby)
     {
 	if (verbose)
@@ -426,11 +473,11 @@
 
     for (i = 0; ruby_funcname_table[i].ptr; ++i)
     {
-	if (!(*ruby_funcname_table[i].ptr = GetProcAddress(hinstRuby,
+	if (!(*ruby_funcname_table[i].ptr = symbol_from_dll(hinstRuby,
 			ruby_funcname_table[i].name)))
 	{
-	    FreeLibrary(hinstRuby);
-	    hinstRuby = 0;
+	    close_dll(hinstRuby);
+	    hinstRuby = NULL;
 	    if (verbose)
 		EMSG2(_(e_loadfunc), ruby_funcname_table[i].name);
 	    return FAIL;
@@ -539,9 +586,9 @@
 	if (u_save(eap->line1 - 1, eap->line2 + 1) != OK)
 	    return;
 	for (i = eap->line1; i <= eap->line2; i++) {
-	    VALUE line, oldline;
+	    VALUE line;
 
-	    line = oldline = vim_str2rb_enc_str((char *)ml_get(i));
+	    line = vim_str2rb_enc_str((char *)ml_get(i));
 	    rb_lastline_set(line);
 	    eval_enc_string_protect((char *) eap->arg, &state);
 	    if (state) {
@@ -616,13 +663,16 @@
 		ruby_init();
 	    }
 #ifdef RUBY19_OR_LATER
+	    {
+		int dummy_argc = 2;
+		char *dummy_argv[] = {"vim-ruby", "-e0"};
+		ruby_process_options(dummy_argc, dummy_argv);
+	    }
 	    ruby_script("vim-ruby");
-#endif
+#else
 	    ruby_init_loadpath();
-	    ruby_io_init();
-#ifdef RUBY19_OR_LATER
-	    rb_enc_find_index("encdb");
 #endif
+	    ruby_io_init();
 	    ruby_vim_init();
 	    ruby_initialized = 1;
 #ifdef DYNAMIC_RUBY
@@ -906,15 +956,9 @@
 
 static VALUE get_buffer_line(buf_T *buf, linenr_T n)
 {
-    if (n > 0 && n <= buf->b_ml.ml_line_count)
-    {
-	char *line = (char *)ml_get_buf(buf, n, FALSE);
-	return line ? vim_str2rb_enc_str(line) : Qnil;
-    }
-    rb_raise(rb_eIndexError, "line number %ld out of range", (long)n);
-#ifndef __GNUC__
-    return Qnil; /* For stop warning */
-#endif
+    if (n <= 0 || n > buf->b_ml.ml_line_count)
+	rb_raise(rb_eIndexError, "line number %ld out of range", (long)n);
+    return vim_str2rb_enc_str((char *)ml_get_buf(buf, n, FALSE));
 }
 
 static VALUE buffer_aref(VALUE self, VALUE num)
@@ -953,9 +997,6 @@
     else
     {
 	rb_raise(rb_eIndexError, "line number %ld out of range", (long)n);
-#ifndef __GNUC__
-	return Qnil; /* For stop warning */
-#endif
     }
     return str;
 }
@@ -1010,7 +1051,8 @@
     long	n = NUM2LONG(num);
     aco_save_T	aco;
 
-    if (line == NULL) {
+    if (line == NULL)
+    {
 	rb_raise(rb_eIndexError, "NULL line");
     }
     else if (n >= 0 && n <= buf->b_ml.ml_line_count)
@@ -1034,7 +1076,8 @@
 
 	update_curbuf(NOT_VALID);
     }
-    else {
+    else
+    {
 	rb_raise(rb_eIndexError, "line number %ld out of range", n);
     }
     return str;
diff -Naur vim73.orig/src/if_sniff.c vim73/src/if_sniff.c
--- vim73.orig/src/if_sniff.c	2010-05-15 11:04:06.000000000 +0000
+++ vim73/src/if_sniff.c	2011-05-17 09:35:36.142053351 +0000
@@ -9,7 +9,6 @@
 
 #ifdef WIN32
 # include <stdio.h>
-# include "vimio.h"
 # include <process.h>
 # include <string.h>
 # include <assert.h>
diff -Naur vim73.orig/src/if_tcl.c vim73/src/if_tcl.c
--- vim73.orig/src/if_tcl.c	2010-08-08 13:07:25.000000000 +0000
+++ vim73/src/if_tcl.c	2011-05-17 09:35:40.549564160 +0000
@@ -74,7 +74,6 @@
 #endif
 
 #include <tcl.h>
-#include <errno.h>
 #include <string.h>
 
 typedef struct
diff -Naur vim73.orig/src/integration.c vim73/src/integration.c
--- vim73.orig/src/integration.c	2010-08-08 13:09:21.000000000 +0000
+++ vim73/src/integration.c	2011-05-17 09:35:40.549564160 +0000
@@ -33,7 +33,6 @@
 #include <sys/un.h>
 #endif
 
-#include <errno.h>
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/param.h>
diff -Naur vim73.orig/src/link.sh vim73/src/link.sh
--- vim73.orig/src/link.sh	2010-07-21 19:43:29.000000000 +0000
+++ vim73/src/link.sh	2011-05-17 09:34:17.110825093 +0000
@@ -5,7 +5,7 @@
 # libraries when they exist, but this doesn't mean they are needed for Vim.
 #
 #      Author: Bram Moolenaar
-# Last change: 2006 Sep 26
+# Last change: 2010 Nov 03
 #     License: Public domain
 #
 # Warning: This fails miserably if the linker doesn't return an error code!
@@ -16,11 +16,23 @@
 echo "$LINK " >link.cmd
 exit_value=0
 
+if test "$LINK_AS_NEEDED" = yes; then
+  echo "link.sh: \$LINK_AS_NEEDED set to 'yes': invoking linker directly."
+  cat link.cmd
+  if sh link.cmd; then
+    exit_value=0
+    echo "link.sh: Linked fine"
+  else
+    exit_value=$?
+    echo "link.sh: Linking failed"
+  fi
+else
+  if test -f auto/link.sed; then
+
 #
 # If auto/link.sed already exists, use it.  We assume a previous run of
 # link.sh has found the correct set of libraries.
 #
-if test -f auto/link.sed; then
   echo "link.sh: The file 'auto/link.sed' exists, which is going to be used now."
   echo "link.sh: If linking fails, try deleting the auto/link.sed file."
   echo "link.sh: If this fails too, try creating an empty auto/link.sed file."
@@ -124,6 +136,8 @@
   fi
 fi
 
+fi
+
 #
 # cleanup
 #
diff -Naur vim73.orig/src/macros.h vim73/src/macros.h
--- vim73.orig/src/macros.h	2010-07-17 19:41:21.000000000 +0000
+++ vim73/src/macros.h	2011-05-17 09:32:40.829511613 +0000
@@ -285,3 +285,17 @@
 #else
 # define DO_AUTOCHDIR
 #endif
+
+#if defined(FEAT_SCROLLBIND) && defined(FEAT_CURSORBIND)
+# define RESET_BINDING(wp)  (wp)->w_p_scb = FALSE; (wp)->w_p_crb = FALSE
+#else
+# if defined(FEAT_SCROLLBIND)
+#  define RESET_BINDING(wp)  (wp)->w_p_scb = FALSE
+# else
+#  if defined(FEAT_CURSORBIND)
+#   define RESET_BINDING(wp)  (wp)->w_p_crb = FALSE
+#  else
+#   define RESET_BINDING(wp)
+#  endif
+# endif
+#endif
diff -Naur vim73.orig/src/main.c vim73/src/main.c
--- vim73.orig/src/main.c	2010-08-08 13:09:55.000000000 +0000
+++ vim73/src/main.c	2011-05-17 09:39:31.611919093 +0000
@@ -7,10 +7,6 @@
  * See README.txt for an overview of the Vim source code.
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"		/* for close() and dup() */
-#endif
-
 #define EXTERN
 #include "vim.h"
 
@@ -96,37 +92,39 @@
 #define EDIT_TAG    3	    /* tag name argument given, use tagname */
 #define EDIT_QF	    4	    /* start in quickfix mode */
 
-#if defined(UNIX) || defined(VMS)
+#if (defined(UNIX) || defined(VMS)) && !defined(NO_VIM_MAIN)
 static int file_owned __ARGS((char *fname));
 #endif
 static void mainerr __ARGS((int, char_u *));
+#ifndef NO_VIM_MAIN
 static void main_msg __ARGS((char *s));
 static void usage __ARGS((void));
 static int get_number_arg __ARGS((char_u *p, int *idx, int def));
-#if defined(HAVE_LOCALE_H) || defined(X_LOCALE)
+# if defined(HAVE_LOCALE_H) || defined(X_LOCALE)
 static void init_locale __ARGS((void));
-#endif
+# endif
 static void parse_command_name __ARGS((mparm_T *parmp));
 static void early_arg_scan __ARGS((mparm_T *parmp));
 static void command_line_scan __ARGS((mparm_T *parmp));
 static void check_tty __ARGS((mparm_T *parmp));
 static void read_stdin __ARGS((void));
 static void create_windows __ARGS((mparm_T *parmp));
-#ifdef FEAT_WINDOWS
+# ifdef FEAT_WINDOWS
 static void edit_buffers __ARGS((mparm_T *parmp));
-#endif
+# endif
 static void exe_pre_commands __ARGS((mparm_T *parmp));
 static void exe_commands __ARGS((mparm_T *parmp));
 static void source_startup_scripts __ARGS((mparm_T *parmp));
 static void main_start_gui __ARGS((void));
-#if defined(HAS_SWAP_EXISTS_ACTION)
+# if defined(HAS_SWAP_EXISTS_ACTION)
 static void check_swap_exists_action __ARGS((void));
-#endif
-#ifdef FEAT_CLIENTSERVER
+# endif
+# if defined(FEAT_CLIENTSERVER) || defined(PROTO)
 static void exec_on_server __ARGS((mparm_T *parmp));
 static void prepare_server __ARGS((mparm_T *parmp));
 static void cmdsrv_main __ARGS((int *argc, char **argv, char_u *serverName_arg, char_u **serverStr));
 static char_u *serverMakeName __ARGS((char_u *arg, char *cmd));
+# endif
 #endif
 
 
@@ -149,7 +147,8 @@
 #define ME_INVALID_ARG		5
 };
 
-#ifndef PROTO	    /* don't want a prototype for main() */
+#ifndef NO_VIM_MAIN	/* skip this for unittests */
+#ifndef PROTO		/* don't want a prototype for main() */
     int
 # ifdef VIMDLL
 _export
@@ -940,7 +939,7 @@
     if (netbeansArg != NULL && strncmp("-nb", netbeansArg, 3) == 0)
     {
 # ifdef FEAT_GUI
-#  if !defined(FEAT_GUI_MOTIF) && !defined(FEAT_GUI_GTK)  \
+#  if !defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)  \
 		&& !defined(FEAT_GUI_W32)
 	if (gui.in_use)
 	{
@@ -970,6 +969,7 @@
     return 0;
 }
 #endif /* PROTO */
+#endif /* NO_VIM_MAIN */
 
 /*
  * Main loop: Execute Normal mode commands until exiting Vim.
@@ -1202,7 +1202,9 @@
 			|| conceal_cursor_line(curwin)
 			|| need_cursor_line_redraw))
 	    {
-		if (conceal_old_cursor_line != conceal_new_cursor_line)
+		if (conceal_old_cursor_line != conceal_new_cursor_line
+			&& conceal_old_cursor_line
+						<= curbuf->b_ml.ml_line_count)
 		    update_single_line(curwin, conceal_old_cursor_line);
 		update_single_line(curwin, conceal_new_cursor_line);
 		curwin->w_valid &= ~VALID_CROW;
@@ -1432,6 +1434,7 @@
     mch_exit(exitval);
 }
 
+#ifndef NO_VIM_MAIN
 /*
  * Get a (optional) count for a Vim argument.
  */
@@ -2996,6 +2999,8 @@
 #endif
 }
 
+#endif  /* NO_VIM_MAIN */
+
 /*
  * Get an environment variable, and execute it as Ex commands.
  * Returns FAIL if the environment variable was not executed, OK otherwise.
@@ -3035,7 +3040,7 @@
     return FAIL;
 }
 
-#if defined(UNIX) || defined(VMS)
+#if (defined(UNIX) || defined(VMS)) && !defined(NO_VIM_MAIN)
 /*
  * Return TRUE if we are certain the user owns the file "fname".
  * Used for ".vimrc" and ".exrc".
@@ -3093,6 +3098,7 @@
     mainerr(ME_ARG_MISSING, str);
 }
 
+#ifndef NO_VIM_MAIN
 /*
  * print a message with three spaces prepended and '\n' appended.
  */
@@ -3270,11 +3276,6 @@
     main_msg(_("+reverse\t\tDon't use reverse video (also: +rv)"));
     main_msg(_("-xrm <resource>\tSet the specified resource"));
 #endif /* FEAT_GUI_X11 */
-#if defined(FEAT_GUI) && defined(RISCOS)
-    mch_msg(_("\nArguments recognised by gvim (RISC OS version):\n"));
-    main_msg(_("--columns <number>\tInitial width of window in columns"));
-    main_msg(_("--rows <number>\tInitial height of window in rows"));
-#endif
 #ifdef FEAT_GUI_GTK
     mch_msg(_("\nArguments recognised by gvim (GTK+ version):\n"));
     main_msg(_("-font <font>\t\tUse <font> for normal text (also: -fn)"));
@@ -3313,6 +3314,8 @@
 }
 #endif
 
+#endif
+
 #if defined(STARTUPTIME) || defined(PROTO)
 static void time_diff __ARGS((struct timeval *then, struct timeval *now));
 
@@ -3422,7 +3425,7 @@
 
 #endif
 
-#if defined(FEAT_CLIENTSERVER) || defined(PROTO)
+#if (defined(FEAT_CLIENTSERVER) && !defined(NO_VIM_MAIN)) || defined(PROTO)
 
 /*
  * Common code for the X command server and the Win32 command server.
@@ -3806,7 +3809,7 @@
     int		i;
     char_u	*inicmd = NULL;
     char_u	*p;
-    char_u	cwd[MAXPATHL];
+    char_u	*cwd;
 
     if (filec > 0 && filev[0][0] == '+')
     {
@@ -3817,15 +3820,25 @@
     /* Check if we have at least one argument. */
     if (filec <= 0)
 	mainerr_arg_missing((char_u *)filev[-1]);
+
+    /* Temporarily cd to the current directory to handle relative file names. */
+    cwd = alloc(MAXPATHL);
+    if (cwd == NULL)
+	return NULL;
     if (mch_dirname(cwd, MAXPATHL) != OK)
+    {
+	vim_free(cwd);
 	return NULL;
-    if ((p = vim_strsave_escaped_ext(cwd,
+    }
+    p = vim_strsave_escaped_ext(cwd,
 #ifdef BACKSLASH_IN_FILENAME
 		    "",  /* rem_backslash() will tell what chars to escape */
 #else
 		    PATH_ESC_CHARS,
 #endif
-		    '\\', TRUE)) == NULL)
+		    '\\', TRUE);
+    vim_free(cwd);
+    if (p == NULL)
 	return NULL;
     ga_init2(&ga, 1, 100);
     ga_concat(&ga, (char_u *)"<C-\\><C-N>:cd ");
@@ -3858,13 +3871,20 @@
 	ga_concat(&ga, p);
 	vim_free(p);
     }
+    ga_concat(&ga, (char_u *)"|if exists('*inputrestore')|call inputrestore()|endif<CR>");
+
     /* The :drop commands goes to Insert mode when 'insertmode' is set, use
      * CTRL-\ CTRL-N again. */
-    ga_concat(&ga, (char_u *)"|if exists('*inputrestore')|call inputrestore()|endif<CR>");
-    ga_concat(&ga, (char_u *)"<C-\\><C-N>:cd -");
+    ga_concat(&ga, (char_u *)"<C-\\><C-N>");
+
+    /* Switch back to the correct current directory (prior to temporary path
+     * switch) unless 'autochdir' is set, in which case it will already be
+     * correct after the :drop command. */
+    ga_concat(&ga, (char_u *)":if !exists('+acd')||!&acd|cd -|endif<CR>");
+
     if (sendReply)
-	ga_concat(&ga, (char_u *)"<CR>:call SetupRemoteReplies()");
-    ga_concat(&ga, (char_u *)"<CR>:");
+	ga_concat(&ga, (char_u *)":call SetupRemoteReplies()<CR>");
+    ga_concat(&ga, (char_u *)":");
     if (inicmd != NULL)
     {
 	/* Can't use <CR> after "inicmd", because an "startinsert" would cause
@@ -3881,6 +3901,32 @@
 }
 
 /*
+ * Make our basic server name: use the specified "arg" if given, otherwise use
+ * the tail of the command "cmd" we were started with.
+ * Return the name in allocated memory.  This doesn't include a serial number.
+ */
+    static char_u *
+serverMakeName(arg, cmd)
+    char_u	*arg;
+    char	*cmd;
+{
+    char_u *p;
+
+    if (arg != NULL && *arg != NUL)
+	p = vim_strsave_up(arg);
+    else
+    {
+	p = vim_strsave_up(gettail((char_u *)cmd));
+	/* Remove .exe or .bat from the name. */
+	if (p != NULL && vim_strchr(p, '.') != NULL)
+	    *vim_strchr(p, '.') = NUL;
+    }
+    return p;
+}
+#endif /* FEAT_CLIENTSERVER */
+
+#if defined(FEAT_CLIENTSERVER) || defined(PROTO)
+/*
  * Replace termcodes such as <CR> and insert as key presses if there is room.
  */
     void
@@ -3991,32 +4037,7 @@
 # endif
     return res;
 }
-
-
-/*
- * Make our basic server name: use the specified "arg" if given, otherwise use
- * the tail of the command "cmd" we were started with.
- * Return the name in allocated memory.  This doesn't include a serial number.
- */
-    static char_u *
-serverMakeName(arg, cmd)
-    char_u	*arg;
-    char	*cmd;
-{
-    char_u *p;
-
-    if (arg != NULL && *arg != NUL)
-	p = vim_strsave_up(arg);
-    else
-    {
-	p = vim_strsave_up(gettail((char_u *)cmd));
-	/* Remove .exe or .bat from the name. */
-	if (p != NULL && vim_strchr(p, '.') != NULL)
-	    *vim_strchr(p, '.') = NUL;
-    }
-    return p;
-}
-#endif /* FEAT_CLIENTSERVER */
+#endif
 
 /*
  * When FEAT_FKMAP is defined, also compile the Farsi source code.
diff -Naur vim73.orig/src/mark.c vim73/src/mark.c
--- vim73.orig/src/mark.c	2010-08-13 09:14:35.000000000 +0000
+++ vim73/src/mark.c	2011-05-17 09:37:13.347264636 +0000
@@ -1750,7 +1750,10 @@
 	    {
 		if (line[1] != NUL)
 		{
-		    sscanf((char *)line + 2, "%ld %u", &pos.lnum, &pos.col);
+		    unsigned u;
+
+		    sscanf((char *)line + 2, "%ld %u", &pos.lnum, &u);
+		    pos.col = u;
 		    switch (line[1])
 		    {
 			case '"': curbuf->b_last_cursor = pos; break;
diff -Naur vim73.orig/src/mbyte.c vim73/src/mbyte.c
--- vim73.orig/src/mbyte.c	2010-07-18 13:05:44.000000000 +0000
+++ vim73/src/mbyte.c	2011-05-17 09:38:24.607355664 +0000
@@ -3124,6 +3124,9 @@
 		/* If one of the two characters is incomplete return -1. */
 		if (incomplete || i + utf_byte2len(s2[i]) > n)
 		    return -1;
+		/* Don't case-fold illegal bytes or truncated characters. */
+		if (utf_ptr2len(s1 + i) < l || utf_ptr2len(s2 + i) < l)
+		    return -1;
 		cdiff = utf_fold(utf_ptr2char(s1 + i))
 					     - utf_fold(utf_ptr2char(s2 + i));
 		if (cdiff != 0)
@@ -4126,7 +4129,7 @@
 	done = to - (char *)result;
     }
 
-    if (resultlenp != NULL)
+    if (resultlenp != NULL && result != NULL)
 	*resultlenp = (int)(to - (char *)result);
     return result;
 }
@@ -4159,11 +4162,11 @@
 {
     if (hIconvDLL != 0 && hMsvcrtDLL != 0)
 	return TRUE;
-    hIconvDLL = LoadLibrary(DYNAMIC_ICONV_DLL);
+    hIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL);
     if (hIconvDLL == 0)		/* sometimes it's called libiconv.dll */
-	hIconvDLL = LoadLibrary(DYNAMIC_ICONV_DLL_ALT);
+	hIconvDLL = vimLoadLib(DYNAMIC_ICONV_DLL_ALT);
     if (hIconvDLL != 0)
-	hMsvcrtDLL = LoadLibrary(DYNAMIC_MSVCRT_DLL);
+	hMsvcrtDLL = vimLoadLib(DYNAMIC_MSVCRT_DLL);
     if (hIconvDLL == 0 || hMsvcrtDLL == 0)
     {
 	/* Only give the message when 'verbose' is set, otherwise it might be
@@ -5167,16 +5170,16 @@
     void
 xim_set_preedit()
 {
-    if (xic == NULL)
-	return;
-
-    xim_set_focus(TRUE);
-
     XVaNestedList attr_list;
     XRectangle spot_area;
     XPoint over_spot;
     int line_space;
 
+    if (xic == NULL)
+	return;
+
+    xim_set_focus(TRUE);
+
     if (!xim_has_focus)
     {
 	/* hide XIM cursor */
@@ -5554,12 +5557,12 @@
     void
 xim_set_status_area()
 {
-    if (xic == NULL)
-	return;
-
     XVaNestedList preedit_list = 0, status_list = 0, list = 0;
     XRectangle pre_area, status_area;
 
+    if (xic == NULL)
+	return;
+
     if (input_style & XIMStatusArea)
     {
 	if (input_style & XIMPreeditArea)
diff -Naur vim73.orig/src/memfile.c vim73/src/memfile.c
--- vim73.orig/src/memfile.c	2010-06-21 02:59:57.000000000 +0000
+++ vim73/src/memfile.c	2011-05-17 09:39:31.611919093 +0000
@@ -32,10 +32,6 @@
  * file is opened.
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for lseek(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 /*
@@ -88,6 +84,13 @@
 static int  mf_write_block __ARGS((memfile_T *mfp, bhdr_T *hp, off_t offset, unsigned size));
 static int  mf_trans_add __ARGS((memfile_T *, bhdr_T *));
 static void mf_do_open __ARGS((memfile_T *, char_u *, int));
+static void mf_hash_init __ARGS((mf_hashtab_T *));
+static void mf_hash_free __ARGS((mf_hashtab_T *));
+static void mf_hash_free_all __ARGS((mf_hashtab_T *));
+static mf_hashitem_T *mf_hash_find __ARGS((mf_hashtab_T *, blocknr_T));
+static void mf_hash_add_item __ARGS((mf_hashtab_T *, mf_hashitem_T *));
+static void mf_hash_rem_item __ARGS((mf_hashtab_T *, mf_hashitem_T *));
+static int mf_hash_grow __ARGS((mf_hashtab_T *));
 
 /*
  * The functions for using a memfile:
@@ -123,7 +126,6 @@
     int		flags;
 {
     memfile_T		*mfp;
-    int			i;
     off_t		size;
 #if defined(STATFS) && defined(UNIX) && !defined(__QNX__)
 # define USE_FSTATFS
@@ -156,11 +158,8 @@
     mfp->mf_used_last = NULL;
     mfp->mf_dirty = FALSE;
     mfp->mf_used_count = 0;
-    for (i = 0; i < MEMHASHSIZE; ++i)
-    {
-	mfp->mf_hash[i] = NULL;		/* hash lists are empty */
-	mfp->mf_trans[i] = NULL;	/* trans lists are empty */
-    }
+    mf_hash_init(&mfp->mf_hash);
+    mf_hash_init(&mfp->mf_trans);
     mfp->mf_page_size = MEMFILE_PAGE_SIZE;
 #ifdef FEAT_CRYPT
     mfp->mf_old_key = NULL;
@@ -246,8 +245,6 @@
     int		del_file;
 {
     bhdr_T	*hp, *nextp;
-    NR_TRANS	*tp, *tpnext;
-    int		i;
 
     if (mfp == NULL)		    /* safety check */
 	return;
@@ -267,12 +264,8 @@
     }
     while (mfp->mf_free_first != NULL)	    /* free entries in free list */
 	vim_free(mf_rem_free(mfp));
-    for (i = 0; i < MEMHASHSIZE; ++i)	    /* free entries in trans lists */
-	for (tp = mfp->mf_trans[i]; tp != NULL; tp = tpnext)
-	{
-	    tpnext = tp->nt_next;
-	    vim_free(tp);
-	}
+    mf_hash_free(&mfp->mf_hash);
+    mf_hash_free_all(&mfp->mf_trans);	    /* free hashtable and its items */
     vim_free(mfp->mf_fname);
     vim_free(mfp->mf_ffname);
     vim_free(mfp);
@@ -747,16 +740,7 @@
     memfile_T	*mfp;
     bhdr_T	*hp;
 {
-    bhdr_T	*hhp;
-    int		hash;
-
-    hash = MEMHASH(hp->bh_bnum);
-    hhp = mfp->mf_hash[hash];
-    hp->bh_hash_next = hhp;
-    hp->bh_hash_prev = NULL;
-    if (hhp != NULL)
-	hhp->bh_hash_prev = hp;
-    mfp->mf_hash[hash] = hp;
+    mf_hash_add_item(&mfp->mf_hash, (mf_hashitem_T *)hp);
 }
 
 /*
@@ -767,13 +751,7 @@
     memfile_T	*mfp;
     bhdr_T	*hp;
 {
-    if (hp->bh_hash_prev == NULL)
-	mfp->mf_hash[MEMHASH(hp->bh_bnum)] = hp->bh_hash_next;
-    else
-	hp->bh_hash_prev->bh_hash_next = hp->bh_hash_next;
-
-    if (hp->bh_hash_next)
-	hp->bh_hash_next->bh_hash_prev = hp->bh_hash_prev;
+    mf_hash_rem_item(&mfp->mf_hash, (mf_hashitem_T *)hp);
 }
 
 /*
@@ -784,12 +762,7 @@
     memfile_T	*mfp;
     blocknr_T	nr;
 {
-    bhdr_T	*hp;
-
-    for (hp = mfp->mf_hash[MEMHASH(nr)]; hp != NULL; hp = hp->bh_hash_next)
-	if (hp->bh_bnum == nr)
-	    break;
-    return hp;
+    return (bhdr_T *)mf_hash_find(&mfp->mf_hash, nr);
 }
 
 /*
@@ -1049,7 +1022,7 @@
 	PERROR(_("E294: Seek error in swap file read"));
 	return FAIL;
     }
-    if ((unsigned)vim_read(mfp->mf_fd, hp->bh_data, size) != size)
+    if ((unsigned)read_eintr(mfp->mf_fd, hp->bh_data, size) != size)
     {
 	PERROR(_("E295: Read error in swap file"));
 	return FAIL;
@@ -1168,7 +1141,7 @@
     }
 #endif
 
-    if ((unsigned)vim_write(mfp->mf_fd, data, size) != size)
+    if ((unsigned)write_eintr(mfp->mf_fd, data, size) != size)
 	result = FAIL;
 
 #ifdef FEAT_CRYPT
@@ -1191,7 +1164,6 @@
 {
     bhdr_T	*freep;
     blocknr_T	new_bnum;
-    int		hash;
     NR_TRANS	*np;
     int		page_count;
 
@@ -1239,12 +1211,8 @@
     hp->bh_bnum = new_bnum;
     mf_ins_hash(mfp, hp);		    /* insert in new hash list */
 
-    hash = MEMHASH(np->nt_old_bnum);	    /* insert in trans list */
-    np->nt_next = mfp->mf_trans[hash];
-    mfp->mf_trans[hash] = np;
-    if (np->nt_next != NULL)
-	np->nt_next->nt_prev = np;
-    np->nt_prev = NULL;
+    /* Insert "np" into "mf_trans" hashtable with key "np->nt_old_bnum" */
+    mf_hash_add_item(&mfp->mf_trans, (mf_hashitem_T *)np);
 
     return OK;
 }
@@ -1259,25 +1227,20 @@
     memfile_T	*mfp;
     blocknr_T	old_nr;
 {
-    int		hash;
     NR_TRANS	*np;
     blocknr_T	new_bnum;
 
-    hash = MEMHASH(old_nr);
-    for (np = mfp->mf_trans[hash]; np != NULL; np = np->nt_next)
-	if (np->nt_old_bnum == old_nr)
-	    break;
+    np = (NR_TRANS *)mf_hash_find(&mfp->mf_trans, old_nr);
+
     if (np == NULL)		/* not found */
 	return old_nr;
 
     mfp->mf_neg_count--;
     new_bnum = np->nt_new_bnum;
-    if (np->nt_prev != NULL)		/* remove entry from the trans list */
-	np->nt_prev->nt_next = np->nt_next;
-    else
-	mfp->mf_trans[hash] = np->nt_next;
-    if (np->nt_next != NULL)
-	np->nt_next->nt_prev = np->nt_prev;
+
+    /* remove entry from the trans list */
+    mf_hash_rem_item(&mfp->mf_trans, (mf_hashitem_T *)np);
+
     vim_free(np);
 
     return new_bnum;
@@ -1344,7 +1307,7 @@
      * fname cannot be NameBuff, because it must have been allocated.
      */
     mf_set_ffname(mfp);
-#if defined(MSDOS) || defined(MSWIN) || defined(RISCOS)
+#if defined(MSDOS) || defined(MSWIN)
     /*
      * A ":!cd e:xxx" may change the directory without us knowning, use the
      * full pathname always.  Careful: This frees fname!
@@ -1401,3 +1364,207 @@
 	mch_hide(mfp->mf_fname);    /* try setting the 'hidden' flag */
     }
 }
+
+/*
+ * Implementation of mf_hashtab_T follows.
+ */
+
+/*
+ * The number of buckets in the hashtable is increased by a factor of
+ * MHT_GROWTH_FACTOR when the average number of items per bucket
+ * exceeds 2 ^ MHT_LOG_LOAD_FACTOR.
+ */
+#define MHT_LOG_LOAD_FACTOR 6
+#define MHT_GROWTH_FACTOR   2   /* must be a power of two */
+
+/*
+ * Initialize an empty hash table.
+ */
+    static void
+mf_hash_init(mht)
+    mf_hashtab_T *mht;
+{
+    vim_memset(mht, 0, sizeof(mf_hashtab_T));
+    mht->mht_buckets = mht->mht_small_buckets;
+    mht->mht_mask = MHT_INIT_SIZE - 1;
+}
+
+/*
+ * Free the array of a hash table.  Does not free the items it contains!
+ * The hash table must not be used again without another mf_hash_init() call.
+ */
+    static void
+mf_hash_free(mht)
+    mf_hashtab_T *mht;
+{
+    if (mht->mht_buckets != mht->mht_small_buckets)
+	vim_free(mht->mht_buckets);
+}
+
+/*
+ * Free the array of a hash table and all the items it contains.
+ */
+    static void
+mf_hash_free_all(mht)
+    mf_hashtab_T    *mht;
+{
+    long_u	    idx;
+    mf_hashitem_T   *mhi;
+    mf_hashitem_T   *next;
+
+    for (idx = 0; idx <= mht->mht_mask; idx++)
+	for (mhi = mht->mht_buckets[idx]; mhi != NULL; mhi = next)
+	{
+	    next = mhi->mhi_next;
+	    vim_free(mhi);
+	}
+
+    mf_hash_free(mht);
+}
+
+/*
+ * Find "key" in hashtable "mht".
+ * Returns a pointer to a mf_hashitem_T or NULL if the item was not found.
+ */
+    static mf_hashitem_T *
+mf_hash_find(mht, key)
+    mf_hashtab_T    *mht;
+    blocknr_T	    key;
+{
+    mf_hashitem_T   *mhi;
+
+    mhi = mht->mht_buckets[key & mht->mht_mask];
+    while (mhi != NULL && mhi->mhi_key != key)
+	mhi = mhi->mhi_next;
+
+    return mhi;
+}
+
+/*
+ * Add item "mhi" to hashtable "mht".
+ * "mhi" must not be NULL.
+ */
+    static void
+mf_hash_add_item(mht, mhi)
+    mf_hashtab_T    *mht;
+    mf_hashitem_T   *mhi;
+{
+    long_u	    idx;
+
+    idx = mhi->mhi_key & mht->mht_mask;
+    mhi->mhi_next = mht->mht_buckets[idx];
+    mhi->mhi_prev = NULL;
+    if (mhi->mhi_next != NULL)
+	mhi->mhi_next->mhi_prev = mhi;
+    mht->mht_buckets[idx] = mhi;
+
+    mht->mht_count++;
+
+    /*
+     * Grow hashtable when we have more thank 2^MHT_LOG_LOAD_FACTOR
+     * items per bucket on average
+     */
+    if (mht->mht_fixed == 0
+	&& (mht->mht_count >> MHT_LOG_LOAD_FACTOR) > mht->mht_mask)
+    {
+	if (mf_hash_grow(mht) == FAIL)
+	{
+	    /* stop trying to grow after first failure to allocate memory */
+	    mht->mht_fixed = 1;
+	}
+    }
+}
+
+/*
+ * Remove item "mhi" from hashtable "mht".
+ * "mhi" must not be NULL and must have been inserted into "mht".
+ */
+    static void
+mf_hash_rem_item(mht, mhi)
+    mf_hashtab_T    *mht;
+    mf_hashitem_T   *mhi;
+{
+    if (mhi->mhi_prev == NULL)
+	mht->mht_buckets[mhi->mhi_key & mht->mht_mask] = mhi->mhi_next;
+    else
+	mhi->mhi_prev->mhi_next = mhi->mhi_next;
+
+    if (mhi->mhi_next != NULL)
+	mhi->mhi_next->mhi_prev = mhi->mhi_prev;
+
+    mht->mht_count--;
+
+    /* We could shrink the table here, but it typically takes little memory,
+     * so why bother?  */
+}
+
+/*
+ * Increase number of buckets in the hashtable by MHT_GROWTH_FACTOR and
+ * rehash items.
+ * Returns FAIL when out of memory.
+ */
+    static int
+mf_hash_grow(mht)
+    mf_hashtab_T    *mht;
+{
+    long_u	    i, j;
+    int		    shift;
+    mf_hashitem_T   *mhi;
+    mf_hashitem_T   *tails[MHT_GROWTH_FACTOR];
+    mf_hashitem_T   **buckets;
+    size_t	    size;
+
+    size = (mht->mht_mask + 1) * MHT_GROWTH_FACTOR * sizeof(void *);
+    buckets = (mf_hashitem_T **)lalloc_clear(size, FALSE);
+    if (buckets == NULL)
+	return FAIL;
+
+    shift = 0;
+    while ((mht->mht_mask >> shift) != 0)
+	shift++;
+
+    for (i = 0; i <= mht->mht_mask; i++)
+    {
+	/*
+	 * Traverse the items in the i-th original bucket and move them into
+	 * MHT_GROWTH_FACTOR new buckets, preserving their relative order
+	 * within each new bucket.  Preserving the order is important because
+	 * mf_get() tries to keep most recently used items at the front of
+	 * each bucket.
+	 *
+	 * Here we strongly rely on the fact the hashes are computed modulo
+	 * a power of two.
+	 */
+
+	vim_memset(tails, 0, sizeof(tails));
+
+	for (mhi = mht->mht_buckets[i]; mhi != NULL; mhi = mhi->mhi_next)
+	{
+	    j = (mhi->mhi_key >> shift) & (MHT_GROWTH_FACTOR - 1);
+	    if (tails[j] == NULL)
+	    {
+		buckets[i + (j << shift)] = mhi;
+		tails[j] = mhi;
+		mhi->mhi_prev = NULL;
+	    }
+	    else
+	    {
+		tails[j]->mhi_next = mhi;
+		mhi->mhi_prev = tails[j];
+		tails[j] = mhi;
+	    }
+	}
+
+	for (j = 0; j < MHT_GROWTH_FACTOR; j++)
+	    if (tails[j] != NULL)
+		tails[j]->mhi_next = NULL;
+    }
+
+    if (mht->mht_buckets != mht->mht_small_buckets)
+	vim_free(mht->mht_buckets);
+
+    mht->mht_buckets = buckets;
+    mht->mht_mask = (mht->mht_mask + 1) * MHT_GROWTH_FACTOR - 1;
+
+    return OK;
+}
diff -Naur vim73.orig/src/memfile_test.c vim73/src/memfile_test.c
--- vim73.orig/src/memfile_test.c	1970-01-01 00:00:00.000000000 +0000
+++ vim73/src/memfile_test.c	2011-05-17 09:37:47.947424441 +0000
@@ -0,0 +1,145 @@
+/* vi:set ts=8 sts=4 sw=4:
+ *
+ * VIM - Vi IMproved	by Bram Moolenaar
+ *
+ * Do ":help uganda"  in Vim to read copying and usage conditions.
+ * Do ":help credits" in Vim to see a list of people who contributed.
+ * See README.txt for an overview of the Vim source code.
+ */
+
+/*
+ * memfile_test.c: Unittests for memfile.c
+ * Mostly by Ivan Krasilnikov.
+ */
+
+#undef NDEBUG
+#include <assert.h>
+
+/* Must include main.c because it contains much more than just main() */
+#define NO_VIM_MAIN
+#include "main.c"
+
+/* This file has to be included because the tested functions are static */
+#include "memfile.c"
+
+#define index_to_key(i) ((i) ^ 15167)
+#define TEST_COUNT 50000
+
+static void test_mf_hash __ARGS((void));
+
+/*
+ * Test mf_hash_*() functions.
+ */
+    static void
+test_mf_hash()
+{
+    mf_hashtab_T   ht;
+    mf_hashitem_T  *item;
+    blocknr_T      key;
+    long_u	   i;
+    long_u	   num_buckets;
+
+    mf_hash_init(&ht);
+
+    /* insert some items and check invariants */
+    for (i = 0; i < TEST_COUNT; i++)
+    {
+	assert(ht.mht_count == i);
+
+	/* check that number of buckets is a power of 2 */
+	num_buckets = ht.mht_mask + 1;
+	assert(num_buckets > 0 && (num_buckets & (num_buckets - 1)) == 0);
+
+	/* check load factor */
+	assert(ht.mht_count <= (num_buckets << MHT_LOG_LOAD_FACTOR));
+
+	if (i < (MHT_INIT_SIZE << MHT_LOG_LOAD_FACTOR))
+	{
+	    /* first expansion shouldn't have occurred yet */
+	    assert(num_buckets == MHT_INIT_SIZE);
+	    assert(ht.mht_buckets == ht.mht_small_buckets);
+	}
+	else
+	{
+	    assert(num_buckets > MHT_INIT_SIZE);
+	    assert(ht.mht_buckets != ht.mht_small_buckets);
+	}
+
+	key = index_to_key(i);
+	assert(mf_hash_find(&ht, key) == NULL);
+
+	/* allocate and add new item */
+	item = (mf_hashitem_T *)lalloc_clear(sizeof(mf_hashtab_T), FALSE);
+	assert(item != NULL);
+	item->mhi_key = key;
+	mf_hash_add_item(&ht, item);
+
+	assert(mf_hash_find(&ht, key) == item);
+
+	if (ht.mht_mask + 1 != num_buckets)
+	{
+	    /* hash table was expanded */
+	    assert(ht.mht_mask + 1 == num_buckets * MHT_GROWTH_FACTOR);
+	    assert(i + 1 == (num_buckets << MHT_LOG_LOAD_FACTOR));
+	}
+    }
+
+    /* check presence of inserted items */
+    for (i = 0; i < TEST_COUNT; i++)
+    {
+	key = index_to_key(i);
+	item = mf_hash_find(&ht, key);
+	assert(item != NULL);
+	assert(item->mhi_key == key);
+    }
+
+    /* delete some items */
+    for (i = 0; i < TEST_COUNT; i++)
+    {
+	if (i % 100 < 70)
+	{
+	    key = index_to_key(i);
+	    item = mf_hash_find(&ht, key);
+	    assert(item != NULL);
+	    assert(item->mhi_key == key);
+
+	    mf_hash_rem_item(&ht, item);
+	    assert(mf_hash_find(&ht, key) == NULL);
+
+	    mf_hash_add_item(&ht, item);
+	    assert(mf_hash_find(&ht, key) == item);
+
+	    mf_hash_rem_item(&ht, item);
+	    assert(mf_hash_find(&ht, key) == NULL);
+
+	    vim_free(item);
+	}
+    }
+
+    /* check again */
+    for (i = 0; i < TEST_COUNT; i++)
+    {
+	key = index_to_key(i);
+	item = mf_hash_find(&ht, key);
+
+	if (i % 100 < 70)
+	{
+	    assert(item == NULL);
+	}
+	else
+	{
+	    assert(item != NULL);
+	    assert(item->mhi_key == key);
+	}
+    }
+
+    /* free hash table and all remaining items */
+    mf_hash_free_all(&ht);
+}
+
+    int
+main()
+{
+    test_mf_hash();
+    return 0;
+}
diff -Naur vim73.orig/src/memline.c vim73/src/memline.c
--- vim73.orig/src/memline.c	2010-08-08 13:11:46.000000000 +0000
+++ vim73/src/memline.c	2011-05-17 09:39:31.615918649 +0000
@@ -42,10 +42,6 @@
  *  mf_get().
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for mch_open(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 #ifndef UNIX		/* it's in os_unix.h for Unix */
@@ -56,10 +52,6 @@
 # include <proto/dos.h>	    /* for Open() and Close() */
 #endif
 
-#ifdef HAVE_ERRNO_H
-# include <errno.h>
-#endif
-
 typedef struct block0		ZERO_BL;    /* contents of the first block */
 typedef struct pointer_block	PTR_BL;	    /* contents of a pointer block */
 typedef struct data_block	DATA_BL;    /* contents of a data block */
@@ -582,6 +574,9 @@
 	    idx = ip->ip_index + 1;	    /* go to next index */
 	    page_count = 1;
 	}
+
+	if (error > 0)
+	    EMSG(_("E843: Error while updating swap file crypt"));
     }
 
     mfp->mf_old_key = NULL;
@@ -753,7 +748,7 @@
 	    continue;
 	if (mf_open_file(mfp, fname) == OK)	/* consumes fname! */
 	{
-#if defined(MSDOS) || defined(MSWIN) || defined(RISCOS)
+#if defined(MSDOS) || defined(MSWIN)
 	    /*
 	     * set full pathname for swap file now, because a ":!cd dir" may
 	     * change directory without us knowing it.
@@ -938,7 +933,7 @@
 	b0p->b0_fname[0] = NUL;
     else
     {
-#if defined(MSDOS) || defined(MSWIN) || defined(AMIGA) || defined(RISCOS)
+#if defined(MSDOS) || defined(MSWIN) || defined(AMIGA)
 	/* Systems that cannot translate "~user" back into a path: copy the
 	 * file name unmodified.  Do use slashes instead of backslashes for
 	 * portability. */
@@ -1108,7 +1103,7 @@
 	fname = (char_u *)"";
     len = (int)STRLEN(fname);
     if (len >= 4 &&
-#if defined(VMS) || defined(RISCOS)
+#if defined(VMS)
 	    STRNICMP(fname + len - 4, "_s" , 2)
 #else
 	    STRNICMP(fname + len - 4, ".s" , 2)
@@ -1778,11 +1773,7 @@
 #ifdef VMS
 		names[0] = vim_strsave((char_u *)"*_sw%");
 #else
-# ifdef RISCOS
-		names[0] = vim_strsave((char_u *)"*_sw#");
-# else
 		names[0] = vim_strsave((char_u *)"*.sw?");
-# endif
 #endif
 #if defined(UNIX) || defined(WIN3264)
 		/* For Unix names starting with a dot are special.  MS-Windows
@@ -1809,11 +1800,7 @@
 #ifdef VMS
 		names[0] = concat_fnames(dir_name, (char_u *)"*_sw%", TRUE);
 #else
-# ifdef RISCOS
-		names[0] = concat_fnames(dir_name, (char_u *)"*_sw#", TRUE);
-# else
 		names[0] = concat_fnames(dir_name, (char_u *)"*.sw?", TRUE);
-# endif
 #endif
 #if defined(UNIX) || defined(WIN3264)
 		/* For Unix names starting with a dot are special.  MS-Windows
@@ -1882,7 +1869,7 @@
 	    char_u	    *swapname;
 
 	    swapname = modname(fname_res,
-#if defined(VMS) || defined(RISCOS)
+#if defined(VMS)
 			       (char_u *)"_swp", FALSE
 #else
 			       (char_u *)".swp", TRUE
@@ -2059,7 +2046,7 @@
     fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);
     if (fd >= 0)
     {
-	if (read(fd, (char *)&b0, sizeof(b0)) == sizeof(b0))
+	if (read_eintr(fd, &b0, sizeof(b0)) == sizeof(b0))
 	{
 	    if (STRNCMP(b0.b0_version, "VIM 3.0", 7) == 0)
 	    {
@@ -2181,11 +2168,7 @@
 #ifdef VMS
     names[num_names] = concat_fnames(path, (char_u *)"_sw%", FALSE);
 #else
-# ifdef RISCOS
-    names[num_names] = concat_fnames(path, (char_u *)"_sw#", FALSE);
-# else
     names[num_names] = concat_fnames(path, (char_u *)".sw?", FALSE);
-# endif
 #endif
     if (names[num_names] == NULL)
 	goto end;
@@ -2212,11 +2195,7 @@
 #ifdef VMS
     names[num_names] = modname(path, (char_u *)"_sw%", FALSE);
 #else
-# ifdef RISCOS
-    names[num_names] = modname(path, (char_u *)"_sw#", FALSE);
-# else
     names[num_names] = modname(path, (char_u *)".sw?", FALSE);
-# endif
 #endif
     if (names[num_names] == NULL)
 	goto end;
@@ -2384,7 +2363,7 @@
  * Make a copy of the line if necessary.
  */
 /*
- * get a pointer to a (read-only copy of a) line
+ * Return a pointer to a (read-only copy of a) line.
  *
  * On failure an error message is given and IObuff is returned (to avoid
  * having to check for error everywhere).
@@ -2397,7 +2376,7 @@
 }
 
 /*
- * ml_get_pos: get pointer to position 'pos'
+ * Return pointer to position "pos".
  */
     char_u *
 ml_get_pos(pos)
@@ -2407,7 +2386,7 @@
 }
 
 /*
- * ml_get_curline: get pointer to cursor line.
+ * Return pointer to cursor line.
  */
     char_u *
 ml_get_curline()
@@ -2416,7 +2395,7 @@
 }
 
 /*
- * ml_get_cursor: get pointer to cursor position
+ * Return pointer to cursor position.
  */
     char_u *
 ml_get_cursor()
@@ -2426,7 +2405,7 @@
 }
 
 /*
- * get a pointer to a line in a specific buffer
+ * Return a pointer to a line in a specific buffer
  *
  * "will_change": if TRUE mark the buffer dirty (chars in the line will be
  * changed)
@@ -3210,7 +3189,8 @@
 	mf_free(mfp, hp);	/* free the data block */
 	buf->b_ml.ml_locked = NULL;
 
-	for (stack_idx = buf->b_ml.ml_stack_top - 1; stack_idx >= 0; --stack_idx)
+	for (stack_idx = buf->b_ml.ml_stack_top - 1; stack_idx >= 0;
+								  --stack_idx)
 	{
 	    buf->b_ml.ml_stack_top = 0;	    /* stack is invalid when failing */
 	    ip = &(buf->b_ml.ml_stack[stack_idx]);
@@ -3961,14 +3941,9 @@
 #else
 	    (buf->b_p_sn || buf->b_shortname),
 #endif
-#ifdef RISCOS
-	    /* Avoid problems if fname has special chars, eg <Wimp$Scrap> */
-	    ffname,
-#else
 	    fname_res,
-#endif
 	    (char_u *)
-#if defined(VMS) || defined(RISCOS)
+#if defined(VMS)
 	    "_swp",
 #else
 	    ".swp",
@@ -4076,9 +4051,9 @@
     }
     /* Some of these messages are long to allow translation to
      * other languages. */
-    MSG_PUTS(_("\n(1) Another program may be editing the same file.\n    If this is the case, be careful not to end up with two\n    different instances of the same file when making changes.\n"));
-    MSG_PUTS(_("    Quit, or continue with caution.\n"));
-    MSG_PUTS(_("\n(2) An edit session for this file crashed.\n"));
+    MSG_PUTS(_("\n(1) Another program may be editing the same file.  If this is the case,\n    be careful not to end up with two different instances of the same\n    file when making changes."));
+    MSG_PUTS(_("  Quit, or continue with caution.\n"));
+    MSG_PUTS(_("(2) An edit session for this file crashed.\n"));
     MSG_PUTS(_("    If this is the case, use \":recover\" or \"vim -r "));
     msg_outtrans(buf->b_fname);
     MSG_PUTS(_("\"\n    to recover the changes (see \":help recovery\").\n"));
@@ -4389,7 +4364,7 @@
 		fd = mch_open((char *)fname, O_RDONLY | O_EXTRA, 0);
 		if (fd >= 0)
 		{
-		    if (read(fd, (char *)&b0, sizeof(b0)) == sizeof(b0))
+		    if (read_eintr(fd, &b0, sizeof(b0)) == sizeof(b0))
 		    {
 			/*
 			 * If the swapfile has the same directory as the
@@ -4432,14 +4407,6 @@
 		    }
 		    close(fd);
 		}
-#ifdef RISCOS
-		else
-		    /* Can't open swap file, though it does exist.
-		     * Assume that the user is editing two files with
-		     * the same name in different directories. No error.
-		     */
-		    differ = TRUE;
-#endif
 
 		/* give the ATTENTION message when there is an old swap file
 		 * for the current file, and the buffer was not recovered. */
@@ -4521,7 +4488,7 @@
 				    process_still_running
 					? (char_u *)_("&Open Read-Only\n&Edit anyway\n&Recover\n&Quit\n&Abort") :
 # endif
-					(char_u *)_("&Open Read-Only\n&Edit anyway\n&Recover\n&Delete it\n&Quit\n&Abort"), 1, NULL);
+					(char_u *)_("&Open Read-Only\n&Edit anyway\n&Recover\n&Delete it\n&Quit\n&Abort"), 1, NULL, FALSE);
 
 # if defined(UNIX) || defined(__EMX__) || defined(VMS)
 			if (process_still_running && choice >= 4)
diff -Naur vim73.orig/src/menu.c vim73/src/menu.c
--- vim73.orig/src/menu.c	2010-07-14 14:49:01.000000000 +0000
+++ vim73/src/menu.c	2011-05-17 09:38:27.315055146 +0000
@@ -1394,7 +1394,8 @@
     int		idx;
 {
     static vimmenu_T	*menu = NULL;
-    static char_u	tbuffer[256]; /*hack*/
+#define TBUFFER_LEN 256
+    static char_u	tbuffer[TBUFFER_LEN]; /*hack*/
     char_u		*str;
 #ifdef FEAT_MULTI_LANG
     static  int		should_advance = FALSE;
@@ -1428,11 +1429,11 @@
 	{
 #ifdef FEAT_MULTI_LANG
 	    if (should_advance)
-		STRCPY(tbuffer, menu->en_dname);
+		vim_strncpy(tbuffer, menu->en_dname, TBUFFER_LEN - 2);
 	    else
 	    {
 #endif
-		STRCPY(tbuffer, menu->dname);
+		vim_strncpy(tbuffer, menu->dname,  TBUFFER_LEN - 2);
 #ifdef FEAT_MULTI_LANG
 		if (menu->en_dname == NULL)
 		    should_advance = TRUE;
@@ -1512,8 +1513,8 @@
 {
 #ifdef FEAT_MULTI_LANG
     if (menu->en_name != NULL
-	    && (menu_namecmp(name,menu->en_name)
-		|| menu_namecmp(name,menu->en_dname)))
+	    && (menu_namecmp(name, menu->en_name)
+		|| menu_namecmp(name, menu->en_dname)))
 	return TRUE;
 #endif
     return menu_namecmp(name, menu->name) || menu_namecmp(name, menu->dname);
@@ -2342,7 +2343,7 @@
 
 	while (menu != NULL)
 	{
-	    if (STRCMP(name, menu->name) == 0 || STRCMP(name, menu->dname) == 0)
+	    if (menu_name_equal(name, menu))
 	    {
 		if (menu->children == NULL)
 		{
diff -Naur vim73.orig/src/message.c vim73/src/message.c
--- vim73.orig/src/message.c	2010-08-04 18:10:02.000000000 +0000
+++ vim73/src/message.c	2011-05-17 09:37:38.700450741 +0000
@@ -569,6 +569,10 @@
     int		severe;
 #endif
 
+    /* Skip this if not giving error messages at the moment. */
+    if (emsg_not_now())
+	return TRUE;
+
     called_emsg = TRUE;
     ex_exitval = 1;
 
@@ -581,10 +585,6 @@
     emsg_severe = FALSE;
 #endif
 
-    /* Skip this if not giving error messages at the moment. */
-    if (emsg_not_now())
-	return TRUE;
-
     if (!emsg_off || vim_strchr(p_debug, 't') != NULL)
     {
 #ifdef FEAT_EVAL
@@ -879,16 +879,17 @@
     if (msg_silent != 0)
 	return;
 
-/*
- * With the global command (and some others) we only need one return at the
- * end. Adjust cmdline_row to avoid the next message overwriting the last one.
- * When inside vgetc(), we can't wait for a typed character at all.
- */
+    /*
+     * When inside vgetc(), we can't wait for a typed character at all.
+     * With the global command (and some others) we only need one return at
+     * the end. Adjust cmdline_row to avoid the next message overwriting the
+     * last one.
+     */
     if (vgetc_busy > 0)
 	return;
+    need_wait_return = TRUE;
     if (no_wait_return)
     {
-	need_wait_return = TRUE;
 	if (!exmode_active)
 	    cmdline_row = msg_row;
 	return;
@@ -1477,6 +1478,27 @@
     return retval;
 }
 
+#if defined(FEAT_EVAL) || defined(PROTO)
+/*
+ * Return the lhs or rhs of a mapping, with the key codes turned into printable
+ * strings, in an allocated string.
+ */
+    char_u *
+str2special_save(str, is_lhs)
+    char_u  *str;
+    int	    is_lhs;  /* TRUE for lhs, FALSE for rhs */
+{
+    garray_T	ga;
+    char_u	*p = str;
+
+    ga_init2(&ga, 1, 40);
+    while (*p != NUL)
+	ga_concat(&ga, str2special(&p, is_lhs));
+    ga_append(&ga, NUL);
+    return (char_u *)ga.ga_data;
+}
+#endif
+
 /*
  * Return the printable string for the key codes at "*sp".
  * Used for translating the lhs or rhs of a mapping to printable chars.
@@ -1616,8 +1638,16 @@
 	else if (has_mbyte && (l = (*mb_ptr2len)(s)) > 1)
 	{
 	    col += (*mb_ptr2cells)(s);
-	    mch_memmove(buf, s, (size_t)l);
-	    buf[l] = NUL;
+	    if (lcs_nbsp != NUL && list && mb_ptr2char(s) == 160)
+	    {
+		mb_char2bytes(lcs_nbsp, buf);
+		buf[(*mb_ptr2len)(buf)] = NUL;
+	    }
+	    else
+	    {
+		mch_memmove(buf, s, (size_t)l);
+		buf[l] = NUL;
+	    }
 	    msg_puts(buf);
 	    s += l;
 	    continue;
@@ -1643,6 +1673,11 @@
 		    attr = hl_attr(HLF_8);
 		}
 	    }
+	    else if (c == 160 && list && lcs_nbsp != NUL)
+	    {
+		c = lcs_nbsp;
+		attr = hl_attr(HLF_8);
+	    }
 	    else if (c == NUL && list && lcs_eol != NUL)
 	    {
 		p_extra = (char_u *)"";
@@ -3294,7 +3329,7 @@
  * different letter.
  */
     int
-do_dialog(type, title, message, buttons, dfltbutton, textfield)
+do_dialog(type, title, message, buttons, dfltbutton, textfield, ex_cmd)
     int		type UNUSED;
     char_u	*title UNUSED;
     char_u	*message;
@@ -3302,6 +3337,8 @@
     int		dfltbutton;
     char_u	*textfield UNUSED;	/* IObuff for inputdialog(), NULL
 					   otherwise */
+    int		ex_cmd;	    /* when TRUE pressing : accepts default and starts
+			       Ex command */
 {
     int		oldState;
     int		retval = 0;
@@ -3320,7 +3357,7 @@
     if (gui.in_use && vim_strchr(p_go, GO_CONDIALOG) == NULL)
     {
 	c = gui_mch_dialog(type, title, message, buttons, dfltbutton,
-								   textfield);
+							   textfield, ex_cmd);
 	/* avoid a hit-enter prompt without clearing the cmdline */
 	need_wait_return = FALSE;
 	emsg_on_display = FALSE;
@@ -3367,6 +3404,13 @@
 	    default:		/* Could be a hotkey? */
 		if (c < 0)	/* special keys are ignored here */
 		    continue;
+		if (c == ':' && ex_cmd)
+		{
+		    retval = dfltbutton;
+		    ins_char_typebuf(':');
+		    break;
+		}
+
 		/* Make the character lowercase, as chars in "hotkeys" are. */
 		c = MB_TOLOWER(c);
 		retval = 1;
@@ -3640,7 +3684,7 @@
     if (do_dialog(type,
 		title == NULL ? (char_u *)_("Question") : title,
 		message,
-		(char_u *)_("&Yes\n&No"), dflt, NULL) == 1)
+		(char_u *)_("&Yes\n&No"), dflt, NULL, FALSE) == 1)
 	return VIM_YES;
     return VIM_NO;
 }
@@ -3655,7 +3699,7 @@
     switch (do_dialog(type,
 		title == NULL ? (char_u *)_("Question") : title,
 		message,
-		(char_u *)_("&Yes\n&No\n&Cancel"), dflt, NULL))
+		(char_u *)_("&Yes\n&No\n&Cancel"), dflt, NULL, FALSE))
     {
 	case 1: return VIM_YES;
 	case 2: return VIM_NO;
@@ -3674,7 +3718,7 @@
 		title == NULL ? (char_u *)"Question" : title,
 		message,
 		(char_u *)_("&Yes\n&No\nSave &All\n&Discard All\n&Cancel"),
-								  dflt, NULL))
+							   dflt, NULL, FALSE))
     {
 	case 1: return VIM_YES;
 	case 2: return VIM_NO;
diff -Naur vim73.orig/src/misc1.c vim73/src/misc1.c
--- vim73.orig/src/misc1.c	2010-08-15 11:24:05.000000000 +0000
+++ vim73/src/misc1.c	2011-05-17 09:39:31.615918649 +0000
@@ -1561,6 +1561,9 @@
     char_u	part_buf[COM_MAX_LEN];	/* buffer for one option part */
     char_u	*string;		/* pointer to comment string */
     char_u	*list;
+    int		middle_match_len = 0;
+    char_u	*prev_list;
+    char_u	*saved_flags = NULL;
 
     i = 0;
     while (vim_iswhite(line[i]))    /* leading white space is ignored */
@@ -1569,7 +1572,7 @@
     /*
      * Repeat to match several nested comment strings.
      */
-    while (line[i])
+    while (line[i] != NUL)
     {
 	/*
 	 * scan through the 'comments' option for a match
@@ -1577,82 +1580,104 @@
 	found_one = FALSE;
 	for (list = curbuf->b_p_com; *list; )
 	{
-	    /*
-	     * Get one option part into part_buf[].  Advance list to next one.
-	     * put string at start of string.
-	     */
-	    if (!got_com && flags != NULL)  /* remember where flags started */
-		*flags = list;
+	    /* Get one option part into part_buf[].  Advance "list" to next
+	     * one.  Put "string" at start of string.  */
+	    if (!got_com && flags != NULL)
+		*flags = list;	    /* remember where flags started */
+	    prev_list = list;
 	    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, ",");
 	    string = vim_strchr(part_buf, ':');
 	    if (string == NULL)	    /* missing ':', ignore this part */
 		continue;
 	    *string++ = NUL;	    /* isolate flags from string */
 
-	    /*
-	     * When already found a nested comment, only accept further
-	     * nested comments.
-	     */
+	    /* If we found a middle match previously, use that match when this
+	     * is not a middle or end. */
+	    if (middle_match_len != 0
+		    && vim_strchr(part_buf, COM_MIDDLE) == NULL
+		    && vim_strchr(part_buf, COM_END) == NULL)
+		break;
+
+	    /* When we already found a nested comment, only accept further
+	     * nested comments. */
 	    if (got_com && vim_strchr(part_buf, COM_NEST) == NULL)
 		continue;
 
-	    /* When 'O' flag used don't use for "O" command */
+	    /* When 'O' flag present and using "O" command skip this one. */
 	    if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)
 		continue;
 
-	    /*
-	     * Line contents and string must match.
+	    /* Line contents and string must match.
 	     * When string starts with white space, must have some white space
 	     * (but the amount does not need to match, there might be a mix of
-	     * TABs and spaces).
-	     */
+	     * TABs and spaces). */
 	    if (vim_iswhite(string[0]))
 	    {
 		if (i == 0 || !vim_iswhite(line[i - 1]))
-		    continue;
+		    continue;  /* missing shite space */
 		while (vim_iswhite(string[0]))
 		    ++string;
 	    }
 	    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)
 		;
 	    if (string[j] != NUL)
-		continue;
+		continue;  /* string doesn't match */
 
-	    /*
-	     * When 'b' flag used, there must be white space or an
-	     * end-of-line after the string in the line.
-	     */
+	    /* When 'b' flag used, there must be white space or an
+	     * end-of-line after the string in the line. */
 	    if (vim_strchr(part_buf, COM_BLANK) != NULL
 			   && !vim_iswhite(line[i + j]) && line[i + j] != NUL)
 		continue;
 
-	    /*
-	     * We have found a match, stop searching.
-	     */
-	    i += j;
-	    got_com = TRUE;
+	    /* We have found a match, stop searching unless this is a middle
+	     * comment. The middle comment can be a substring of the end
+	     * comment in which case it's better to return the length of the
+	     * end comment and its flags.  Thus we keep searching with middle
+	     * and end matches and use an end match if it matches better. */
+	    if (vim_strchr(part_buf, COM_MIDDLE) != NULL)
+	    {
+		if (middle_match_len == 0)
+		{
+		    middle_match_len = j;
+		    saved_flags = prev_list;
+		}
+		continue;
+	    }
+	    if (middle_match_len != 0 && j > middle_match_len)
+		/* Use this match instead of the middle match, since it's a
+		 * longer thus better match. */
+		middle_match_len = 0;
+
+	    if (middle_match_len == 0)
+		i += j;
 	    found_one = TRUE;
 	    break;
 	}
 
-	/*
-	 * No match found, stop scanning.
-	 */
+	if (middle_match_len != 0)
+	{
+	    /* Use the previously found middle match after failing to find a
+	     * match with an end. */
+	    if (!got_com && flags != NULL)
+		*flags = saved_flags;
+	    i += middle_match_len;
+	    found_one = TRUE;
+	}
+
+	/* No match found, stop scanning. */
 	if (!found_one)
 	    break;
 
-	/*
-	 * Include any trailing white space.
-	 */
+	/* Include any trailing white space. */
 	while (vim_iswhite(line[i]))
 	    ++i;
 
-	/*
-	 * If this comment doesn't nest, stop here.
-	 */
+	/* If this comment doesn't nest, stop here. */
+	got_com = TRUE;
 	if (vim_strchr(part_buf, COM_NEST) == NULL)
 	    break;
     }
+
     return (got_com ? i : 0);
 }
 #endif
@@ -2919,7 +2944,7 @@
     buf_T	*buf;
     int		ff;	/* also reset 'fileformat' */
 {
-    if (buf->b_changed || (ff && file_ff_differs(buf)))
+    if (buf->b_changed || (ff && file_ff_differs(buf, FALSE)))
     {
 	buf->b_changed = 0;
 	ml_setflags(buf);
@@ -3114,10 +3139,19 @@
 	       && (!p_ttimeout || waited * 100L < (p_ttm < 0 ? p_tm : p_ttm)))
 	    continue;
 
-	/* found a termcode: adjust length */
-	if (n > 0)
+	if (n == KEYLEN_REMOVED)  /* key code removed */
+	{
+	    if (must_redraw != 0 && !need_wait_return && (State & CMDLINE) == 0)
+	    {
+		/* Redrawing was postponed, do it now. */
+		update_screen(0);
+		setcursor(); /* put cursor back where it belongs */
+	    }
+	    continue;
+	}
+	if (n > 0)		/* found a termcode: adjust length */
 	    len = n;
-	if (len == 0)	    /* nothing typed yet */
+	if (len == 0)		/* nothing typed yet */
 	    continue;
 
 	/* Handle modifier and/or special key code. */
@@ -3323,19 +3357,23 @@
 	if (pn == 1)
 	{
 	    if (n > 0)
-		STRCPY(msg_buf, _("1 more line"));
+		vim_strncpy(msg_buf, (char_u *)_("1 more line"),
+							     MSG_BUF_LEN - 1);
 	    else
-		STRCPY(msg_buf, _("1 line less"));
+		vim_strncpy(msg_buf, (char_u *)_("1 line less"),
+							     MSG_BUF_LEN - 1);
 	}
 	else
 	{
 	    if (n > 0)
-		sprintf((char *)msg_buf, _("%ld more lines"), pn);
+		vim_snprintf((char *)msg_buf, MSG_BUF_LEN,
+						     _("%ld more lines"), pn);
 	    else
-		sprintf((char *)msg_buf, _("%ld fewer lines"), pn);
+		vim_snprintf((char *)msg_buf, MSG_BUF_LEN,
+						    _("%ld fewer lines"), pn);
 	}
 	if (got_int)
-	    STRCAT(msg_buf, _(" (Interrupted)"));
+	    vim_strcat(msg_buf, (char_u *)_(" (Interrupted)"), MSG_BUF_LEN);
 	if (msg(msg_buf))
 	{
 	    set_keep_msg(msg_buf, 0);
@@ -3492,7 +3530,7 @@
     if (enc_utf8 && var != NULL)
     {
 	int	len;
-	char_u  *pp;
+	char_u  *pp = NULL;
 
 	/* Convert from active codepage to UTF-8.  Other conversions are
 	 * not done, because they would fail for non-ASCII characters. */
@@ -3859,11 +3897,13 @@
  * Vim's version of getenv().
  * Special handling of $HOME, $VIM and $VIMRUNTIME.
  * Also does ACP to 'enc' conversion for Win32.
+ * "mustfree" is set to TRUE when returned is allocated, it must be
+ * initialized to FALSE by the caller.
  */
     char_u *
 vim_getenv(name, mustfree)
     char_u	*name;
-    int		*mustfree;	/* set to TRUE when returned is allocated */
+    int		*mustfree;
 {
     char_u	*p;
     char_u	*pend;
@@ -3885,7 +3925,7 @@
 	if (enc_utf8)
 	{
 	    int	    len;
-	    char_u  *pp;
+	    char_u  *pp = NULL;
 
 	    /* Convert from active codepage to UTF-8.  Other conversions are
 	     * not done, because they would fail for non-ASCII characters. */
@@ -3929,7 +3969,7 @@
 	    if (enc_utf8)
 	    {
 		int	len;
-		char_u  *pp;
+		char_u  *pp = NULL;
 
 		/* Convert from active codepage to UTF-8.  Other conversions
 		 * are not done, because they would fail for non-ASCII
@@ -3937,7 +3977,7 @@
 		acp_to_enc(p, (int)STRLEN(p), &pp, &len);
 		if (pp != NULL)
 		{
-		    if (mustfree)
+		    if (*mustfree)
 			vim_free(p);
 		    p = pp;
 		    *mustfree = TRUE;
@@ -4549,25 +4589,21 @@
 vim_ispathsep(c)
     int c;
 {
-#ifdef RISCOS
-    return (c == '.' || c == ':');
-#else
-# ifdef UNIX
+#ifdef UNIX
     return (c == '/');	    /* UNIX has ':' inside file names */
-# else
-#  ifdef BACKSLASH_IN_FILENAME
+#else
+# ifdef BACKSLASH_IN_FILENAME
     return (c == ':' || c == '/' || c == '\\');
-#  else
-#   ifdef VMS
+# else
+#  ifdef VMS
     /* server"user passwd"::device:[full.path.name]fname.extension;version" */
     return (c == ':' || c == '[' || c == ']' || c == '/'
 	    || c == '<' || c == '>' || c == '"' );
-#   else		/* Amiga */
+#  else
     return (c == ':' || c == '/');
-#   endif /* VMS */
-#  endif
+#  endif /* VMS */
 # endif
-#endif /* RISC OS */
+#endif
 }
 
 #if defined(FEAT_SEARCHPATH) || defined(PROTO)
@@ -4968,7 +5004,7 @@
 }
 
 /*
- * Return TRUE if there there is no code at *s.  White space and comments are
+ * Return TRUE if there is no code at *s.  White space and comments are
  * not considered code.
  */
     static int
@@ -5383,8 +5419,7 @@
 cin_ispreproc(s)
     char_u *s;
 {
-    s = skipwhite(s);
-    if (*s == '#')
+    if (*skipwhite(s) == '#')
 	return TRUE;
     return FALSE;
 }
@@ -5444,8 +5479,11 @@
 }
 
 /*
- * Recognize a line that starts with '{' or '}', or ends with ';', '{' or '}'.
+ * Recognize a line that starts with '{' or '}', or ends with ';', ',', '{' or
+ * '}'.
  * Don't consider "} else" a terminated line.
+ * Don't consider a line where there are unmatched opening braces before '}',
+ * ';' or ',' a terminated line.
  * Return the character terminating the line (ending char's have precedence if
  * both apply in order to determine initializations).
  */
@@ -5456,6 +5494,7 @@
     int		incl_comma;	/* recognize a trailing comma */
 {
     char_u found_start = 0;
+    unsigned n_open = 0;
 
     s = cin_skipcomment(s);
 
@@ -5466,10 +5505,19 @@
     {
 	/* skip over comments, "" strings and 'c'haracters */
 	s = skip_string(cin_skipcomment(s));
-	if ((*s == ';' || (incl_open && *s == '{') || *s == '}'
-						 || (incl_comma && *s == ','))
+	if (*s == '}' && n_open > 0)
+	    --n_open;
+	if (n_open == 0
+		&& (*s == ';' || *s == '}' || (incl_comma && *s == ','))
 		&& cin_nocode(s + 1))
 	    return *s;
+	else if (*s == '{')
+	{
+	    if (incl_open && cin_nocode(s + 1))
+		return *s;
+	    else
+		++n_open;
+	}
 
 	if (*s)
 	    s++;
@@ -5500,6 +5548,10 @@
     else
 	s = *sp;
 
+    /* Ignore line starting with #. */
+    if (cin_ispreproc(s))
+	return FALSE;
+
     while (*s && *s != '(' && *s != ';' && *s != '\'' && *s != '"')
     {
 	if (cin_iscomment(s))	/* ignore comments */
@@ -5525,13 +5577,29 @@
 		retval = TRUE;
 	    goto done;
 	}
-	if (*s == ',' && cin_nocode(s + 1))
+	if ((*s == ',' && cin_nocode(s + 1)) || s[1] == NUL || cin_nocode(s))
 	{
-	    /* ',' at the end: continue looking in the next line */
+	    int comma = (*s == ',');
+
+	    /* ',' at the end: continue looking in the next line.
+	     * At the end: check for ',' in the next line, for this style:
+	     * func(arg1
+	     *       , arg2) */
+	    for (;;)
+	    {
+		if (lnum >= curbuf->b_ml.ml_line_count)
+		    break;
+		s = ml_get(++lnum);
+		if (!cin_ispreproc(s))
+		    break;
+	    }
 	    if (lnum >= curbuf->b_ml.ml_line_count)
 		break;
-
-	    s = ml_get(++lnum);
+	    /* Require a comma at end of the line or a comma or ')' at the
+	     * start of next line. */
+	    s = skipwhite(s);
+	    if (!comma && *s != ',' && *s != ')')
+		break;
 	}
 	else if (cin_iscomment(s))	/* ignore comments */
 	    s = cin_skipcomment(s);
@@ -5754,7 +5822,9 @@
 		continue;
 	}
 
-	if (s[0] == ':')
+	if (s[0] == '"')
+	    s = skip_string(s) + 1;
+	else if (s[0] == ':')
 	{
 	    if (s[1] == ':')
 	    {
@@ -6424,6 +6494,8 @@
 	/* find how indented the line beginning the comment is */
 	getvcol(curwin, trypos, &col, NULL, NULL);
 	amount = col;
+	*lead_start = NUL;
+	*lead_middle = NUL;
 
 	p = curbuf->b_p_com;
 	while (*p != NUL)
@@ -6764,8 +6836,7 @@
 		{
 		    curwin->w_cursor.lnum = our_paren_pos.lnum;
 		    curwin->w_cursor.col = col;
-		    if ((trypos = find_match_paren(ind_maxparen,
-						     ind_maxcomment)) != NULL)
+		    if (find_match_paren(ind_maxparen, ind_maxcomment) != NULL)
 			amount += ind_unclosed2;
 		    else
 			amount += ind_unclosed;
@@ -9161,7 +9232,10 @@
 #ifdef CASE_INSENSITIVE_FILENAME
     regmatch.rm_ic = TRUE;		/* Behave like Terminal.app */
 #else
-    regmatch.rm_ic = FALSE;		/* Don't ever ignore case */
+    if (flags & EW_ICASE)
+	regmatch.rm_ic = TRUE;		/* 'wildignorecase' set */
+    else
+	regmatch.rm_ic = FALSE;		/* Don't ignore case */
 #endif
     regmatch.regprog = vim_regcomp(pat, RE_MAGIC);
     vim_free(pat);
@@ -9317,7 +9391,8 @@
 	    continue;  /* it's different when it's shorter */
 
 	rival = other_paths[j] + other_path_len - candidate_len;
-	if (fnamecmp(maybe_unique, rival) == 0)
+	if (fnamecmp(maybe_unique, rival) == 0
+		&& (rival == other_paths[j] || vim_ispathsep(*(rival - 1))))
 	    return FALSE;  /* match */
     }
 
@@ -9642,7 +9717,7 @@
     if (paths == NULL)
 	return 0;
 
-    files = globpath(paths, pattern, 0);
+    files = globpath(paths, pattern, (flags & EW_ICASE) ? WILD_ICASE : 0);
     vim_free(paths);
     if (files == NULL)
 	return 0;
diff -Naur vim73.orig/src/misc2.c vim73/src/misc2.c
--- vim73.orig/src/misc2.c	2010-08-13 09:14:35.000000000 +0000
+++ vim73/src/misc2.c	2011-05-17 09:38:27.323054258 +0000
@@ -200,7 +200,6 @@
 	}
 #endif
 
-	idx = -1;
 	ptr = line;
 	while (col <= wcol && *ptr != NUL)
 	{
@@ -1223,7 +1222,7 @@
 #endif
 
 /*
- * copy a string into newly allocated memory
+ * Copy "string" into newly allocated memory.
  */
     char_u *
 vim_strsave(string)
@@ -1239,6 +1238,12 @@
     return p;
 }
 
+/*
+ * Copy up to "len" bytes of "string" into newly allocated memory and
+ * terminate with a NUL.
+ * The allocated memory always has size "len + 1", also when "string" is
+ * shorter.
+ */
     char_u *
 vim_strnsave(string, len)
     char_u	*string;
@@ -1642,6 +1647,28 @@
 }
 
 /*
+ * Like strcat(), but make sure the result fits in "tosize" bytes and is
+ * always NUL terminated.
+ */
+    void
+vim_strcat(to, from, tosize)
+    char_u	*to;
+    char_u	*from;
+    size_t	tosize;
+{
+    size_t tolen = STRLEN(to);
+    size_t fromlen = STRLEN(from);
+
+    if (tolen + fromlen + 1 > tosize)
+    {
+	mch_memmove(to + tolen, from, tosize - tolen - 1);
+	to[tosize - 1] = NUL;
+    }
+    else
+	STRCPY(to + tolen, from);
+}
+
+/*
  * Isolate one part of a string option where parts are separated with
  * "sep_chars".
  * The part is copied into "buf[maxlen]".
diff -Naur vim73.orig/src/move.c vim73/src/move.c
--- vim73.orig/src/move.c	2010-08-08 13:12:31.000000000 +0000
+++ vim73/src/move.c	2011-05-17 09:36:34.391588266 +0000
@@ -2846,6 +2846,7 @@
     colnr_T	col =  curwin->w_cursor.col;
     win_T	*old_curwin = curwin;
     buf_T	*old_curbuf = curbuf;
+    int		restart_edit_save;
 # ifdef FEAT_VISUAL
     int		old_VIsual_select = VIsual_select;
     int		old_VIsual_active = VIsual_active;
@@ -2875,16 +2876,22 @@
 		curwin->w_cursor.lnum = line;
 	    curwin->w_cursor.col = col;
 
-	    /* Make sure the cursor is in a valid position. */
+	    /* Make sure the cursor is in a valid position.  Temporarily set
+	     * "restart_edit" to allow the cursor to be beyond the EOL. */
+	    restart_edit_save = restart_edit;
+	    restart_edit = TRUE;
 	    check_cursor();
+	    restart_edit = restart_edit_save;
 # ifdef FEAT_MBYTE
 	    /* Correct cursor for multi-byte character. */
 	    if (has_mbyte)
 		mb_adjust_cursor();
 # endif
-
 	    redraw_later(VALID);
-	    update_topline();
+
+	    /* Only scroll when 'scrollbind' hasn't done this. */
+	    if (!curwin->w_p_scb)
+		update_topline();
 # ifdef FEAT_WINDOWS
 	    curwin->w_redr_status = TRUE;
 # endif
diff -Naur vim73.orig/src/netbeans.c vim73/src/netbeans.c
--- vim73.orig/src/netbeans.c	2010-08-09 20:48:09.000000000 +0000
+++ vim73/src/netbeans.c	2011-05-17 09:38:29.894768831 +0000
@@ -16,10 +16,6 @@
  * See ":help netbeans-protocol" for explanation.
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for mch_open(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 #if defined(FEAT_NETBEANS_INTG) || defined(PROTO)
@@ -87,7 +83,7 @@
 static void nb_init_graphics __ARGS((void));
 static void coloncmd __ARGS((char *cmd, ...));
 static void nb_set_curbuf __ARGS((buf_T *buf));
-#ifdef FEAT_GUI_MOTIF
+#ifdef FEAT_GUI_X11
 static void messageFromNetbeans __ARGS((XtPointer, int *, XtInputId *));
 #endif
 #ifdef FEAT_GUI_GTK
@@ -112,7 +108,7 @@
 static NBSOCK nbsock = -1;		/* socket fd for Netbeans connection */
 #define NETBEANS_OPEN (nbsock != -1)
 
-#ifdef FEAT_GUI_MOTIF
+#ifdef FEAT_GUI_X11
 static XtInputId inputHandler = (XtInputId)NULL;  /* Cookie for input */
 #endif
 #ifdef FEAT_GUI_GTK
@@ -135,15 +131,13 @@
 static int needupdate = 0;
 static int inAtomic = 0;
 
+/*
+ * Close the socket and remove the input handlers.
+ */
     static void
-netbeans_close(void)
+nb_close_socket(void)
 {
-    if (!NETBEANS_OPEN)
-	return;
-
-    netbeans_send_disconnect();
-
-#ifdef FEAT_GUI_MOTIF
+#ifdef FEAT_GUI_X11
     if (inputHandler != (XtInputId)NULL)
     {
 	XtRemoveInput(inputHandler);
@@ -167,13 +161,27 @@
 # endif
 #endif
 
+    sock_close(nbsock);
+    nbsock = -1;
+}
+
+/*
+ * Close the connection and cleanup.
+ * May be called when nb_close_socket() was called earlier.
+ */
+    static void
+netbeans_close(void)
+{
+    if (NETBEANS_OPEN)
+    {
+	netbeans_send_disconnect();
+	nb_close_socket();
+    }
+
 #ifdef FEAT_BEVAL
     bevalServers &= ~BEVAL_NETBEANS;
 #endif
 
-    sock_close(nbsock);
-    nbsock = -1;
-
     needupdate = 0;
     inAtomic = 0;
     nb_free();
@@ -183,6 +191,7 @@
     changed_window_setting();
     update_screen(CLEAR);
     setcursor();
+    cursor_on();
     out_flush();
 #ifdef FEAT_GUI
     if (gui.in_use)
@@ -311,14 +320,9 @@
     server.sin_port = htons(port);
     if ((host = gethostbyname(hostname)) == NULL)
     {
-	if (mch_access(hostname, R_OK) >= 0)
-	{
-	    /* DEBUG: input file */
-	    sd = mch_open(hostname, O_RDONLY, 0);
-	    goto theend;
-	}
 	nbdebug(("error in gethostbyname() in netbeans_connect()\n"));
 	PERROR("gethostbyname() in netbeans_connect()");
+	sock_close(sd);
 	goto theend;
     }
     memcpy((char *)&server.sin_addr, host->h_addr, host->h_length);
@@ -368,15 +372,12 @@
 							 || (errno == EINTR)))
 		{
 		    nbdebug(("retrying...\n"));
-		    sleep(5);
-		    if (!doabort)
+		    mch_delay(3000L, TRUE);
+		    ui_breakcheck();
+		    if (got_int)
 		    {
-			ui_breakcheck();
-			if (got_int)
-			{
-			    errno = EINTR;
-			    break;
-			}
+			errno = EINTR;
+			break;
 		    }
 		    if (connect(sd, (struct sockaddr *)&server,
 							 sizeof(server)) == 0)
@@ -391,6 +392,7 @@
 		    /* Get here when the server can't be found. */
 		    nbdebug(("Cannot connect to Netbeans #2\n"));
 		    PERROR(_("Cannot connect to Netbeans #2"));
+		    sock_close(sd);
 		    if (doabort)
 			getout(1);
 		    goto theend;
@@ -401,6 +403,7 @@
 	{
 	    nbdebug(("Cannot connect to Netbeans\n"));
 	    PERROR(_("Cannot connect to Netbeans"));
+	    sock_close(sd);
 	    if (doabort)
 		getout(1);
 	    goto theend;
@@ -631,9 +634,7 @@
 {
     char_u	*p;
     queue_T	*node;
-
-    if (!NETBEANS_OPEN)
-	return;
+    int		own_node;
 
     while (head.next != NULL && head.next != &head)
     {
@@ -672,20 +673,25 @@
 	    *p++ = NUL;
 	    if (*p == NUL)
 	    {
+		own_node = TRUE;
 		head.next = node->next;
 		node->next->prev = node->prev;
 	    }
+	    else
+		own_node = FALSE;
 
 	    /* now, parse and execute the commands */
 	    nb_parse_cmd(node->buffer);
 
-	    if (*p == NUL)
+	    if (own_node)
 	    {
 		/* buffer finished, dispose of the node and buffer */
 		vim_free(node->buffer);
 		vim_free(node);
 	    }
-	    else
+	    /* Check that "head" wasn't changed under our fingers, e.g. when a
+	     * DETACH command was handled. */
+	    else if (head.next == node)
 	    {
 		/* more follows, move to the start */
 		STRMOVE(node->buffer, p);
@@ -700,7 +706,7 @@
 /*
  * Read a command from netbeans.
  */
-#ifdef FEAT_GUI_MOTIF
+#ifdef FEAT_GUI_X11
     static void
 messageFromNetbeans(XtPointer clientData UNUSED,
 		    int *unused1 UNUSED,
@@ -720,15 +726,14 @@
 }
 #endif
 
+#define DETACH_MSG "DETACH\n"
+
     void
 netbeans_read()
 {
     static char_u	*buf = NULL;
     int			len = 0;
     int			readlen = 0;
-#if defined(NB_HAS_GUI) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_W32)
-    static int		level = 0;
-#endif
 #ifdef HAVE_SELECT
     struct timeval	tval;
     fd_set		rfds;
@@ -744,13 +749,6 @@
 	return;
     }
 
-#if defined(NB_HAS_GUI) && !defined(FEAT_GUI_GTK) && !defined(FEAT_GUI_W32)
-    /* recursion guard; this will be called from the X event loop at unknown
-     * moments */
-    if (NB_HAS_GUI)
-	++level;
-#endif
-
     /* Allocate a buffer to read into. */
     if (buf == NULL)
     {
@@ -790,34 +788,32 @@
 	    break;	/* did read everything that's available */
     }
 
+    /* Reading a socket disconnection (readlen == 0), or a socket error. */
     if (readlen <= 0)
     {
-	/* read error or didn't read anything */
-	netbeans_close();
-	nbdebug(("messageFromNetbeans: Error in read() from socket\n"));
+	/* Queue a "DETACH" netbeans message in the command queue in order to
+	 * terminate the netbeans session later. Do not end the session here
+	 * directly as we may be running in the context of a call to
+	 * netbeans_parse_messages():
+	 *	netbeans_parse_messages
+	 *	    -> autocmd triggered while processing the netbeans cmd
+	 *		-> ui_breakcheck
+	 *		    -> gui event loop or select loop
+	 *			-> netbeans_read()
+	 */
+	save((char_u *)DETACH_MSG, (int)strlen(DETACH_MSG));
+	nb_close_socket();
+
 	if (len < 0)
 	{
 	    nbdebug(("read from Netbeans socket\n"));
 	    PERROR(_("read from Netbeans socket"));
 	}
-	return; /* don't try to parse it */
     }
 
-#if defined(NB_HAS_GUI) && !defined(FEAT_GUI_W32)
-    /* Let the main loop handle messages. */
-    if (NB_HAS_GUI)
-    {
-# ifdef FEAT_GUI_GTK
-	if (gtk_main_level() > 0)
-	    gtk_main_quit();
-# else
-	/* Parse the messages now, but avoid recursion. */
-	if (level == 1)
-	    netbeans_parse_messages();
-
-	--level;
-# endif
-    }
+#if defined(NB_HAS_GUI) && defined(FEAT_GUI_GTK)
+    if (NB_HAS_GUI && gtk_main_level() > 0)
+	gtk_main_quit();
 #endif
 }
 
@@ -955,7 +951,6 @@
     keyQ_T *key_node = keyHead.next;
     queue_T *cmd_node = head.next;
     nbbuf_T buf;
-    buf_T *bufp;
     int i;
 
     /* free the netbeans buffer list */
@@ -964,7 +959,7 @@
 	buf = buf_list[i];
 	vim_free(buf.displayname);
 	vim_free(buf.signmap);
-	if ((bufp=buf.bufp) != NULL)
+	if (buf.bufp != NULL)
 	{
 	    buf.bufp->b_netbeans_file = FALSE;
 	    buf.bufp->b_was_netbeans_file = FALSE;
@@ -1186,6 +1181,10 @@
 
     nbdebug(("REP %d: <none>\n", cmdno));
 
+    /* Avoid printing an annoying error message. */
+    if (!NETBEANS_OPEN)
+	return;
+
     sprintf(reply, "%d\n", cmdno);
     nb_send(reply, "nb_reply_nil");
 }
@@ -2250,6 +2249,7 @@
 	    update_topline();		/* scroll to show the line */
 	    update_screen(VALID);
 	    setcursor();
+	    cursor_on();
 	    out_flush();
 #ifdef FEAT_GUI
 	    if (gui.in_use)
@@ -2644,6 +2644,7 @@
     {
 	update_screen(NOT_VALID);
 	setcursor();
+	cursor_on();
 	out_flush();
 #ifdef FEAT_GUI
 	if (gui.in_use)
@@ -2773,6 +2774,16 @@
 ex_nbstart(eap)
     exarg_T	*eap;
 {
+#ifdef FEAT_GUI
+# if !defined(FEAT_GUI_X11) && !defined(FEAT_GUI_GTK)  \
+		&& !defined(FEAT_GUI_W32)
+    if (gui.in_use)
+    {
+	EMSG(_("E838: netbeans is not supported with this GUI"));
+	return;
+    }
+# endif
+#endif
     netbeans_open((char *)eap->arg, FALSE);
 }
 
@@ -2880,7 +2891,7 @@
     char_u	*text;
     linenr_T	lnum;
     int		col;
-    char	buf[MAXPATHL * 2 + 25];
+    char	*buf;
     char_u	*p;
 
     /* Don't do anything when 'ballooneval' is off, messages scrolled the
@@ -2894,15 +2905,20 @@
 	 * length. */
 	if (text != NULL && text[0] != NUL && STRLEN(text) < MAXPATHL)
 	{
-	    p = nb_quote(text);
-	    if (p != NULL)
+	    buf = (char *)alloc(MAXPATHL * 2 + 25);
+	    if (buf != NULL)
 	    {
-		vim_snprintf(buf, sizeof(buf),
-				       "0:balloonText=%d \"%s\"\n", r_cmdno, p);
-		vim_free(p);
+		p = nb_quote(text);
+		if (p != NULL)
+		{
+		    vim_snprintf(buf, MAXPATHL * 2 + 25,
+				     "0:balloonText=%d \"%s\"\n", r_cmdno, p);
+		    vim_free(p);
+		}
+		nbdebug(("EVT: %s", buf));
+		nb_send(buf, "netbeans_beval_cb");
+		vim_free(buf);
 	    }
-	    nbdebug(("EVT: %s", buf));
-	    nb_send(buf, "netbeans_beval_cb");
 	}
 	vim_free(text);
     }
@@ -2937,7 +2953,7 @@
     if (!NB_HAS_GUI || !NETBEANS_OPEN)
 	return;
 
-# ifdef FEAT_GUI_MOTIF
+# ifdef FEAT_GUI_X11
     /* tell notifier we are interested in being called
      * when there is input on the editor connection socket
      */
@@ -3000,6 +3016,7 @@
     changed_window_setting();
     update_screen(CLEAR);
     setcursor();
+    cursor_on();
     out_flush();
 #ifdef FEAT_GUI
     if (gui.in_use)
@@ -3027,7 +3044,7 @@
     }
 }
 
-#if defined(FEAT_GUI_MOTIF) || defined(FEAT_GUI_W32) || defined(PROTO)
+#if defined(FEAT_GUI_X11) || defined(FEAT_GUI_W32) || defined(PROTO)
 /*
  * Tell netbeans that the window was moved or resized.
  */
@@ -3458,7 +3475,7 @@
     return FALSE;
 }
 
-#if defined(FEAT_GUI_MOTIF) || defined(PROTO)
+#if defined(FEAT_GUI_X11) || defined(PROTO)
 /*
  * We have multiple signs to draw at the same location. Draw the
  * multi-sign indicator instead. This is the Motif version.
@@ -3487,7 +3504,7 @@
     XDrawPoint(gui.dpy, gui.wid, gui.text_gc, x+3, y++);
     XDrawPoint(gui.dpy, gui.wid, gui.text_gc, x+2, y);
 }
-#endif /* FEAT_GUI_MOTIF */
+#endif /* FEAT_GUI_X11 */
 
 #if defined(FEAT_GUI_GTK) && !defined(PROTO)
 /*
@@ -3902,14 +3919,12 @@
     }
     else
     {
-	char_u ebuf[BUFSIZ];
+	char_u msgbuf[IOSIZE];
 
-	STRCPY(ebuf, (char_u *)_("E505: "));
-	STRCAT(ebuf, IObuff);
-	STRCAT(ebuf, (char_u *)_("is read-only (add ! to override)"));
-	STRCPY(IObuff, ebuf);
-	nbdebug(("    %s\n", ebuf ));
-	emsg(IObuff);
+	vim_snprintf((char *)msgbuf, IOSIZE,
+		_("E505: %s is read-only (add ! to override)"), IObuff);
+	nbdebug(("    %s\n", msgbuf));
+	emsg(msgbuf);
     }
 }
 
diff -Naur vim73.orig/src/normal.c vim73/src/normal.c
--- vim73.orig/src/normal.c	2010-07-31 13:25:19.000000000 +0000
+++ vim73/src/normal.c	2011-05-17 09:39:36.371390862 +0000
@@ -25,6 +25,9 @@
 static int	restart_VIsual_select = 0;
 #endif
 
+#ifdef FEAT_EVAL
+static void	set_vcount_ca __ARGS((cmdarg_T *cap, int *set_prevcount));
+#endif
 static int
 # ifdef __BORLANDC__
 _RTLENTRYF
@@ -648,6 +651,14 @@
     dont_scroll = FALSE;	/* allow scrolling here */
 #endif
 
+#ifdef FEAT_EVAL
+    /* Set v:count here, when called from main() and not a stuffed
+     * command, so that v:count can be used in an expression mapping
+     * when there is no count. */
+    if (toplevel && stuff_empty())
+	set_vcount_ca(&ca, &set_prevcount);
+#endif
+
     /*
      * Get the command character from the user.
      */
@@ -725,15 +736,7 @@
 	     * command, so that v:count can be used in an expression mapping
 	     * right after the count. */
 	    if (toplevel && stuff_empty())
-	    {
-		long count = ca.count0;
-
-		/* multiply with ca.opcount the same way as below */
-		if (ca.opcount != 0)
-		    count = ca.opcount * (count == 0 ? 1 : count);
-		set_vcount(count, count == 0 ? 1 : count, set_prevcount);
-		set_prevcount = FALSE;  /* only set v:prevcount once */
-	    }
+		set_vcount_ca(&ca, &set_prevcount);
 #endif
 	    if (ctrl_w)
 	    {
@@ -1199,7 +1202,16 @@
     {
 	clearop(oap);
 #ifdef FEAT_EVAL
-	set_reg_var('"');
+	{
+	    int regname = 0;
+
+	    /* Adjust the register according to 'clipboard', so that when
+	     * "unnamed" is present it becomes '*' or '+' instead of '"'. */
+# ifdef FEAT_CLIPBOARD
+	    adjust_clip_reg(&regname);
+# endif
+	    set_reg_var(regname);
+	}
 #endif
     }
 
@@ -1386,6 +1398,26 @@
     opcount = ca.opcount;
 }
 
+#ifdef FEAT_EVAL
+/*
+ * Set v:count and v:count1 according to "cap".
+ * Set v:prevcount only when "set_prevcount" is TRUE.
+ */
+    static void
+set_vcount_ca(cap, set_prevcount)
+    cmdarg_T	*cap;
+    int		*set_prevcount;
+{
+    long count = cap->count0;
+
+    /* multiply with cap->opcount the same way as above */
+    if (cap->opcount != 0)
+	count = cap->opcount * (count == 0 ? 1 : count);
+    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);
+    *set_prevcount = FALSE;  /* only set v:prevcount once */
+}
+#endif
+
 /*
  * Handle an operator after visual mode or when the movement is finished
  */
@@ -5666,8 +5698,13 @@
 	else if (cmdchar == '#')
 	    aux_ptr = (char_u *)(p_magic ? "/?.*~[^$\\" : "/?^$\\");
 	else if (tag_cmd)
-	    /* Don't escape spaces and Tabs in a tag with a backslash */
-	    aux_ptr = (char_u *)"\\|\"\n[";
+	{
+	    if (curbuf->b_help)
+		/* ":help" handles unescaped argument */
+		aux_ptr = (char_u *)"";
+	    else
+		aux_ptr = (char_u *)"\\|\"\n[";
+	}
 	else
 	    aux_ptr = (char_u *)"\\|\"\n*?[";
 
@@ -8524,7 +8561,7 @@
     else
 	curwin->w_curswant = 0;
     /* keep curswant at the column where we wanted to go, not where
-       we ended; differs if line is too short */
+     * we ended; differs if line is too short */
     curwin->w_set_curswant = FALSE;
 }
 
diff -Naur vim73.orig/src/ops.c vim73/src/ops.c
--- vim73.orig/src/ops.c	2010-08-01 12:16:08.000000000 +0000
+++ vim73/src/ops.c	2011-05-17 09:38:05.961425117 +0000
@@ -1584,9 +1584,11 @@
 adjust_clip_reg(rp)
     int		*rp;
 {
-    /* If no reg. specified, and "unnamed" is in 'clipboard', use '*' reg. */
-    if (*rp == 0 && clip_unnamed)
-	*rp = '*';
+    /* If no reg. specified, and "unnamed" or "unnamedplus" is in 'clipboard',
+     * use '*' or '+' reg, respectively. "unnamedplus" prevails. */
+    if (*rp == 0 && clip_unnamed != 0)
+	*rp = ((clip_unnamed & CLIP_UNNAMED_PLUS) && clip_plus.available)
+								  ? '+' : '*';
     if (!clip_star.available && *rp == '*')
 	*rp = 0;
     if (!clip_plus.available && *rp == '+')
@@ -2842,6 +2844,9 @@
     char_u		*p;
     char_u		*pnew;
     struct block_def	bd;
+#if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+    int			did_star = FALSE;
+#endif
 
 				    /* check for read-only register */
     if (oap->regname != 0 && !valid_yank_reg(oap->regname, TRUE))
@@ -3115,7 +3120,8 @@
      */
     if (clip_star.available
 	    && (curr == &(y_regs[STAR_REGISTER])
-		|| (!deleting && oap->regname == 0 && clip_unnamed)))
+		|| (!deleting && oap->regname == 0
+					   && (clip_unnamed & CLIP_UNNAMED))))
     {
 	if (curr != &(y_regs[STAR_REGISTER]))
 	    /* Copy the text from register 0 to the clipboard register. */
@@ -3123,6 +3129,9 @@
 
 	clip_own_selection(&clip_star);
 	clip_gen_set_selection(&clip_star);
+# ifdef FEAT_X11
+	did_star = TRUE;
+# endif
     }
 
 # ifdef FEAT_X11
@@ -3130,12 +3139,18 @@
      * If we were yanking to the '+' register, send result to selection.
      * Also copy to the '*' register, in case auto-select is off.
      */
-    else if (clip_plus.available && curr == &(y_regs[PLUS_REGISTER]))
+    if (clip_plus.available
+	    && (curr == &(y_regs[PLUS_REGISTER])
+		|| (!deleting && oap->regname == 0
+				      && (clip_unnamed & CLIP_UNNAMED_PLUS))))
     {
-	/* No need to copy to * register upon 'unnamed' now - see below */
+	if (curr != &(y_regs[PLUS_REGISTER]))
+	    /* Copy the text from register 0 to the clipboard register. */
+	    copy_yank_reg(&(y_regs[PLUS_REGISTER]));
+
 	clip_own_selection(&clip_plus);
 	clip_gen_set_selection(&clip_plus);
-	if (!clip_isautosel())
+	if (!clip_isautosel() && !did_star && curr == &(y_regs[PLUS_REGISTER]))
 	{
 	    copy_yank_reg(&(y_regs[STAR_REGISTER]));
 	    clip_own_selection(&clip_star);
@@ -3979,7 +3994,12 @@
     for (i = -1; i < NUM_REGISTERS && !got_int; ++i)
     {
 	name = get_register_name(i);
-	if (arg != NULL && vim_strchr(arg, name) == NULL)
+	if (arg != NULL && vim_strchr(arg, name) == NULL
+#ifdef ONE_CLIPBOARD
+	    /* Star register and plus register contain the same thing. */
+		&& (name != '*' || vim_strchr(arg, '+') == NULL)
+#endif
+		)
 	    continue;	    /* did not ask for this register */
 
 #ifdef FEAT_CLIPBOARD
@@ -4153,9 +4173,10 @@
     int	    save_undo;
 {
     char_u	*curr = NULL;
+    char_u      *curr_start = NULL;
     char_u	*cend;
     char_u	*newp;
-    char_u	*spaces;	/* number of spaces inserte before a line */
+    char_u	*spaces;	/* number of spaces inserted before a line */
     int		endcurr1 = NUL;
     int		endcurr2 = NUL;
     int		currsize = 0;	/* size of the current line */
@@ -4181,7 +4202,7 @@
      */
     for (t = 0; t < count; ++t)
     {
-	curr = ml_get((linenr_T)(curwin->w_cursor.lnum + t));
+	curr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t));
 	if (insert_space && t > 0)
 	{
 	    curr = skipwhite(curr);
@@ -4265,10 +4286,10 @@
 	    copy_spaces(cend, (size_t)(spaces[t]));
 	}
 	mark_col_adjust(curwin->w_cursor.lnum + t, (colnr_T)0, (linenr_T)-t,
-				 (long)(cend - newp + spaces[t]));
+			 (long)(cend - newp + spaces[t] - (curr - curr_start)));
 	if (t == 0)
 	    break;
-	curr = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));
+	curr = curr_start = ml_get((linenr_T)(curwin->w_cursor.lnum + t - 1));
 	if (insert_space && t > 1)
 	    curr = skipwhite(curr);
 	currsize = (int)STRLEN(curr);
diff -Naur vim73.orig/src/option.c vim73/src/option.c
--- vim73.orig/src/option.c	2010-08-04 18:49:18.000000000 +0000
+++ vim73/src/option.c	2011-05-17 09:38:42.077416723 +0000
@@ -2740,7 +2740,7 @@
 			    (char_u *)&p_wc, PV_NONE,
 			    {(char_u *)(long)Ctrl_E, (char_u *)(long)TAB}
 			    SCRIPTID_INIT},
-    {"wildcharm",   "wcm",   P_NUM|P_VI_DEF,
+    {"wildcharm",   "wcm",  P_NUM|P_VI_DEF,
 			    (char_u *)&p_wcm, PV_NONE,
 			    {(char_u *)0L, (char_u *)0L} SCRIPTID_INIT},
     {"wildignore",  "wig",  P_STRING|P_VI_DEF|P_COMMA|P_NODUP,
@@ -2750,6 +2750,9 @@
 			    (char_u *)NULL, PV_NONE,
 #endif
 			    {(char_u *)"", (char_u *)0L} SCRIPTID_INIT},
+    {"wildignorecase", "wic", P_BOOL|P_VI_DEF,
+			    (char_u *)&p_wic, PV_NONE,
+			    {(char_u *)FALSE, (char_u *)0L} SCRIPTID_INIT},
     {"wildmenu",    "wmnu", P_BOOL|P_VI_DEF,
 #ifdef FEAT_WILDMENU
 			    (char_u *)&p_wmnu, PV_NONE,
@@ -3843,6 +3846,8 @@
 # ifndef OS2	/* Always use bourne shell style redirection if we reach this */
 	    if (       fnamecmp(p, "sh") == 0
 		    || fnamecmp(p, "ksh") == 0
+		    || fnamecmp(p, "mksh") == 0
+		    || fnamecmp(p, "pdksh") == 0
 		    || fnamecmp(p, "zsh") == 0
 		    || fnamecmp(p, "zsh-beta") == 0
 		    || fnamecmp(p, "bash") == 0
@@ -3850,6 +3855,8 @@
 		    || fnamecmp(p, "cmd") == 0
 		    || fnamecmp(p, "sh.exe") == 0
 		    || fnamecmp(p, "ksh.exe") == 0
+		    || fnamecmp(p, "mksh.exe") == 0
+		    || fnamecmp(p, "pdksh.exe") == 0
 		    || fnamecmp(p, "zsh.exe") == 0
 		    || fnamecmp(p, "zsh-beta.exe") == 0
 		    || fnamecmp(p, "bash.exe") == 0
@@ -4349,7 +4356,7 @@
 		    p = find_termcode(key_name);
 		    if (p == NULL)
 		    {
-			errmsg = (char_u *)N_("E518: Unknown option");
+			errmsg = (char_u *)N_("E846: Key code not set");
 			goto skip;
 		    }
 		    else
@@ -4697,8 +4704,8 @@
 						|| s[i] == ','
 						|| s[i] == NUL))
 					break;
-				    /* Count backspaces.  Only a comma with an
-				     * even number of backspaces before it is
+				    /* Count backslashes.  Only a comma with an
+				     * even number of backslashes before it is
 				     * recognized as a separator */
 				    if (s > origval && s[-1] == '\\')
 					++bs;
@@ -7304,7 +7311,7 @@
     static char_u *
 check_clipboard_option()
 {
-    int		new_unnamed = FALSE;
+    int		new_unnamed = 0;
     int		new_autoselect = FALSE;
     int		new_autoselectml = FALSE;
     int		new_html = FALSE;
@@ -7316,9 +7323,15 @@
     {
 	if (STRNCMP(p, "unnamed", 7) == 0 && (p[7] == ',' || p[7] == NUL))
 	{
-	    new_unnamed = TRUE;
+	    new_unnamed |= CLIP_UNNAMED;
 	    p += 7;
 	}
+        else if (STRNCMP(p, "unnamedplus", 11) == 0
+					    && (p[11] == ',' || p[11] == NUL))
+	{
+	    new_unnamed |= CLIP_UNNAMED_PLUS;
+	    p += 11;
+	}
 	else if (STRNCMP(p, "autoselect", 10) == 0
 					&& (p[10] == ',' || p[10] == NUL))
 	{
@@ -9172,7 +9185,7 @@
     int		expand;
 {
     char_u	*s;
-    char_u	buf[MAXPATHL];
+    char_u	*buf;
 
     if (fprintf(fd, "%s %s=", cmd, name) < 0)
 	return FAIL;
@@ -9190,9 +9203,16 @@
 	}
 	else if (expand)
 	{
+	    buf = alloc(MAXPATHL);
+	    if (buf == NULL)
+		return FAIL;
 	    home_replace(NULL, *valuep, buf, MAXPATHL, FALSE);
 	    if (put_escstr(fd, buf, 2) == FAIL)
+	    {
+		vim_free(buf);
 		return FAIL;
+	    }
+	    vim_free(buf);
 	}
 	else if (put_escstr(fd, *valuep, 2) == FAIL)
 	    return FAIL;
@@ -9756,6 +9776,9 @@
 #ifdef FEAT_SCROLLBIND
     to->wo_scb = from->wo_scb;
 #endif
+#ifdef FEAT_CURSORBIND
+    to->wo_crb = from->wo_crb;
+#endif
 #ifdef FEAT_SPELL
     to->wo_spell = from->wo_spell;
 #endif
@@ -10011,7 +10034,7 @@
 	    buf->b_p_smc = p_smc;
 #endif
 #ifdef FEAT_SPELL
-	    buf->b_s.b_p_spc = vim_strsave(p_spf);
+	    buf->b_s.b_p_spc = vim_strsave(p_spc);
 	    (void)compile_cap_prog(&buf->b_s);
 	    buf->b_s.b_p_spf = vim_strsave(p_spf);
 	    buf->b_s.b_p_spl = vim_strsave(p_spl);
@@ -11284,16 +11307,19 @@
  * from when editing started (save_file_ff() called).
  * Also when 'endofline' was changed and 'binary' is set, or when 'bomb' was
  * changed and 'binary' is not set.
- * Don't consider a new, empty buffer to be changed.
+ * When "ignore_empty" is true don't consider a new, empty buffer to be
+ * changed.
  */
     int
-file_ff_differs(buf)
+file_ff_differs(buf, ignore_empty)
     buf_T	*buf;
+    int		ignore_empty;
 {
     /* In a buffer that was never loaded the options are not valid. */
     if (buf->b_flags & BF_NEVERLOADED)
 	return FALSE;
-    if ((buf->b_flags & BF_NEW)
+    if (ignore_empty
+	    && (buf->b_flags & BF_NEW)
 	    && buf->b_ml.ml_line_count == 1
 	    && *ml_get_buf(buf, (linenr_T)1, FALSE) == NUL)
 	return FALSE;
diff -Naur vim73.orig/src/option.h vim73/src/option.h
--- vim73.orig/src/option.h	2010-07-25 14:15:02.000000000 +0000
+++ vim73/src/option.h	2011-05-17 09:36:52.217609780 +0000
@@ -854,7 +854,11 @@
 # define VE_ONEMORE	8
 #endif
 EXTERN long	p_verbose;	/* 'verbose' */
-EXTERN char_u	*p_vfile;	/* 'verbosefile' */
+#ifdef IN_OPTION_C
+char_u	*p_vfile = (char_u *)""; /* used before options are initialized */
+#else
+extern char_u	*p_vfile;	/* 'verbosefile' */
+#endif
 EXTERN int	p_warn;		/* 'warn' */
 #ifdef FEAT_CMDL_COMPL
 EXTERN char_u	*p_wop;		/* 'wildoptions' */
@@ -872,6 +876,7 @@
 EXTERN char_u	*p_ww;		/* 'whichwrap' */
 EXTERN long	p_wc;		/* 'wildchar' */
 EXTERN long	p_wcm;		/* 'wildcharm' */
+EXTERN long	p_wic;		/* 'wildignorecase' */
 EXTERN char_u	*p_wim;		/* 'wildmode' */
 #ifdef FEAT_WILDMENU
 EXTERN int	p_wmnu;		/* 'wildmenu' */
diff -Naur vim73.orig/src/os_macosx.m vim73/src/os_macosx.m
--- vim73.orig/src/os_macosx.m	2010-08-15 10:56:50.000000000 +0000
+++ vim73/src/os_macosx.m	2011-05-17 09:33:10.742191503 +0000
@@ -15,6 +15,10 @@
     Error: MACOS 9 is no longer supported in Vim 7
 #endif
 
+/* Avoid a conflict for the definition of Boolean between Mac header files and
+ * X11 header files. */
+#define NO_X11_INCLUDES
+
 #include "vim.h"
 #import <Cocoa/Cocoa.h>
 
diff -Naur vim73.orig/src/os_msdos.c vim73/src/os_msdos.c
--- vim73.orig/src/os_msdos.c	2010-05-15 11:04:07.000000000 +0000
+++ vim73/src/os_msdos.c	2011-05-17 09:35:36.146052907 +0000
@@ -21,7 +21,6 @@
  * Some functions are also used for Win16 (MS-Windows 3.1).
  */
 
-#include "vimio.h"
 #include "vim.h"
 
 #include <conio.h>
diff -Naur vim73.orig/src/os_mswin.c vim73/src/os_mswin.c
--- vim73.orig/src/os_mswin.c	2010-07-27 19:39:05.000000000 +0000
+++ vim73/src/os_mswin.c	2011-05-17 09:36:14.489797147 +0000
@@ -22,7 +22,6 @@
 # endif
 #endif
 
-#include "vimio.h"
 #include "vim.h"
 
 #ifdef WIN16
@@ -31,7 +30,6 @@
 # include <string.h>
 #endif
 #include <sys/types.h>
-#include <errno.h>
 #include <signal.h>
 #include <limits.h>
 #include <process.h>
@@ -595,7 +593,7 @@
 				     gui.starting ? (char_u *)_("Message") :
 #endif
 					     (char_u *)_("Error"),
-				     p, (char_u *)_("&Ok"), 1, NULL);
+				     p, (char_u *)_("&Ok"), 1, NULL, FALSE);
 		break;
 	    }
 	ga_clear(&error_ga);
@@ -817,7 +815,11 @@
     BOOL fRunTimeLinkSuccess = FALSE;
 
     // Get a handle to the DLL module.
+# ifdef WIN16
     hinstLib = LoadLibrary(libname);
+# else
+    hinstLib = vimLoadLib(libname);
+# endif
 
     // If the handle is valid, try to get the function address.
     if (hinstLib != NULL)
diff -Naur vim73.orig/src/os_riscos.c vim73/src/os_riscos.c
--- vim73.orig/src/os_riscos.c	2010-05-15 11:04:08.000000000 +0000
+++ vim73/src/os_riscos.c	1970-01-01 00:00:00.000000000 +0000
@@ -1,1292 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- * See README.txt for an overview of the Vim source code.
- */
-
-#include "vim.h"
-
-/*
- * os_riscos.c
- *
- * Thomas Leonard <tal197@ecs.soton.ac.uk>
- */
-
-const char *__dynamic_da_name = "Vim heap"; /* Enable and name our dynamic area */
-int ro_line_mode = TRUE;  /* For Ex mode we much echo chars to the screen ourselves */
-int windowed;		/* Flag - are we running inside a text window? */
-int WinLeft, WinTop;	/* We might be started inside a text window */
-int ScrollTop;		/* Make cursor movements relative to ScrollTop. */
-
-int old_escape_state = -1;
-int old_cursor_state = -1;
-
-#define rgb(r,g,b) ((b<<24) + (g<<16) + (r<<8))
-#define NORMAL_FG 0x00000000
-#define NORMAL_BG 0xffffffff
-
-/* Convert a DOS colour number to an RGB palette entry.
- * Mappings from X11 rgb/txt file.
- */
-    static int
-map_colour(dos)
-    int dos;		/* Standard DOS colour number. */
-{
-    switch (dos)
-    {
-	case 0: return 0;			/* Black */
-	case 1: return rgb(0,0,139);		/* DarkBlue */
-	case 2: return rgb(0,100,0);		/* DarkGreen */
-	case 3: return rgb(0,139,139);		/* DarkCyan */
-	case 4: return rgb(139,0,0);		/* DarkRed */
-	case 5: return rgb(139,0,139);		/* DarkMagenta */
-	case 6: return rgb(165,42,42);		/* Brown, DarkYellow */
-	case 7: return rgb(211,211,211);	/* LightGray, LightGrey, Gray, Grey */
-	case 8: return rgb(169,169,169);	/* DarkGray, DarkGrey */
-	case 9: return rgb(173,216,230);	/* Blue, LightBlue */
-	case 10: return rgb(144,238,144);	/* Green, LightGreen */
-	case 11: return rgb(224,255,255);	/* Cyan, LightCyan */
-	case 12: return rgb(255,0,0);		/* Red, LightRed */
-	case 13: return rgb(255,0,255);		/* Magenta, LightMagenta */
-	case 14: return rgb(255,255,0);		/* Yellow, LightYellow */
-	case 15: return rgb(255,255,255);	/* White */
-    }
-    return rgb(100,100,100);
-}
-
-    static void
-text_fg(fg)
-    int fg;		/* Foregound colour in the form &BBGGRR00 */
-{
-    xswi(ColourTrans_SetTextColour, fg, 0, 0, 0);
-}
-
-    static void
-text_bg(bg)
-    int		bg;	/* Backgound colour in the form &BBGGRR00 */
-{
-    xswi(ColourTrans_SetTextColour, bg, 0, 0, 1 << 7);
-}
-
-#define OUT_NORMAL 0
-#define OUT_NUMBER 1		/* Reading in a number */
-
-    void
-mch_write(s, len)
-    char_u  *s;
-    int	    len;
-{
-    static int mode = OUT_NORMAL;
-    static int x, y;			/* For reading numbers in. */
-
-    if (!term_console)
-    {
-	/* Maybe we are running Vim remotely - don't interpret chars */
-	while (len--)
-	{
-	    char_u c = *s++;
-	    swi(OS_WriteC, c);
-	    /* We might need to send a CR too. This shouldn't
-	     * hurt if we don't need it, should it?
-	     */
-	    if (c == 10)
-		swi(OS_WriteI + 13);
-	}
-	return;
-    }
-
-    while (len--)
-    {
-	char_u c = *s++;
-	switch (mode)
-	{
-	    case OUT_NUMBER:
-		if (c < '0' || c > '9')
-		{
-		    mode = OUT_NORMAL;
-		}
-		else
-		{
-		    x = (x * 10) + c - '0';
-		    continue;
-		}
-	    /* note: no break here! */
-
-	    case OUT_NORMAL:
-		switch (c)
-		{
-		    case 1:
-			/* Number (in decimal) follows. */
-			mode = OUT_NUMBER;
-			y = x;
-			x = 0;
-			break;
-		    case 2:
-			/* Position cursor. */
-			swi(OS_WriteI + 31);
-			swi(OS_WriteC, x);
-			swi(OS_WriteC, y - ScrollTop);
-			break;
-		    case 3:
-			/* Set scroll region. */
-			if (x == Rows -1 && y == 0 && !windowed)
-			{
-			    /* Whole screen - remove text window.
-			     * This is MUCH faster.
-			     */
-			    swi(OS_WriteI + 26);
-			}
-			else
-			{
-			    /* Create a text window. */
-			    swi(OS_WriteI + 28);
-			    swi(OS_WriteC, WinLeft);
-			    swi(OS_WriteC, WinTop + x);
-			    swi(OS_WriteC, WinLeft + Columns - 1);
-			    swi(OS_WriteC, WinTop + y);
-			}
-			ScrollTop = y;
-			break;
-		    case 4:
-			/* Normal mode. */
-			text_fg(NORMAL_FG);
-			text_bg(NORMAL_BG);
-			break;
-		    case 5:
-			/* Reverse mode. */
-			text_fg(NORMAL_BG);
-			text_bg(NORMAL_FG);
-			break;
-		    case 10:
-			swi(OS_NewLine);
-			break;
-		    case 14:
-			/* Cursor invisible. */
-			swi(OS_WriteN,
-			     "\027\001\000\000\000\000\000\000\000\000",
-			     10);
-			break;
-		    case 15:
-			/* Cursor visible. */
-			swi(OS_WriteN,
-			     "\027\001\002\000\000\000\000\000\000\000",
-			     10);
-			break;
-		    case 16:
-			/* Cursor very visible (flash) */
-			swi(OS_WriteN,
-			     "\027\001\003\000\000\000\000\000\000\000",
-			     10);
-		    case 17:
-			/* Set foreground colour. */
-			text_fg(map_colour(x));
-			break;
-		    case 18:
-			/* Set background colour. */
-			text_bg(map_colour(x));
-			break;
-		    case 19:
-			/* Scroll text down. */
-			swi(OS_WriteN,
-			     "\027\007\000\002\000\000\000\000\000\000",
-			     10);
-			break;
-		    default:
-			swi(OS_WriteC, c);
-		}
-		continue;
-
-	    default:
-		printf("[output error]");
-		mode = OUT_NORMAL;
-	}
-    }
-}
-
-/*
- * mch_inchar(): low level input funcion.
- * Get a characters from the keyboard.
- * Return the number of characters that are available.
- * If wtime == 0 do not wait for characters.
- * If wtime == n wait n msecs for characters.
- * If wtime == -1 wait forever for characters.
- *
- * TODO: call convert_input() for 'fileencoding' to 'encoding' conversion.
- */
-    int
-mch_inchar(buf, maxlen, wtime, tb_change_cnt)
-    char_u  *buf;
-    int	    maxlen;
-    long    wtime;
-    int	    tb_change_cnt;
-{
-    int got=0;
-    unsigned int start_time = clock();
-
-    if (ro_line_mode)
-    {
-	/* We're probably in Ex mode - get whole lines at a time. */
-
-	static char_u	line_buffer[256];
-	static int	remaining_chars = 0;
-	static int	buf_pos = 0;
-
-	/* Do we need to fetch another line? */
-	if (remaining_chars == 0)
-	{
-	    int		old_esc_state;
-	    swi(OS_Byte, 200, 1, 0xfe);
-	    old_esc_state = r1;
-
-	    buf_pos = 0;
-	    if (xswi(OS_ReadLine, line_buffer, 255, 0, 255) & (c_flag | v_flag))
-	    {
-		got_int = TRUE;	    /* ESC pressed */
-		r1 = 0;
-	    }
-	    line_buffer[r1] = 13;
-	    remaining_chars = r1 + 1;	/* Count CR as part of input */
-
-	    swi(OS_Byte, 200, old_esc_state, 0);
-	}
-
-	/* Can we send the rest of the buffer back in one go? */
-	if (remaining_chars <= maxlen)
-	{
-	    int	    got = remaining_chars;
-
-	    memcpy(buf, line_buffer + buf_pos, got);
-	    remaining_chars = 0;
-	    return  got;
-	}
-
-	/* Send as much as we can */
-	memcpy(buf, line_buffer + buf_pos, maxlen);
-	buf_pos += maxlen;
-	remaining_chars -= maxlen;
-
-	return maxlen;
-    }
-
-    if (!term_console)
-    {
-	/* Use OS_ReadC for all input.
-	 * Avoids problems with remote access getting interference from
-	 * the keyboard.
-	 */
-	if (wtime == 0)
-	    return 0;	    /* Ignore quick key checks */
-
-	if (xswi(OS_ReadC) & c_flag)
-	{
-	    got_int = TRUE;	/* ESC pressed - can this happen? */
-	    swi(OS_Byte, 124);	/* Clear Escape state */
-	    r0 = 0x1b;		/* It *might* not have been Escape! */
-	}
-	buf[0] = r0;
-	return 1;
-    }
-
-    /*
-     * OK, here's the plan:
-     *
-     * 1) Wait until wtime expires or we get a key
-     * 2) Get keys until the keyboard buffer is empty or buf is full
-     */
-
-    while (xswi(OS_Byte,145,0) & c_flag)
-    {
-	/* Nothing at all in the keyboard buffer.
-	 * Has our time expired yet?
-	 */
-	if ( (wtime != -1) && (clock() - start_time) >= wtime )
-	    return 0;		/* Nothing read - giving up */
-    }
-
-    /* We've got one char (in r2) - are there any more? */
-
-    while (got < maxlen)
-    {
-	buf[got++] = r2;
-
-	if (xswi(OS_Byte,145,0) & c_flag)
-	    return got;		/* Keyboard buffer empty */
-    }
-    return got;			/* buf is full */
-}
-
-/*
- * return non-zero if a character is available
- */
-    int
-mch_char_avail()
-{
-    if (!term_console)
-	return 0;	    /* Can't tell */
-    if (xswi(OS_Byte, 152, 0) & c_flag)
-	return 0;
-    return 1;
-}
-
-/* Find out how much free memory we have.
- * I don't know how to work this out exactly but, since we can claim
- * more memory from the OS, let's just report the free pool size.
- * Dynamic area 6 doesn't exist pre 3.6 according to StrongHelp, so
- * we'll use Wimp_SlotSize. If that fails (outside the desktop?)
- * then just return a big number and hope.
- */
-    long_u
-mch_avail_mem(special)
-    int special;
-{
-    if (xswi(Wimp_SlotSize, -1, -1) & v_flag)
-	return 0x7fffffff;
-    return r2;
-}
-
-    void
-mch_delay(msec, ignoreinput)
-    long	msec;
-    int		ignoreinput;
-{
-    int		start_time, time_now;
-    int		csec = msec / 10;
-
-    swi(OS_ReadMonotonicTime);
-    start_time = r0;
-
-    for (;;)
-    {
-	swi(OS_ReadMonotonicTime);
-	time_now = r0;
-	if (time_now - start_time > csec)
-	    return;
-#ifdef FEAT_GUI
-	/* In the GUI, allow other programs to run while waiting. */
-	if (gui.in_use)
-	    gui_mch_wait_for_chars(start_time + csec);
-#endif
-    }
-}
-
-/*
- * If the machine has job control, use it to suspend the program,
- * otherwise fake it by starting a new shell.
- */
-    void
-mch_suspend()
-{
-    suspend_shell();
-}
-
-    void
-mch_init()
-{
-    /*
-     * Read window size first. Calls to mch_get_shellsize() will
-     * simply return these values in future so that setting the
-     * text window (used for scrolling) won't give strange results.
-     */
-
-    int buf[7] = {132, 135, 256, 257, 1, 2, -1};
-
-    /* Command windows are no longer forced open, since if we are
-     * in the desktop then we'll use the GUI version.
-     * Opening a command window here messes up the GUI version startup
-     */
-#ifndef FEAT_GUI
-    swi(OS_WriteI);
-#endif
-    swi(OS_ReadVduVariables, buf, buf);
-    WinLeft = buf[0];
-    WinTop  = buf[1];
-    Columns = buf[2];
-    Rows    = buf[3] + 1;	/* Seems to be one off (VduVars wrong?) */
-    ScrollTop = 0;
-
-    /* Are we running in a textwindow? */
-    if (Rows == buf[5] + 1 && Columns == buf[4] + 1)
-	windowed = 0;
-    else
-	windowed = 1;
-
-    /* Choose a nice colour scheme. */
-    text_fg(NORMAL_FG);
-    text_bg(NORMAL_BG);
-}
-
-/*
- * Check_win checks whether we have an interactive stdout.
- */
-/* ARGSUSED */
-    int
-mch_check_win(argc, argv)
-    int	    argc;
-    char    **argv;
-{
-    return OK;
-}
-
-/*
- * Return TRUE if the input comes from a terminal, FALSE otherwise.
- */
-    int
-mch_input_isatty()
-{
-    if (xswi(OS_ChangeRedirection, -1, -1) & v_flag)
-	return TRUE;		/* Error - TRUE is probably correct though */
-    if (r0 == 0)
-	return TRUE;
-    return FALSE;
-}
-
-#ifdef FEAT_TITLE
-    int
-mch_can_restore_title()
-{
-    return FALSE;
-}
-
-    int
-mch_can_restore_icon()
-{
-    return FALSE;
-}
-
-
-/*
- * Set the window title and icon.
- */
-    void
-mch_settitle(title, icon)
-    char_u *title;
-    char_u *icon;
-{
-    if (title == NULL)
-	title = (char_u *) "<untitled>";
-#ifdef FEAT_GUI
-    if (gui.in_use && strcmp(title, gui.window_title))
-    {
-	int length;
-	length = strlen(title);
-	if (length >= gui.window_title_size)
-	    length = gui.window_title_size - 1;
-	strncpy(gui.window_title, title, length);
-	gui.window_title[length] = 0;
-	ro_redraw_title(gui.window_handle);
-    }
-#endif
-    return;
-}
-
-/*
- * Restore the window/icon title.
- * "which" is one of:
- *  1  only restore title
- *  2  only restore icon
- *  3  restore title and icon
- */
-    void
-mch_restore_title(which)
-    int which;
-{
-    return;
-}
-#endif
-
-/*
- * Insert user name in s[len].
- * Return OK if a name found.
- */
-    int
-mch_get_user_name(s, len)
-    char_u  *s;
-    int	    len;
-{
-    /* RISC OS doesn't support user names. */
-    *s = NUL;
-    return FAIL;
-}
-
-/*
- * Insert host name in s[len].
- */
-
-    void
-mch_get_host_name(s, len)
-    char_u  *s;
-    int	    len;
-{
-    if (xswi(OS_ReadVarVal, "Machine$Name", s, len, 0, 3) & v_flag)
-    {
-	/* Variable does not exist (normal operation) */
-	vim_strncpy(s, "(unknown)", len - 1);
-    }
-}
-
-/*
- * return process ID
- */
-    long
-mch_get_pid()
-{
-    if (xswi(Wimp_ReadSysInfo, 5) & v_flag)
-	return 0;
-    return r0;
-}
-
-/*
- * Get name of current directory into buffer 'buf' of length 'len' bytes.
- * Return OK for success, FAIL for failure.
- */
-    int
-mch_dirname(buf, len)
-    char_u  *buf;
-    int	    len;
-{
-    if (xswi(OS_FSControl, 37, "@", buf, 0, 0, len) & v_flag)
-	return FAIL;
-    return OK;
-}
-
-/*
- * Get absolute file name into buffer 'buf' of length 'len' bytes.
- *
- * return FAIL for failure, OK for success
- */
-    int
-mch_FullName(fname, buf, len, force)
-    char_u *fname, *buf;
-    int len;
-    int	force;		/* Also expand when already absolute path name.
-			 * Not used under RISC OS.
-			 */
-{
-    if (xswi(OS_FSControl, 37, fname, buf, 0, 0, len) & v_flag)
-	return FAIL;
-    return OK;
-}
-
-/*
- * Return TRUE if "fname" does not depend on the current directory.
- */
-    int
-mch_isFullName(fname)
-    char_u	*fname;
-{
-    if (strstr(fname, "::") && strstr(fname,".$."))
-	return TRUE;
-    return FALSE;
-}
-
-/*
- * Get file permissions for 'name'.
- * Returns -1 when it doesn't exist.
- */
-    long
-mch_getperm(name)
-    char_u *name;
-{
-    struct stat statb;
-
-    if (stat((char *)name, &statb))
-	return -1;
-    return statb.st_mode;
-}
-
-/*
- * set file permission for 'name' to 'perm'
- *
- * return FAIL for failure, OK otherwise
- */
-    int
-mch_setperm(name, perm)
-    char_u  *name;
-    long    perm;
-{
-    return (chmod((char *)name, (mode_t)perm) == 0 ? OK : FAIL);
-}
-
-/*
- * Set hidden flag for "name".
- */
-/* ARGSUSED */
-    void
-mch_hide(name)
-    char_u	*name;
-{
-    /* can't hide a file */
-}
-
-/*
- * return TRUE if "name" is a directory
- * return FALSE if "name" is not a directory
- * return FALSE for error
- */
-    int
-mch_isdir(name)
-    char_u *name;
-{
-    if (xswi(OS_File, 17, name) & v_flag)
-	return FALSE;
-    if (r0 == 2 || r0 == 3)
-	return TRUE;		/* Count image files as directories. */
-    return FALSE;
-}
-
-/*
- * Return 1 if "name" can be executed, 0 if not.
- * Return -1 if unknown. Requires which to work.
- */
-    int
-mch_can_exe(name)
-    char_u	*name;
-{
-    char_u	*buf;
-    char_u	*p;
-    int		retval;
-
-    buf = alloc((unsigned)STRLEN(name) + 7);
-    if (buf == NULL)
-	return -1;
-    sprintf((char *)buf, "which %s", name);
-    p = get_cmd_output(buf, NULL, SHELL_SILENT);
-    vim_free(buf);
-    if (p == NULL)
-	return -1;
-    /* result can be: "name: Command not found" */
-    retval = (*p != NUL && strstr((char *)p, "not found") == NULL);
-    vim_free(p);
-    return retval;
-}
-
-/*
- * Check what "name" is:
- * NODE_NORMAL: file or directory (or doesn't exist)
- * NODE_WRITABLE: writable device, socket, fifo, etc.
- * NODE_OTHER: non-writable things
- */
-    int
-mch_nodetype(name)
-    char_u	*name;
-{
-    /* TODO */
-    return NODE_NORMAL;
-}
-
-    void
-mch_early_init()
-{
-    /* Turn off all the horrible filename munging in UnixLib. */
-    int __riscosify_control = __RISCOSIFY_NO_PROCESS;
-}
-
-    void
-mch_exit(r)
-    int r;
-{
-    settmode(TMODE_COOK);
-    exiting = TRUE;
-    out_flush();
-    ml_close_all(TRUE);		/* remove all memfiles */
-
-#ifdef FEAT_GUI
-    if (gui.in_use)
-	gui_exit(r);
-#endif
-    swi(OS_NewLine);
-    if (old_escape_state != -1)
-	swi(OS_Byte, 229, old_escape_state, 0);
-    if (old_cursor_state != -1)
-	swi(OS_Byte, 4, old_cursor_state);
-    exit(r);
-}
-
-    void
-mch_settmode(tmode)
-    int		tmode;	    /* TMODE_RAW or TMODE_COOK */
-{
-    if (tmode == TMODE_COOK)
-    {
-	ro_line_mode = TRUE;
-	return;
-    }
-
-    ro_line_mode = FALSE;
-
-    if (term_console)
-    {
-	/* Block cursor. */
-	swi(OS_WriteN,
-		"\027\000\012\000\000\000\000\000\000\000",
-		10);
-
-	/* Disable the standard cursor key actions. */
-	swi(OS_Byte, 4, 1);
-	if (old_cursor_state == -1)
-	    old_cursor_state = r1;
-    }
-
-    /* Stop Escape from quitting Vim! */
-    swi(OS_Byte, 229, 1, 0);
-    if (old_escape_state == -1)
-	old_escape_state = r1;
-}
-
-/*
- * set mouse clicks on or off (only works for xterms)
- */
-    void
-mch_setmouse(on)
-    int	    on;
-{
-}
-
-/*
- * set screen mode, always fails.
- */
-/* ARGSUSED */
-    int
-mch_screenmode(arg)
-    char_u   *arg;
-{
-    EMSG(_(e_screenmode));
-    return FAIL;
-}
-
-/*
- * Try to get the current window size.
- * Return OK when size could be determined, FAIL otherwise.
- * Simply return results stored by mch_init() if we are the
- * machine's console. If not, we don't know how big the screen is.
- */
-    int
-mch_get_shellsize()
-{
-    /* if size changed: screenalloc will allocate new screen buffers */
-    return term_console ? OK : FAIL;
-}
-
-/*
- * Can't change the size.
- * Assume the user knows what he's doing and use the new values.
- */
-    void
-mch_set_shellsize()
-{
-    /* Assume the user knows what he's doing and use the new values. */
-}
-
-/*
- * Rows and/or Columns has changed.
- */
-    void
-mch_new_shellsize()
-{
-    /* Nothing to do. */
-}
-
-    int
-mch_call_shell(cmd, options)
-    char_u	*cmd;
-    int		options;	/* SHELL_*, see vim.h */
-{
-    int		retval;
-    int		tmode = cur_tmode;
-
-    if (cmd == NULL)
-	cmd = (char_u *) "GOS";
-
-#ifdef FEAT_GUI
-    if (gui.in_use)
-	return gui_mch_call_shell(cmd, options);
-#endif
-    if (options & SHELL_COOKED)
-	settmode(TMODE_COOK);		/* set to normal mode */
-    MSG_PUTS("\n");
-
-   /* I don't even want to think about what UnixLib must
-    * be doing to allow this to work...
-    */
-    retval = system(cmd);
-    if (retval && !(options & SHELL_SILENT))
-	EMSG(strerror(EOPSYS));		/* Doesn't seem to set errno? */
-
-    swi(OS_Byte, 229, 1, 0);		/* Re-disable escape */
-    if (tmode == TMODE_RAW)
-	settmode(TMODE_RAW);		/* set to raw mode */
-    return retval ? FAIL : OK;
-}
-
-/*
- * Check for Escape being pressed right now.
- * [ different if !term_console? ]
- */
-    void
-mch_breakcheck()
-{
-    if (xswi(OS_Byte, 121, 0xf0) & v_flag)
-	return;
-    if (r1 == 0xff)
-    {
-	got_int = TRUE;
-	swi(OS_Byte, 15, 1);	/* Flush input buffer */
-    }
-}
-
-/*
- * Recursively expand one path component into all matching files and/or
- * directories.
- * "path" has backslashes before chars that are not to be expanded.
- * Return the number of matches found.
- */
-    int
-mch_expandpath(gap, path, flags)
-    garray_T	*gap;	/* Grow array for results. */
-    char_u	*path;
-    int		flags;	/* EW_* flags */
-{
-    int		got;	/* Number of matches. */
-    char_u	*pattern;
-
-   /* Plan:
-    *
-    * 1) Get first part of path - no wildcards
-    * 2) Get next path element (wildcarded)
-    * 3) Get rest of path
-    *
-    * If (3) is nothing then only the leaf is wildcarded - add to gap
-    * Otherwise call recursively for each path in (2), passing (3)
-    *
-    * This is just the header function.
-    */
-
-    /* We must be able to modifiy path, so make a copy */
-    pattern = vim_strsave(path);
-    if (pattern == NULL)
-	return 0;
-    got = expand_section(gap, (char_u *)"", pattern, flags);
-    vim_free(pattern);
-    return got;
-}
-
-/*
- * expand_section(gap, "$.Dir1.Dir2", "ABBA*.myleaf##")
- *
- * calls expand_section(gap, "$.Dir1.Dir2.ABBA_Gold", "myleaf##")
- *   and expand_section(gap, "$.Dir1.Dir2.ABBA_Live", "myleaf##")
- *
- * If rest is just a leaf then all matches are added to gap.
- *
- * Returns number of items added to gap.
- */
-    int
-expand_section(gap, root, rest, flags)
-    garray_T	*gap;
-    char_u	*root;	/* Non-wildcarded path to search */
-    char_u	*rest;	/* Wildcarded remainder of path */
-    int		flags;	/* Add dirs/files/missing objects. */
-{
-    static char_u buf[MAXPATHL];	/* Temporary buffer. */
-    char_u dir[MAXPATHL];
-    int start_element = -1;		/* Start of wildcarded element */
-    char_u c;
-    int i;
-    int got, dir_pos;
-    int buflen;			/* Chars used in buf[] */
-    int colon = 0;		/* Dir ends in ':' */
-
-    buflen = strlen(root);
-    STRNCPY(buf, root, buflen);	/* Copy root into buffer. */
-
-   /*
-    * Find end of nonwildcarded section.
-    * Count ':' as a path sep since Vim:Bug* is a valid pathname.
-    */
-
-    for (i = 0; c = rest[i]; i++)
-    {
-	if (c == PATHSEP)
-	{
-	    start_element = i;
-	    colon = 0;
-	}
-	if (c == ':')
-	{
-	    start_element = i + 1;
-	    colon = 1;
-	}
-	if (c == '#' || c == '*')
-	    break;
-    }
-    if (c == 0)
-	start_element = i;
-
-   /*
-    * start_element +> terminator for non-wildcarded section.
-    * Transfer this bit into buf.
-    */
-    if (buflen + start_element + 4 >= MAXPATHL)
-       return 0;			/* Buffer full */
-    if (start_element >= 0)
-    {
-	if (*root && !colon)
-	    buf[buflen++] = PATHSEP;
-	strncpy(buf + buflen, rest, start_element);
-	buflen += start_element;
-    }
-    buf[buflen] = 0;
-
-   /*
-    * Did we reach the end of the string without hitting any wildcards?
-    */
-    if (c == 0)
-    {
-	/* Yes - add combined path to grow array and return. */
-	addfile(gap, buf, flags);
-	return 1;
-    }
-
-    if (start_element < 0 || !colon)
-	start_element++;
-    rest += start_element;
-
-   /*
-    * rest does contain wildcards if we get here.
-    *
-    * Now : have we reached the leaf names part yet?
-    * If so, add all matches (files and dirs) to gap.
-    * If not, get next path element and scan all matching directories.
-    */
-
-    start_element = -1;
-    for (i = 0; rest[i]; i++)
-    {
-	if (rest[i] == '.')
-	{
-	    start_element = i;
-	    rest[i] = 0;		/* Break string here. */
-	    break;
-	}
-    }
-
-    /* If start_element is -1 then we are matching leaf names */
-
-    r3 = 0;			/* Number of objs read. */
-    dir_pos = 0;		/* Position through directory. */
-    got = 0;			/* Files added so far. */
-    while (dir_pos != -1)
-    {
-	buf[buflen] = 0;
-	if (xswi(OS_GBPB, 9,
-		buf,				/* Directory to scan. */
-		buf + buflen + (1 - colon),	/* Buffer for result. */
-		1,			/* Number of objects to read. */
-		dir_pos,		/* Search position. */
-		MAXPATHL - 2 - buflen,	/* Size of result buffer. */
-		rest)			/* Wildcarded leafname. */
-			& v_flag)
-	{
-	    EMSG(r0 + 4);
-	    r4 = -1;
-	}
-	dir_pos = r4;		/* r4 corrupted by addfile() */
-	if (r3 > 0)
-	{
-	    char_u *path = buf;
-	    if (buflen == 0)
-		path++;			/* Don't do '.File' */
-	    else if (!colon)
-		buf[buflen] = '.';		/* Join path and leaf */
-
-	   /* Path -> full path of object found */
-	    if (start_element == -1)
-	    {
-		addfile(gap, path, flags);
-		got++;
-	    }
-	    else
-	    {
-	       /* Scan into subdirectories and images; ignore files */
-		swi(OS_File, 17, path);
-		if (r0 == 2 || r0 == 3)
-		    got += expand_section(gap,
-						path,
-						rest + start_element + 1,
-						flags);
-	    }
-	}
-    }
-
-    /* Restore the dot if we removed it. */
-    if (start_element >= 0)
-	rest[start_element] = '.';
-    return got;
-}
-
-/*
- * mch_expand_wildcards() - this code does wild-card pattern matching using
- * the shell. It isn't used under RISC OS.
- *
- * return OK for success, FAIL for error (you may lose some memory) and put
- * an error message in *file.
- *
- * num_pat is number of input patterns
- * pat is array of pointers to input patterns
- * num_file is pointer to number of matched file names
- * file is pointer to array of pointers to matched file names
- */
-    int
-mch_expand_wildcards(num_pat, pat, num_file, file, flags)
-    int		    num_pat;
-    char_u	  **pat;
-    int		   *num_file;
-    char_u	 ***file;
-    int		    flags;		/* EW_* flags */
-{
-    /* This doesn't get called unless SPECIAL_WILDCHAR is defined. */
-    return FAIL;
-}
-
-/*
- * Return TRUE if "p" contains wildcards which can be expanded by
- * mch_expandpath().
- */
-    int
-mch_has_exp_wildcard(p)
-    char_u	*p;
-{
-    if (vim_strpbrk((char_u *)"*#", p))
-	return TRUE;
-    return FALSE;
-}
-
-/* Return TRUE if "p" contains wildcards. */
-    int
-mch_has_wildcard(p)
-    char_u	*p;
-{
-    if (vim_strpbrk((char_u *)"*#`", p))
-	return TRUE;
-    return FALSE;
-}
-
-    int			/* see Unix unlink(2) */
-mch_remove(file)
-    char_u *file;	/* Name of file to delete. */
-{
-    if (xswi(OS_FSControl, 27, file, 0, 0) & v_flag)
-	return EXIT_FAILURE;
-    return EXIT_SUCCESS;
-}
-
-/* Try to make existing scripts work without modification.
- * Return a pointer to the new string (freed by caller), or NULL
- *
- * Two main cases:
- * - Absolute : $VIM/syntax/help.vim
- * - Relative : Adfs::4.$.!Vim.Resources.Syntax/help.vim
- */
-    char_u *
-mch_munge_fname(fname)
-    char_u *fname;
-{
-    char_u c;
-    int len;
-    char_u *retval;
-
-    retval = fname = vim_strsave(fname);
-    if (fname == NULL)
-	return NULL;
-
-    if (strncmp(fname, "$VIM/", 5) == 0)
-    {
-	strncpy(fname, "Vim:", 4);
-	for (fname += 5; c = *fname; fname++)
-	{
-	    if (c == '.')
-		break;
-	    if (c == '/')
-		fname[-1] = '.';
-	    else
-		fname[-1] = c;
-	}
-	fname[-1] = '\0';
-    }
-    else
-    {
-	/* Check to see if the file exists without modification. */
-	if (xswi(OS_File, 17, fname) & v_flag)
-	    r0 == 0;		/* Invalid filename? */
-	if (r0)
-	    return retval;
-
-	len = strlen(fname);
-	if (strcmp(fname + len - 4, ".vim") == 0)
-	{
-	    fname[len - 4] = '\0';
-	    for (; c = *fname; fname++)
-	    {
-		if (c == '/')
-		    *fname = '.';
-	    }
-	}
-    }
-    return retval;
-}
-
-/* QuickFix reads munged names from the error file.
- * Correct them.
- */
-    int
-ro_buflist_add(old_name)
-    char_u  *old_name;	/* Name of file found by quickfix */
-{
-    char_u  *fname;
-    char_u  *leaf;	/* Pointer to start of leaf in old_name */
-    char_u  *ptr;
-    char_u  c;
-    int	    retval;
-
-    if (old_name == NULL)
-	return buflist_add(NULL, 0);
-
-    /* Copy the name so we can mess around with it. */
-    fname = vim_strsave(old_name);
-    if (fname == NULL)
-	/* Out of memory - can't modify name */
-	return buflist_add(old_name, 0);
-
-    /* Change `dir/main.c' into `dir.c.main' */
-    leaf = fname;
-    for (ptr = fname; c = *ptr; ptr++)
-    {
-	if (c == '/')
-	{
-	    leaf = ptr + 1;
-	    *ptr = '.';
-	}
-	else if (c == '.')
-	    break;
-    }
-    if (c == '.')
-    {
-	/* Change `main.c' into `c.main'
-	 *	  |    |
-	 *      leaf  ptr
-	 */
-	ptr += old_name - fname;
-	*ptr = '\0';
-	sprintf(leaf,
-		"%s.%s",
-		ptr + 1,
-		leaf - fname + old_name);
-    }
-
-    retval = buflist_add(fname, 0);
-    free(fname);
-    return retval;
-}
-
-/* Change the current directory.
- * Strip trailing dots to make it easier to use with filename completion.
- * Return 0 for success, -1 for failure.
- */
-    int
-mch_chdir(dir)
-    char_u  *dir;
-{
-    int	    length;
-    int	    retval;
-    char_u  *new_dir;
-
-    if (p_verbose >= 5)
-    {
-	verbose_enter();
-	smsg((char_u *)"chdir(%s)", dir);
-	verbose_leave();
-    }
-    length = strlen(dir);
-    if (dir[length - 1] != '.')
-	return chdir(dir);	    /* No trailing dots - nothing to do. */
-    new_dir = vim_strsave(dir);
-    if (new_dir == NULL)
-	return chdir(dir);	    /* Can't allocate memory. */
-
-    while (new_dir[--length] == '.')
-	new_dir[length] = '\0';
-
-    retval = chdir(new_dir);
-    vim_free(new_dir);
-    return retval;
-}
-
-/* Examine the named file, and set the 'osfiletype' option
- * (in curbuf) to the file's type.
- */
-    void
-mch_read_filetype(file)
-    char_u  *file;
-{
-    int	    type;
-    char_u  type_string[9];
-    int	    i;
-
-    if (xswi(OS_File, 23, file) & v_flag)
-	type = 0xfff;		/* Default to Text */
-    else
-	type = r6;
-
-    /* Type is the numerical value - see if we have a textual equivalent */
-    swi(OS_FSControl, 18, 0, type);
-    ((int *) type_string)[0] = r2;
-    ((int *) type_string)[1] = r3;
-    type_string[8] = 0;
-    for (i = 0; type_string[i] > ' '; i++)
-	;
-    type_string[i] = 0;
-
-    set_string_option_direct("osfiletype", -1, type_string, OPT_FREE, 0);
-    return;
-}
-
-    void
-mch_set_filetype(file, type)
-    char_u  *file;
-    char_u  *type;
-{
-    if (xswi(OS_FSControl, 31, type) & v_flag)
-    {
-	EMSG(_("E366: Invalid 'osfiletype' option - using Text"));
-	r2 = 0xfff;
-    }
-
-    swi(OS_File, 18, file, r2);
-}
-
-/* Return TRUE if the file's type matches 'type'
- * RISC OS types always start with '&'
- */
-    int
-mch_check_filetype(fname, type)
-    char_u  *fname;
-    char_u  *type;
-{
-    int	    value;
-    char    *end;
-
-    if (*type != '&')
-	return FALSE;
-
-    value = strtol(type + 1, &end, 16);
-    if (*end)
-	return FALSE;		/* Invalid type (report error?) */
-
-    if (xswi(OS_File, 23, fname) & v_flag)
-	return FALSE;		/* Invalid filename? */
-
-    return (r0 && r6 == value);
-}
diff -Naur vim73.orig/src/os_riscos.h vim73/src/os_riscos.h
--- vim73.orig/src/os_riscos.h	2010-05-23 12:16:06.000000000 +0000
+++ vim73/src/os_riscos.h	1970-01-01 00:00:00.000000000 +0000
@@ -1,166 +0,0 @@
-/* vi:set ts=8 sts=4 sw=4:
- *
- * VIM - Vi IMproved	by Bram Moolenaar
- *
- * Do ":help uganda"  in Vim to read copying and usage conditions.
- * Do ":help credits" in Vim to see a list of people who contributed.
- */
-
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/ioctl.h>
-#include <termios.h>
-#include <stdlib.h>
-#include <unixlib/local.h>
-#include <errno.h>
-#include <fcntl.h>
-
-#define CASE_INSENSITIVE_FILENAME
-#define FEAT_MODIFY_FNAME
-#define FEAT_OSFILETYPE
-#define DFLT_OFT	"Text"
-#define USE_TERM_CONSOLE
-#define HAVE_AVAIL_MEM
-
-/* Longer filenames now accessible to all */
-#ifndef BASENAMELEN
-# define BASENAMELEN 64 /* Same length as unzip */
-#endif
-
-#ifndef TEMNAME
-# define TEMPNAME	"<Wimp$ScrapDir>.v?XXXXXX"
-# define TEMPNAMELEN	25
-#endif
-
-#ifndef DFLT_HELPFILE
-# define DFLT_HELPFILE "Vim:doc.help"
-#endif
-
-#ifndef DFLT_BDIR
-# define DFLT_BDIR	".,<Wimp$ScrapDir>."	/* default for 'backupdir' */
-#endif
-
-/* Paths to try putting swap file in. */
-#ifndef DFLT_DIR
-# define DFLT_DIR	"<Wimp$ScrapDir>.,."	/* default for 'directory' */
-#endif
-
-#ifndef DFLT_VDIR
-# define DFLT_VDIR	"Choices:Vim.view"	/* default for 'viewdir' */
-#endif
-
-#ifndef TERMCAPFILE
-# define TERMCAPFILE	"Vim:TermCap"
-#endif
-#define HAVE_TGETENT
-
-#ifndef SYNTAX_FNAME
-# define SYNTAX_FNAME	"Vim:Syntax.%s"
-#endif
-
-#ifndef EVIM_FILE
-# define EVIM_FILE	"Vim:Evim"
-#endif
-
-#define FEAT_VIMINFO
-
-#ifndef VIMINFO_FILE
-# define VIMINFO_FILE	"<Choices$Write>.Vim.VimInfo"
-#endif
-#ifndef VIMINFO_FILE2
-# define VIMINFO_FILE2	"Choices:Vim.VimInfo"
-#endif
-
-#ifndef VIMRC_FILE
-# define VIMRC_FILE	"/vimrc"
-#endif
-#ifndef EXRC_FILE
-# define EXRC_FILE	"/exrc"
-#endif
-#ifndef GVIMRC_FILE
-# define GVIMRC_FILE	"/gvimrc"
-#endif
-#ifndef USR_VIMRC_FILE
-# define USR_VIMRC_FILE	"Vim:Evim"
-#endif
-#ifndef SESSION_FILE
-# define SESSION_FILE	"/Session.vim"
-#endif
-#ifndef USR_VIMRC_FILE
-# define USR_VIMRC_FILE	"Choices:Vim.VimRC"
-#endif
-#ifndef USR_GVIMRC_FILE
-# define USR_GVIMRC_FILE    "Choices:Vim.GVimRC"
-#endif
-#ifndef USR_EXRC_FILE
-# define USR_EXRC_FILE    "Choices:Vim.ExRC"
-#endif
-#ifndef SYS_VIMRC_FILE
-# define SYS_VIMRC_FILE	    "Vim:VimRC"
-#endif
-#ifndef SYS_GVIMRC_FILE
-# define SYS_GVIMRC_FILE    "Vim:GVimRC"
-#endif
-#ifndef SYS_MENU_FILE
-# define SYS_MENU_FILE	    "Vim:Menu"
-#endif
-#ifndef SYS_OPTWIN_FILE
-# define SYS_OPTWIN_FILE    "Vim:Optwin"
-#endif
-#ifndef FILETYPE_FILE
-# define FILETYPE_FILE	    "Vim:Filetype"
-#endif
-#ifndef FTPLUGIN_FILE
-# define FTPLUGIN_FILE	    "Vim:Ftplugin/vim"
-#endif
-#ifndef INDENT_FILE
-# define INDENT_FILE	    "Vim:Indent/vim"
-#endif
-#ifndef FTOFF_FILE
-# define FTOFF_FILE	    "Vim:Ftoff"
-#endif
-#ifndef FTPLUGOF_FILE
-# define FTPLUGOF_FILE	    "Vim:Ftplugof"
-#endif
-#ifndef INDOFF_FILE
-# define INDOFF_FILE	    "Vim:Indoff"
-#endif
-
-#define DFLT_ERRORFILE		"errors/vim"
-#define DFLT_RUNTIMEPATH	"Choices:Vim,Vim:,Choices:Vim.after"
-
-/*
- * RISC PCs have plenty of memory, use large buffers
- */
-#define CMDBUFFSIZE 1024	/* size of the command processing buffer */
-#define MAXPATHL    256		/* paths are always quite short though */
-
-#ifndef DFLT_MAXMEM
-# define DFLT_MAXMEM	(5*1024)    /* use up to 5 Mbyte for a buffer */
-#endif
-
-#ifndef DFLT_MAXMEMTOT
-# define DFLT_MAXMEMTOT	(10*1024)    /* use up to 10 Mbyte for Vim */
-#endif
-
-#ifdef HAVE_SIGSET
-# define signal sigset
-#endif
-
-#define n_flag (1<<31)
-#define z_flag (1<<30)
-#define c_flag (1<<29)
-#define v_flag (1<<28)
-
-/* These take r0-r7 as inputs, returns r0-r7 in global variables. */
-void swi(int swinum, ...);      /* Handles errors itself */
-int xswi(int swinum, ...);      /* Returns errors using v flag */
-extern int r0, r1, r2, r3, r4, r5, r6, r7;  /* For return values */
-
-#include <kernel.h>
-#include <swis.h>
-
-#define mch_memmove(to, from, len) memmove((char *)(to), (char *)(from), len)
-#define mch_rename(src, dst) rename(src, dst)
-#define mch_getenv(x) (char_u *)getenv((char *)x)
-#define mch_setenv(name, val, x) setenv(name, val, x)
diff -Naur vim73.orig/src/os_unix.c vim73/src/os_unix.c
--- vim73.orig/src/os_unix.c	2010-08-08 13:14:04.000000000 +0000
+++ vim73/src/os_unix.c	2011-05-17 09:38:27.327053814 +0000
@@ -283,7 +283,7 @@
 #ifdef SIGTERM
     {SIGTERM,	    "TERM",	TRUE},
 #endif
-#ifdef SIGVTALRM
+#if defined(SIGVTALRM) && !defined(FEAT_RUBY)
     {SIGVTALRM,	    "VTALRM",	TRUE},
 #endif
 #if defined(SIGPROF) && !defined(FEAT_MZSCHEME) && !defined(WE_ARE_PROFILING)
@@ -1107,7 +1107,7 @@
  * On Linux, signal is not always handled immediately either.
  * See https://bugs.launchpad.net/bugs/291373
  *
- * volatile because it is used in in signal handler sigcont_handler().
+ * volatile because it is used in signal handler sigcont_handler().
  */
 static volatile int sigcont_received;
 static RETSIGTYPE sigcont_handler __ARGS(SIGPROTOARG);
@@ -1123,6 +1123,30 @@
 }
 #endif
 
+# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+static void loose_clipboard __ARGS((void));
+
+/*
+ * Called when Vim is going to sleep or execute a shell command.
+ * We can't respond to requests for the X selections.  Lose them, otherwise
+ * other applications will hang.  But first copy the text to cut buffer 0.
+ */
+    static void
+loose_clipboard()
+{
+    if (clip_star.owned || clip_plus.owned)
+    {
+	x11_export_final_selection();
+	if (clip_star.owned)
+	    clip_lose_selection(&clip_star);
+	if (clip_plus.owned)
+	    clip_lose_selection(&clip_plus);
+	if (x11_display != NULL)
+	    XFlush(x11_display);
+    }
+}
+#endif
+
 /*
  * If the machine has job control, use it to suspend the program,
  * otherwise fake it by starting a new shell.
@@ -1137,19 +1161,7 @@
     out_flush();	    /* needed to disable mouse on some systems */
 
 # if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
-    /* Since we are going to sleep, we can't respond to requests for the X
-     * selections.  Lose them, otherwise other applications will hang.  But
-     * first copy the text to cut buffer 0. */
-    if (clip_star.owned || clip_plus.owned)
-    {
-	x11_export_final_selection();
-	if (clip_star.owned)
-	    clip_lose_selection(&clip_star);
-	if (clip_plus.owned)
-	    clip_lose_selection(&clip_plus);
-	if (x11_display != NULL)
-	    XFlush(x11_display);
-    }
+    loose_clipboard();
 # endif
 
 # if defined(_REENTRANT) && defined(SIGCONT)
@@ -1726,6 +1738,11 @@
     }
     if (x11_window == 0 || x11_display == NULL)
 	return (result = FAIL);
+
+# ifdef FEAT_EVAL
+    set_vim_var_nr(VV_WINDOWID, (long)x11_window);
+# endif
+
     return (result = OK);
 }
 
@@ -3706,6 +3723,10 @@
     if (options & SHELL_COOKED)
 	settmode(TMODE_COOK);	    /* set to normal mode */
 
+# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+    loose_clipboard();
+# endif
+
 # ifdef __EMX__
     if (cmd == NULL)
 	x = system("");	/* this starts an interactive shell in emx */
@@ -3814,13 +3835,17 @@
 # endif
     int		did_settmode = FALSE;	/* settmode(TMODE_RAW) called */
 
+    newcmd = vim_strsave(p_sh);
+    if (newcmd == NULL)		/* out of memory */
+	goto error;
+
     out_flush();
     if (options & SHELL_COOKED)
 	settmode(TMODE_COOK);		/* set to normal mode */
 
-    newcmd = vim_strsave(p_sh);
-    if (newcmd == NULL)		/* out of memory */
-	goto error;
+# if defined(FEAT_CLIPBOARD) && defined(FEAT_X11)
+    loose_clipboard();
+# endif
 
     /*
      * Do this loop twice:
@@ -4148,7 +4173,6 @@
 # ifdef FEAT_GUI
 		if (pty_master_fd >= 0)
 		{
-		    close(pty_slave_fd);	/* close slave side of pty */
 		    fromshell_fd = pty_master_fd;
 		    toshell_fd = dup(pty_master_fd);
 		}
@@ -4221,7 +4245,7 @@
 				 * should not have one. */
 				if (lnum != curbuf->b_op_end.lnum
 					|| !curbuf->b_p_bin
-					|| (lnum != write_no_eol_lnum
+					|| (lnum != curbuf->b_no_eol_lnum
 					    && (lnum !=
 						    curbuf->b_ml.ml_line_count
 						    || curbuf->b_p_eol)))
@@ -4430,7 +4454,7 @@
 		    ++noread_cnt;
 		    while (RealWaitForChar(fromshell_fd, 10L, NULL))
 		    {
-			len = read(fromshell_fd, (char *)buffer
+			len = read_eintr(fromshell_fd, buffer
 # ifdef FEAT_MBYTE
 				+ buffer_off, (size_t)(BUFLEN - buffer_off)
 # else
@@ -4564,10 +4588,10 @@
 		    {
 			append_ga_line(&ga);
 			/* remember that the NL was missing */
-			write_no_eol_lnum = curwin->w_cursor.lnum;
+			curbuf->b_no_eol_lnum = curwin->w_cursor.lnum;
 		    }
 		    else
-			write_no_eol_lnum = 0;
+			curbuf->b_no_eol_lnum = 0;
 		    ga_clear(&ga);
 		}
 
@@ -4617,6 +4641,14 @@
 		    break;
 	    }
 
+# ifdef FEAT_GUI
+	    /* Close slave side of pty.  Only do this after the child has
+	     * exited, otherwise the child may hang when it tries to write on
+	     * the pty. */
+	    if (pty_master_fd >= 0)
+		close(pty_slave_fd);
+# endif
+
 	    /* Make sure the child that writes to the external program is
 	     * dead. */
 	    if (wpid > 0)
@@ -5693,6 +5725,7 @@
 	if (shell_style == STYLE_PRINT && !did_find_nul)
 	{
 	    /* If there is a NUL, set did_find_nul, else set check_spaces */
+	    buffer[len] = NUL;
 	    if (len && (int)STRLEN(buffer) < (int)len - 1)
 		did_find_nul = TRUE;
 	    else
@@ -6562,7 +6595,7 @@
 	    xterm_hints.x = 2;
 	return TRUE;
     }
-    if (mouse_code == NULL)
+    if (mouse_code == NULL || STRLEN(mouse_code) > 45)
     {
 	xterm_trace = 0;
 	return FALSE;
diff -Naur vim73.orig/src/os_unix.h vim73/src/os_unix.h
--- vim73.orig/src/os_unix.h	2010-05-23 12:16:14.000000000 +0000
+++ vim73/src/os_unix.h	2011-05-17 09:37:20.566463390 +0000
@@ -184,10 +184,6 @@
 
 #define BASENAMELEN	(MAXNAMLEN - 5)
 
-#ifdef HAVE_ERRNO_H
-# include <errno.h>
-#endif
-
 #ifdef HAVE_PWD_H
 # include <pwd.h>
 #endif
diff -Naur vim73.orig/src/os_win16.c vim73/src/os_win16.c
--- vim73.orig/src/os_win16.c	2010-06-26 04:03:31.000000000 +0000
+++ vim73/src/os_win16.c	2011-05-17 09:35:40.553563716 +0000
@@ -20,13 +20,11 @@
 # pragma warn -obs
 #endif
 
-#include "vimio.h"
 #include "vim.h"
 
 #include <dos.h>
 #include <string.h>
 #include <sys/types.h>
-#include <errno.h>
 #include <signal.h>
 #include <limits.h>
 #include <process.h>
diff -Naur vim73.orig/src/os_win32.c vim73/src/os_win32.c
--- vim73.orig/src/os_win32.c	2010-07-14 14:49:36.000000000 +0000
+++ vim73/src/os_win32.c	2011-05-17 09:39:06.774675671 +0000
@@ -20,7 +20,6 @@
  * Roger Knobbe <rogerk@wonderware.com> did the initial port of Vim 3.0.
  */
 
-#include "vimio.h"
 #include "vim.h"
 
 #ifdef FEAT_MZSCHEME
@@ -28,7 +27,6 @@
 #endif
 
 #include <sys/types.h>
-#include <errno.h>
 #include <signal.h>
 #include <limits.h>
 #include <process.h>
@@ -206,42 +204,73 @@
 static int suppress_winsize = 1;	/* don't fiddle with console */
 #endif
 
+static char_u *exe_path = NULL;
+
     static void
 get_exe_name(void)
 {
-    char	temp[256];
-    static int	did_set_PATH = FALSE;
+    /* Maximum length of $PATH is more than MAXPATHL.  8191 is often mentioned
+     * as the maximum length that works (plus a NUL byte). */
+#define MAX_ENV_PATH_LEN 8192
+    char	temp[MAX_ENV_PATH_LEN];
+    char_u	*p;
 
     if (exe_name == NULL)
     {
 	/* store the name of the executable, may be used for $VIM */
-	GetModuleFileName(NULL, temp, 255);
+	GetModuleFileName(NULL, temp, MAX_ENV_PATH_LEN - 1);
 	if (*temp != NUL)
 	    exe_name = FullName_save((char_u *)temp, FALSE);
     }
 
-    if (!did_set_PATH && exe_name != NULL)
+    if (exe_path == NULL && exe_name != NULL)
     {
-	char_u	    *p;
-	char_u	    *newpath;
-
-	/* Append our starting directory to $PATH, so that when doing "!xxd"
-	 * it's found in our starting directory.  Needed because SearchPath()
-	 * also looks there. */
-	p = mch_getenv("PATH");
-	newpath = alloc((unsigned)(STRLEN(p) + STRLEN(exe_name) + 2));
-	if (newpath != NULL)
-	{
-	    STRCPY(newpath, p);
-	    STRCAT(newpath, ";");
-	    vim_strncpy(newpath + STRLEN(newpath), exe_name,
-					    gettail_sep(exe_name) - exe_name);
-	    vim_setenv((char_u *)"PATH", newpath);
-	    vim_free(newpath);
+	exe_path = vim_strnsave(exe_name,
+				     (int)(gettail_sep(exe_name) - exe_name));
+	if (exe_path != NULL)
+	{
+	    /* Append our starting directory to $PATH, so that when doing
+	     * "!xxd" it's found in our starting directory.  Needed because
+	     * SearchPath() also looks there. */
+	    p = mch_getenv("PATH");
+	    if (p == NULL
+		       || STRLEN(p) + STRLEN(exe_path) + 2 < MAX_ENV_PATH_LEN)
+	    {
+		if (p == NULL || *p == NUL)
+		    temp[0] = NUL;
+		else
+		{
+		    STRCPY(temp, p);
+		    STRCAT(temp, ";");
+		}
+		STRCAT(temp, exe_path);
+		vim_setenv((char_u *)"PATH", temp);
+	    }
 	}
+    }
+}
+
+/*
+ * Load library "name".
+ */
+    HINSTANCE
+vimLoadLib(char *name)
+{
+    HINSTANCE dll = NULL;
+    char old_dir[MAXPATHL];
 
-	did_set_PATH = TRUE;
+    if (exe_path == NULL)
+	get_exe_name();
+    if (exe_path != NULL && mch_dirname(old_dir, MAXPATHL) == OK)
+    {
+	/* Change directory to where the executable is, both to make sure we
+	 * find a .dll there and to avoid looking for a .dll in the current
+	 * directory. */
+	mch_chdir(exe_path);
+	dll = LoadLibrary(name);
+	mch_chdir(old_dir);
     }
+    return dll;
 }
 
 #if defined(DYNAMIC_GETTEXT) || defined(PROTO)
@@ -254,7 +283,7 @@
 static char *null_libintl_bindtextdomain(const char *, const char *);
 static char *null_libintl_bind_textdomain_codeset(const char *, const char *);
 
-static HINSTANCE hLibintlDLL = 0;
+static HINSTANCE hLibintlDLL = NULL;
 char *(*dyn_libintl_gettext)(const char *) = null_libintl_gettext;
 char *(*dyn_libintl_textdomain)(const char *) = null_libintl_textdomain;
 char *(*dyn_libintl_bindtextdomain)(const char *, const char *)
@@ -282,26 +311,16 @@
     if (hLibintlDLL)
 	return 1;
     /* Load gettext library (libintl.dll) */
-    hLibintlDLL = LoadLibrary(libname != NULL ? libname : GETTEXT_DLL);
+    hLibintlDLL = vimLoadLib(libname != NULL ? libname : GETTEXT_DLL);
     if (!hLibintlDLL)
     {
-	char_u	    dirname[_MAX_PATH];
-
-	/* Try using the path from gvim.exe to find the .dll there. */
-	get_exe_name();
-	STRCPY(dirname, exe_name);
-	STRCPY(gettail(dirname), GETTEXT_DLL);
-	hLibintlDLL = LoadLibrary((char *)dirname);
-	if (!hLibintlDLL)
+	if (p_verbose > 0)
 	{
-	    if (p_verbose > 0)
-	    {
-		verbose_enter();
-		EMSG2(_(e_loadlib), GETTEXT_DLL);
-		verbose_leave();
-	    }
-	    return 0;
+	    verbose_enter();
+	    EMSG2(_(e_loadlib), GETTEXT_DLL);
+	    verbose_leave();
 	}
+	return 0;
     }
     for (i = 0; libintl_entry[i].name != NULL
 					 && libintl_entry[i].ptr != NULL; ++i)
@@ -430,7 +449,7 @@
 	     * Seems like a lot of overhead to load/unload ADVAPI32.DLL each
 	     * time we verify security...
 	     */
-	    advapi_lib = LoadLibrary("ADVAPI32.DLL");
+	    advapi_lib = vimLoadLib("ADVAPI32.DLL");
 	    if (advapi_lib != NULL)
 	    {
 		pSetNamedSecurityInfo = (PSNSECINFO)GetProcAddress(advapi_lib,
@@ -1615,6 +1634,35 @@
     return TRUE;
 }
 
+#if ((defined(__MINGW32__) || defined (__CYGWIN32__)) && \
+        __MSVCRT_VERSION__ >= 0x800) || (defined(_MSC_VER) && _MSC_VER >= 1400)
+/*
+ * Bad parameter handler.
+ *
+ * Certain MS CRT functions will intentionally crash when passed invalid
+ * parameters to highlight possible security holes.  Setting this function as
+ * the bad parameter handler will prevent the crash.
+ *
+ * In debug builds the parameters contain CRT information that might help track
+ * down the source of a problem, but in non-debug builds the arguments are all
+ * NULL/0.  Debug builds will also produce assert dialogs from the CRT, it is
+ * worth allowing these to make debugging of issues easier.
+ */
+    static void
+bad_param_handler(const wchar_t *expression,
+    const wchar_t *function,
+    const wchar_t *file,
+    unsigned int line,
+    uintptr_t pReserved)
+{
+}
+
+# define SET_INVALID_PARAM_HANDLER \
+	((void)_set_invalid_parameter_handler(bad_param_handler))
+#else
+# define SET_INVALID_PARAM_HANDLER
+#endif
+
 #ifdef FEAT_GUI_W32
 
 /*
@@ -1627,6 +1675,9 @@
     extern int _fmode;
 #endif
 
+    /* Silently handle invalid parameters to CRT functions */
+    SET_INVALID_PARAM_HANDLER;
+
     /* Let critical errors result in a failure, not in a dialog box.  Required
      * for the timestamp test to work on removed floppies. */
     SetErrorMode(SEM_FAILCRITICALERRORS);
@@ -1835,8 +1886,7 @@
 	cb->BufferSize.X = cb->Info.dwSize.X;
 	cb->BufferSize.Y = cb->Info.dwSize.Y;
 	NumCells = cb->BufferSize.X * cb->BufferSize.Y;
-	if (cb->Buffer != NULL)
-	    vim_free(cb->Buffer);
+	vim_free(cb->Buffer);
 	cb->Buffer = (PCHAR_INFO)alloc(NumCells * sizeof(CHAR_INFO));
 	if (cb->Buffer == NULL)
 	    return FALSE;
@@ -2103,6 +2153,9 @@
     extern int _fmode;
 #endif
 
+    /* Silently handle invalid parameters to CRT functions */
+    SET_INVALID_PARAM_HANDLER;
+
     /* Let critical errors result in a failure, not in a dialog box.  Required
      * for the timestamp test to work on removed floppies. */
     SetErrorMode(SEM_FAILCRITICALERRORS);
@@ -2273,12 +2326,14 @@
     int		len)
 {
     char		szTrueName[_MAX_PATH + 2];
+    char		szTrueNameTemp[_MAX_PATH + 2];
     char		*ptrue, *ptruePrev;
     char		*porig, *porigPrev;
     int			flen;
     WIN32_FIND_DATA	fb;
     HANDLE		hFind;
     int			c;
+    int			slen;
 
     flen = (int)STRLEN(name);
     if (flen == 0 || flen > _MAX_PATH)
@@ -2323,12 +2378,19 @@
 	}
 	*ptrue = NUL;
 
+	/* To avoid a slow failure append "\*" when searching a directory,
+	 * server or network share. */
+	STRCPY(szTrueNameTemp, szTrueName);
+	slen = (int)strlen(szTrueNameTemp);
+	if (*porig == psepc && slen + 2 < _MAX_PATH)
+	    STRCPY(szTrueNameTemp + slen, "\\*");
+
 	/* Skip "", "." and "..". */
 	if (ptrue > ptruePrev
 		&& (ptruePrev[0] != '.'
 		    || (ptruePrev[1] != NUL
 			&& (ptruePrev[1] != '.' || ptruePrev[2] != NUL)))
-		&& (hFind = FindFirstFile(szTrueName, &fb))
+		&& (hFind = FindFirstFile(szTrueNameTemp, &fb))
 						      != INVALID_HANDLE_VALUE)
 	{
 	    c = *porig;
@@ -2578,30 +2640,73 @@
 }
 
 /*
+ * Create directory "name".
+ * Return 0 on success, -1 on error.
+ */
+    int
+mch_mkdir(char_u *name)
+{
+#ifdef FEAT_MBYTE
+    if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
+	WCHAR	*p;
+	int	retval;
+
+	p = enc_to_utf16(name, NULL);
+	if (p == NULL)
+	    return -1;
+	retval = _wmkdir(p);
+	vim_free(p);
+	return retval;
+    }
+#endif
+    return _mkdir(name);
+}
+
+/*
  * Return TRUE if file "fname" has more than one link.
  */
     int
 mch_is_linked(char_u *fname)
 {
+    BY_HANDLE_FILE_INFORMATION info;
+
+    return win32_fileinfo(fname, &info) == FILEINFO_OK
+						   && info.nNumberOfLinks > 1;
+}
+
+/*
+ * Get the by-handle-file-information for "fname".
+ * Returns FILEINFO_OK when OK.
+ * returns FILEINFO_ENC_FAIL when enc_to_utf16() failed.
+ * Returns FILEINFO_READ_FAIL when CreateFile() failed.
+ * Returns FILEINFO_INFO_FAIL when GetFileInformationByHandle() failed.
+ */
+    int
+win32_fileinfo(char_u *fname, BY_HANDLE_FILE_INFORMATION *info)
+{
     HANDLE	hFile;
-    int		res = 0;
-    BY_HANDLE_FILE_INFORMATION inf;
+    int		res = FILEINFO_READ_FAIL;
 #ifdef FEAT_MBYTE
     WCHAR	*wn = NULL;
 
     if (enc_codepage >= 0 && (int)GetACP() != enc_codepage)
+    {
 	wn = enc_to_utf16(fname, NULL);
+	if (wn == NULL)
+	    res = FILEINFO_ENC_FAIL;
+    }
     if (wn != NULL)
     {
 	hFile = CreateFileW(wn,		/* file name */
 		    GENERIC_READ,	/* access mode */
-		    0,			/* share mode */
+		    FILE_SHARE_READ | FILE_SHARE_WRITE,	/* share mode */
 		    NULL,		/* security descriptor */
 		    OPEN_EXISTING,	/* creation disposition */
-		    0,			/* file attributes */
+		    FILE_FLAG_BACKUP_SEMANTICS,	/* file attributes */
 		    NULL);		/* handle to template file */
 	if (hFile == INVALID_HANDLE_VALUE
-		&& GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
+			      && GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)
 	{
 	    /* Retry with non-wide function (for Windows 98). */
 	    vim_free(wn);
@@ -2612,17 +2717,18 @@
 #endif
 	hFile = CreateFile(fname,	/* file name */
 		    GENERIC_READ,	/* access mode */
-		    0,			/* share mode */
+		    FILE_SHARE_READ | FILE_SHARE_WRITE,	/* share mode */
 		    NULL,		/* security descriptor */
 		    OPEN_EXISTING,	/* creation disposition */
-		    0,			/* file attributes */
+		    FILE_FLAG_BACKUP_SEMANTICS,	/* file attributes */
 		    NULL);		/* handle to template file */
 
     if (hFile != INVALID_HANDLE_VALUE)
     {
-	if (GetFileInformationByHandle(hFile, &inf) != 0
-		&& inf.nNumberOfLinks > 1)
-	    res = 1;
+	if (GetFileInformationByHandle(hFile, info) != 0)
+	    res = FILEINFO_OK;
+	else
+	    res = FILEINFO_INFO_FAIL;
 	CloseHandle(hFile);
     }
 
@@ -3120,9 +3226,10 @@
      * It's nicer to run a filter command in a minimized window, but in
      * Windows 95 this makes the command MUCH slower.  We can't do it under
      * Win32s either as it stops the synchronous spawn workaround working.
+     * Don't activate the window to keep focus on Vim.
      */
     if ((options & SHELL_DOOUT) && !mch_windows95() && !gui_is_win32s())
-	si.wShowWindow = SW_SHOWMINIMIZED;
+	si.wShowWindow = SW_SHOWMINNOACTIVE;
     else
 	si.wShowWindow = SW_SHOWNORMAL;
     si.cbReserved2 = 0;
diff -Naur vim73.orig/src/os_win32.h vim73/src/os_win32.h
--- vim73.orig/src/os_win32.h	2010-05-31 19:50:24.000000000 +0000
+++ vim73/src/os_win32.h	2011-05-17 09:39:06.774675671 +0000
@@ -191,5 +191,5 @@
 #ifdef __BORLANDC__
 # define vim_mkdir(x, y) mkdir(x)
 #else
-# define vim_mkdir(x, y) _mkdir(x)
+# define vim_mkdir(x, y) mch_mkdir(x)
 #endif
diff -Naur vim73.orig/src/popupmnu.c vim73/src/popupmnu.c
--- vim73.orig/src/popupmnu.c	2010-08-08 13:14:58.000000000 +0000
+++ vim73/src/popupmnu.c	2011-05-17 09:34:02.792414321 +0000
@@ -558,8 +558,11 @@
 	    win_T	*curwin_save = curwin;
 	    int		res = OK;
 
-	    /* Open a preview window.  3 lines by default. */
+	    /* Open a preview window.  3 lines by default.  Prefer
+	     * 'previewheight' if set and smaller. */
 	    g_do_tagpreview = 3;
+	    if (p_pvh > 0 && p_pvh < g_do_tagpreview)
+		g_do_tagpreview = p_pvh;
 	    resized = prepare_tagpreview(FALSE);
 	    g_do_tagpreview = 0;
 
diff -Naur vim73.orig/src/proto/fileio.pro vim73/src/proto/fileio.pro
--- vim73.orig/src/proto/fileio.pro	2010-08-15 12:30:28.000000000 +0000
+++ vim73/src/proto/fileio.pro	2011-05-17 09:35:31.702546091 +0000
@@ -54,4 +54,6 @@
 int match_file_pat __ARGS((char_u *pattern, regprog_T *prog, char_u *fname, char_u *sfname, char_u *tail, int allow_dirs));
 int match_file_list __ARGS((char_u *list, char_u *sfname, char_u *ffname));
 char_u *file_pat_to_reg_pat __ARGS((char_u *pat, char_u *pat_end, char *allow_dirs, int no_bslash));
+long read_eintr __ARGS((int fd, void *buf, size_t bufsize));
+long write_eintr __ARGS((int fd, void *buf, size_t bufsize));
 /* vim: set ft=c : */
diff -Naur vim73.orig/src/proto/getchar.pro vim73/src/proto/getchar.pro
--- vim73.orig/src/proto/getchar.pro	2010-08-15 12:30:29.000000000 +0000
+++ vim73/src/proto/getchar.pro	2011-05-17 09:33:35.471446735 +0000
@@ -51,6 +51,7 @@
 int get_map_mode __ARGS((char_u **cmdp, int forceit));
 void map_clear __ARGS((char_u *cmdp, char_u *arg, int forceit, int abbr));
 void map_clear_int __ARGS((buf_T *buf, int mode, int local, int abbr));
+char_u *map_mode_to_chars __ARGS((int mode));
 int map_to_exists __ARGS((char_u *str, char_u *modechars, int abbr));
 int map_to_exists_mode __ARGS((char_u *rhs, int mode, int abbr));
 char_u *set_context_in_map_cmd __ARGS((expand_T *xp, char_u *cmd, char_u *arg, int forceit, int isabbrev, int isunmap, cmdidx_T cmdidx));
@@ -61,7 +62,7 @@
 int makemap __ARGS((FILE *fd, buf_T *buf));
 int put_escstr __ARGS((FILE *fd, char_u *strstart, int what));
 void check_map_keycodes __ARGS((void));
-char_u *check_map __ARGS((char_u *keys, int mode, int exact, int ign_mod, int abbr));
+char_u *check_map __ARGS((char_u *keys, int mode, int exact, int ign_mod, int abbr, mapblock_T **mp_ptr, int *local_ptr));
 void init_mappings __ARGS((void));
 void add_map __ARGS((char_u *map, int mode));
 /* vim: set ft=c : */
diff -Naur vim73.orig/src/proto/gui_athena.pro vim73/src/proto/gui_athena.pro
--- vim73.orig/src/proto/gui_athena.pro	2010-08-15 12:31:06.000000000 +0000
+++ vim73/src/proto/gui_athena.pro	2011-05-17 09:36:14.489797147 +0000
@@ -27,5 +27,5 @@
 void gui_mch_set_scrollbar_colors __ARGS((scrollbar_T *sb));
 Window gui_x11_get_wid __ARGS((void));
 char_u *gui_mch_browse __ARGS((int saving, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *filter));
-int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield));
+int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd));
 /* vim: set ft=c : */
diff -Naur vim73.orig/src/proto/gui_gtk.pro vim73/src/proto/gui_gtk.pro
--- vim73.orig/src/proto/gui_gtk.pro	2010-08-15 12:31:03.000000000 +0000
+++ vim73/src/proto/gui_gtk.pro	2011-05-17 09:36:14.489797147 +0000
@@ -13,7 +13,7 @@
 void gui_mch_destroy_scrollbar __ARGS((scrollbar_T *sb));
 char_u *gui_mch_browse __ARGS((int saving, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *filter));
 char_u *gui_mch_browsedir __ARGS((char_u *title, char_u *initdir));
-int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int def_but, char_u *textfield));
+int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int def_but, char_u *textfield, int ex_cmd));
 void gui_mch_show_popupmenu __ARGS((vimmenu_T *menu));
 void gui_make_popup __ARGS((char_u *path_name, int mouse_pos));
 void gui_mch_find_dialog __ARGS((exarg_T *eap));
diff -Naur vim73.orig/src/proto/gui_mac.pro vim73/src/proto/gui_mac.pro
--- vim73.orig/src/proto/gui_mac.pro	2010-08-14 19:40:45.000000000 +0000
+++ vim73/src/proto/gui_mac.pro	2011-05-17 09:36:14.493796703 +0000
@@ -81,7 +81,7 @@
 int gui_mch_get_mouse_y __ARGS((void));
 void gui_mch_setmouse __ARGS((int x, int y));
 void gui_mch_show_popupmenu __ARGS((vimmenu_T *menu));
-int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield));
+int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd));
 char_u *gui_mch_browse __ARGS((int saving, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *filter));
 void gui_mch_set_foreground __ARGS((void));
 void gui_mch_show_tabline __ARGS((int showit));
diff -Naur vim73.orig/src/proto/gui_motif.pro vim73/src/proto/gui_motif.pro
--- vim73.orig/src/proto/gui_motif.pro	2010-08-15 12:31:04.000000000 +0000
+++ vim73/src/proto/gui_motif.pro	2011-05-17 09:36:14.493796703 +0000
@@ -29,7 +29,7 @@
 void gui_mch_set_scrollbar_colors __ARGS((scrollbar_T *sb));
 Window gui_x11_get_wid __ARGS((void));
 char_u *gui_mch_browse __ARGS((int saving, char_u *title, char_u *dflt, char_u *ext, char_u *initdir, char_u *filter));
-int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *button_names, int dfltbutton, char_u *textfield));
+int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *button_names, int dfltbutton, char_u *textfield, int ex_cmd));
 void gui_mch_enable_footer __ARGS((int showit));
 void gui_mch_set_footer __ARGS((char_u *s));
 void gui_mch_show_toolbar __ARGS((int showit));
diff -Naur vim73.orig/src/proto/gui_photon.pro vim73/src/proto/gui_photon.pro
--- vim73.orig/src/proto/gui_photon.pro	2010-08-15 12:31:10.000000000 +0000
+++ vim73/src/proto/gui_photon.pro	2011-05-17 09:36:14.493796703 +0000
@@ -8,7 +8,7 @@
 void gui_mch_update __ARGS((void));
 int gui_mch_wait_for_chars __ARGS((int wtime));
 char_u *gui_mch_browse __ARGS((int saving, char_u *title, char_u *default_name, char_u *ext, char_u *initdir, char_u *filter));
-int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int default_button, char_u *textfield));
+int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int default_button, char_u *textfield, int ex_cmd));
 int gui_mch_get_winpos __ARGS((int *x, int *y));
 void gui_mch_set_winpos __ARGS((int x, int y));
 void gui_mch_set_shellsize __ARGS((int width, int height, int min_width, int min_height, int base_width, int base_height, int direction));
diff -Naur vim73.orig/src/proto/gui_riscos.pro vim73/src/proto/gui_riscos.pro
--- vim73.orig/src/proto/gui_riscos.pro	2010-05-15 11:04:08.000000000 +0000
+++ vim73/src/proto/gui_riscos.pro	1970-01-01 00:00:00.000000000 +0000
@@ -1,66 +0,0 @@
-/* Prototypes for gui_riscos.c
- * Based on gui_x11_pro.h (10 March 2002 version)
- */
-void gui_mch_prepare __ARGS((int *argc, char **argv));
-int gui_mch_init_check __ARGS((void));
-int gui_mch_init __ARGS((void));
-void gui_mch_uninit __ARGS((void));
-void gui_mch_new_colors __ARGS((void));
-int gui_mch_open __ARGS((void));
-void gui_init_tooltip_font __ARGS((void));
-void gui_init_menu_font __ARGS((void));void gui_mch_exit __ARGS((int rc));
-int gui_mch_get_winpos __ARGS((int *x, int *y));
-void gui_mch_set_winpos __ARGS((int x, int y));
-void gui_mch_set_shellsize __ARGS((int width, int height, int min_width, int min_height, int base_width, int base_height));
-void gui_mch_get_screen_dimensions __ARGS((int *screen_w, int *screen_h));
-int gui_mch_init_font __ARGS((char_u *font_name, int do_fontset));
-GuiFont gui_mch_get_font __ARGS((char_u *name, int giveErrorIfMissing));
-int gui_mch_adjust_charheight __ARGS((void));
-void gui_mch_set_font __ARGS((GuiFont font));
-void gui_mch_set_fontset __ARGS((GuiFontset fontset));
-void gui_mch_free_font __ARGS((GuiFont font));
-void gui_mch_free_fontset __ARGS((GuiFontset fontset));
-GuiFontset gui_mch_get_fontset __ARGS((char_u *name, int giveErrorIfMissing, int fixed_width));
-guicolor_T gui_mch_get_color __ARGS((char_u *reqname));
-void gui_mch_set_fg_color __ARGS((guicolor_T color));
-void gui_mch_set_bg_color __ARGS((guicolor_T color));
-void gui_mch_draw_string __ARGS((int row, int col, char_u *s, int len, int flags));
-int gui_mch_haskey __ARGS((char_u *name));
-void gui_mch_beep __ARGS((void));
-void gui_mch_flash __ARGS((int msec));
-void gui_mch_invert_rectangle __ARGS((int r, int c, int nr, int nc));
-void gui_mch_iconify __ARGS((void));
-void gui_mch_set_foreground __ARGS((void));
-void gui_mch_draw_hollow_cursor __ARGS((guicolor_T color));
-void gui_mch_draw_part_cursor __ARGS((int w, int h, guicolor_T color));
-void gui_mch_update __ARGS((void));
-int gui_mch_wait_for_chars __ARGS((long wtime));
-void gui_mch_flush __ARGS((void));
-void gui_mch_clear_block __ARGS((int row1, int col1, int row2, int col2));
-void gui_mch_clear_all __ARGS((void));
-void gui_mch_delete_lines __ARGS((int row, int num_lines));
-void gui_mch_insert_lines __ARGS((int row, int num_lines));
-void clip_mch_lose_selection __ARGS((VimClipboard *cbd));
-int clip_mch_own_selection __ARGS((VimClipboard *cbd));
-void clip_mch_request_selection __ARGS((VimClipboard *cbd));
-void clip_mch_set_selection __ARGS((VimClipboard *cbd));
-void gui_mch_menu_grey __ARGS((vimmenu_T *menu, int grey));
-void gui_mch_menu_hidden __ARGS((vimmenu_T *menu, int hidden));
-void gui_mch_draw_menubar __ARGS((void));
-void gui_mch_set_blinking __ARGS((long waittime, long on, long off));
-void gui_mch_stop_blink __ARGS((void));
-void gui_mch_start_blink __ARGS((void));
-void process_event __ARGS((int event, int *block));
-void gui_mch_show_popupmenu __ARGS((vimmenu_T *menu));
-long_u gui_mch_get_rgb __ARGS((guicolor_T pixel));
-void gui_mch_getmouse __ARGS((int *x, int *y));
-void gui_mch_setmouse __ARGS((int x, int y));
-void gui_mch_drawsign __ARGS((int row, int col, int typenr));
-void gui_mch_destroy_sign __ARGS((XImage *sign));
-void gui_mch_mousehide __ARGS((int hide));
-void mch_set_mouse_shape __ARGS((int shape));
-void gui_mch_menu_set_tip __ARGS((vimmenu_T *menu));
-
-void ro_redraw_title __ARGS((int window));
-int ro_ok_to_quit __ARGS((void));
-/* vim: set ft=c : */
diff -Naur vim73.orig/src/proto/gui_w16.pro vim73/src/proto/gui_w16.pro
--- vim73.orig/src/proto/gui_w16.pro	2010-08-15 12:31:09.000000000 +0000
+++ vim73/src/proto/gui_w16.pro	2011-05-17 09:36:14.493796703 +0000
@@ -74,6 +74,6 @@
 void gui_mch_add_menu_item __ARGS((vimmenu_T *menu, int idx));
 void gui_mch_destroy_menu __ARGS((vimmenu_T *menu));
 void gui_mch_menu_grey __ARGS((vimmenu_T *menu, int grey));
-int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield));
+int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd));
 void gui_mch_set_foreground __ARGS((void));
 /* vim: set ft=c : */
diff -Naur vim73.orig/src/proto/gui_w32.pro vim73/src/proto/gui_w32.pro
--- vim73.orig/src/proto/gui_w32.pro	2010-08-15 12:31:09.000000000 +0000
+++ vim73/src/proto/gui_w32.pro	2011-05-17 09:36:14.493796703 +0000
@@ -81,7 +81,7 @@
 void gui_mch_add_menu_item __ARGS((vimmenu_T *menu, int idx));
 void gui_mch_destroy_menu __ARGS((vimmenu_T *menu));
 void gui_mch_menu_grey __ARGS((vimmenu_T *menu, int grey));
-int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield));
+int gui_mch_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd));
 void gui_mch_set_foreground __ARGS((void));
 void gui_mch_drawsign __ARGS((int row, int col, int typenr));
 void *gui_mch_register_sign __ARGS((char_u *signfile));
diff -Naur vim73.orig/src/proto/message.pro vim73/src/proto/message.pro
--- vim73.orig/src/proto/message.pro	2010-08-15 12:30:41.000000000 +0000
+++ vim73/src/proto/message.pro	2011-05-17 09:36:14.481798035 +0000
@@ -33,6 +33,7 @@
 int msg_outtrans_len_attr __ARGS((char_u *msgstr, int len, int attr));
 void msg_make __ARGS((char_u *arg));
 int msg_outtrans_special __ARGS((char_u *strstart, int from));
+char_u *str2special_save __ARGS((char_u *str, int is_lhs));
 char_u *str2special __ARGS((char_u **sp, int from));
 void str2specialbuf __ARGS((char_u *sp, char_u *buf, int len));
 void msg_prt_line __ARGS((char_u *s, int list));
@@ -63,7 +64,7 @@
 int verbose_open __ARGS((void));
 void give_warning __ARGS((char_u *message, int hl));
 void msg_advance __ARGS((int col));
-int do_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield));
+int do_dialog __ARGS((int type, char_u *title, char_u *message, char_u *buttons, int dfltbutton, char_u *textfield, int ex_cmd));
 void display_confirm_msg __ARGS((void));
 int vim_dialog_yesno __ARGS((int type, char_u *title, char_u *message, int dflt));
 int vim_dialog_yesnocancel __ARGS((int type, char_u *title, char_u *message, int dflt));
diff -Naur vim73.orig/src/proto/misc2.pro vim73/src/proto/misc2.pro
--- vim73.orig/src/proto/misc2.pro	2010-08-15 12:30:42.000000000 +0000
+++ vim73/src/proto/misc2.pro	2011-05-17 09:38:27.323054258 +0000
@@ -40,6 +40,7 @@
 void copy_chars __ARGS((char_u *ptr, size_t count, int c));
 void del_trailing_spaces __ARGS((char_u *ptr));
 void vim_strncpy __ARGS((char_u *to, char_u *from, size_t len));
+void vim_strcat __ARGS((char_u *to, char_u *from, size_t tosize));
 int copy_option_part __ARGS((char_u **option, char_u *buf, int maxlen, char *sep_chars));
 void vim_free __ARGS((void *x));
 int vim_stricmp __ARGS((char *s1, char *s2));
diff -Naur vim73.orig/src/proto/option.pro vim73/src/proto/option.pro
--- vim73.orig/src/proto/option.pro	2010-08-15 12:30:46.000000000 +0000
+++ vim73/src/proto/option.pro	2011-05-17 09:36:16.709550779 +0000
@@ -54,6 +54,6 @@
 int option_was_set __ARGS((char_u *name));
 int can_bs __ARGS((int what));
 void save_file_ff __ARGS((buf_T *buf));
-int file_ff_differs __ARGS((buf_T *buf));
+int file_ff_differs __ARGS((buf_T *buf, int ignore_empty));
 int check_ff_value __ARGS((char_u *p));
 /* vim: set ft=c : */
diff -Naur vim73.orig/src/proto/os_riscos.pro vim73/src/proto/os_riscos.pro
--- vim73.orig/src/proto/os_riscos.pro	2010-08-15 12:31:16.000000000 +0000
+++ vim73/src/proto/os_riscos.pro	1970-01-01 00:00:00.000000000 +0000
@@ -1,49 +0,0 @@
-/* os_riscos.c */
-void mch_write __ARGS((char_u *s, int len));
-int mch_inchar __ARGS((char_u *buf, int maxlen, long wtime, int tb_change_cnt));
-int mch_char_avail __ARGS((void));
-long_u mch_avail_mem __ARGS((int special));
-void mch_delay __ARGS((long msec, int ignoreinput));
-void mch_suspend __ARGS((void));
-void mch_init __ARGS((void));
-int mch_check_win __ARGS((int argc, char **argv));
-int mch_input_isatty __ARGS((void));
-int mch_can_restore_title __ARGS((void));
-int mch_can_restore_icon __ARGS((void));
-void mch_settitle __ARGS((char_u *title, char_u *icon));
-void mch_restore_title __ARGS((int which));
-int mch_get_user_name __ARGS((char_u *s, int len));
-void mch_get_host_name __ARGS((char_u *s, int len));
-long mch_get_pid __ARGS((void));
-int mch_dirname __ARGS((char_u *buf, int len));
-int mch_FullName __ARGS((char_u *fname, char_u *buf, int len, int force));
-int mch_isFullName __ARGS((char_u *fname));
-long mch_getperm __ARGS((char_u *name));
-int mch_setperm __ARGS((char_u *name, long perm));
-void mch_hide __ARGS((char_u *name));
-int mch_isdir __ARGS((char_u *name));
-int mch_can_exe __ARGS((char_u *name));
-int mch_nodetype __ARGS((char_u *name));
-void mch_early_init __ARGS((void));
-void mch_exit __ARGS((int r));
-void mch_settmode __ARGS((int tmode));
-void mch_setmouse __ARGS((int on));
-int mch_screenmode __ARGS((char_u *arg));
-int mch_get_shellsize __ARGS((void));
-void mch_set_shellsize __ARGS((void));
-void mch_new_shellsize __ARGS((void));
-int mch_call_shell __ARGS((char_u *cmd, int options));
-void mch_breakcheck __ARGS((void));
-int mch_expandpath __ARGS((garray_T *gap, char_u *path, int flags));
-int expand_section __ARGS((garray_T *gap, char_u *root, char_u *rest, int flags));
-int mch_expand_wildcards __ARGS((int num_pat, char_u **pat, int *num_file, char_u ***file, int flags));
-int mch_has_exp_wildcard __ARGS((char_u *p));
-int mch_has_wildcard __ARGS((char_u *p));
-int mch_remove __ARGS((char_u *file));
-char_u *mch_munge_fname __ARGS((char_u *fname));
-int ro_buflist_add __ARGS((char_u *old_name));
-int mch_chdir __ARGS((char_u *dir));
-void mch_read_filetype __ARGS((char_u *file));
-void mch_set_filetype __ARGS((char_u *file, char_u *type));
-int mch_check_filetype __ARGS((char_u *fname, char_u *type));
-/* vim: set ft=c : */
diff -Naur vim73.orig/src/proto/os_win32.pro vim73/src/proto/os_win32.pro
--- vim73.orig/src/proto/os_win32.pro	2010-08-15 12:31:14.000000000 +0000
+++ vim73/src/proto/os_win32.pro	2011-05-17 09:39:06.774675671 +0000
@@ -1,4 +1,5 @@
 /* os_win32.c */
+HINSTANCE vimLoadLib __ARGS((char *name));
 int dyn_libintl_init __ARGS((char *libname));
 void dyn_libintl_end __ARGS((void));
 void PlatformId __ARGS((void));
@@ -19,7 +20,9 @@
 int mch_setperm __ARGS((char_u *name, long perm));
 void mch_hide __ARGS((char_u *name));
 int mch_isdir __ARGS((char_u *name));
+int mch_mkdir __ARGS((char_u *name));
 int mch_is_linked __ARGS((char_u *fname));
+int win32_fileinfo __ARGS((char_u *name, BY_HANDLE_FILE_INFORMATION *lpFileInfo));
 int mch_writable __ARGS((char_u *name));
 int mch_can_exe __ARGS((char_u *name));
 int mch_nodetype __ARGS((char_u *name));
diff -Naur vim73.orig/src/proto.h vim73/src/proto.h
--- vim73.orig/src/proto.h	2010-07-17 15:28:51.000000000 +0000
+++ vim73/src/proto.h	2011-05-17 09:39:31.619918205 +0000
@@ -62,9 +62,6 @@
 # ifdef __BEOS__
 #  include "os_beos.pro"
 # endif
-# ifdef RISCOS
-#  include "os_riscos.pro"
-# endif
 # ifdef __QNX__
 #  include "os_qnx.pro"
 # endif
@@ -245,9 +242,6 @@
 #  ifdef FEAT_GUI_X11
 #   include "gui_x11.pro"
 #  endif
-#  ifdef RISCOS
-#   include "gui_riscos.pro"
-#  endif
 #  ifdef FEAT_GUI_PHOTON
 #   include "gui_photon.pro"
 #  endif
diff -Naur vim73.orig/src/pty.c vim73/src/pty.c
--- vim73.orig/src/pty.c	2010-07-24 18:23:01.000000000 +0000
+++ vim73/src/pty.c	2011-05-17 09:38:17.780113397 +0000
@@ -209,8 +209,8 @@
 #ifdef _SEQUENT_
     fvhangup(s);
 #endif
-    strncpy(PtyName, m, sizeof(PtyName));
-    strncpy(TtyName, s, sizeof(TtyName));
+    vim_strncpy((char_u *)PtyName, (char_u *)m, sizeof(PtyName) - 1);
+    vim_strncpy((char_u *)TtyName, (char_u *)s, sizeof(TtyName) - 1);
     initmaster(f);
     *ttyn = TtyName;
     return f;
@@ -301,7 +301,7 @@
 	return -1;
     }
     signal(SIGCHLD, sigcld);
-    strncpy(TtyName, m, sizeof(TtyName));
+    vim_strncpy((char_u *)TtyName, (char_u *)m, sizeof(TtyName) - 1);
     initmaster(f);
     *ttyn = TtyName;
     return f;
@@ -326,7 +326,7 @@
     /* a dumb looking loop replaced by mycrofts code: */
     if ((f = open("/dev/ptc", O_RDWR | O_NOCTTY | O_EXTRA)) < 0)
 	return -1;
-    strncpy(TtyName, ttyname(f), sizeof(TtyName));
+    vim_strncpy((char_u *)TtyName, (char_u *)ttyname(f), sizeof(TtyName) - 1);
     if (geteuid() != ROOT_UID && mch_access(TtyName, R_OK | W_OK))
     {
 	close(f);
diff -Naur vim73.orig/src/quickfix.c vim73/src/quickfix.c
--- vim73.orig/src/quickfix.c	2010-08-09 20:12:14.000000000 +0000
+++ vim73/src/quickfix.c	2011-05-17 09:39:31.619918205 +0000
@@ -1164,7 +1164,7 @@
 
 	/* When no valid entries are present in the list, qf_ptr points to
 	 * the first item in the list */
-	if (to_qfl->qf_nonevalid == TRUE)
+	if (to_qfl->qf_nonevalid)
 	    to_qfl->qf_ptr = to_qfl->qf_start;
     }
 
@@ -1182,21 +1182,17 @@
     if (fname == NULL || *fname == NUL)		/* no file name */
 	return 0;
     {
-#ifdef RISCOS
-	/* Name is reported as `main.c', but file is `c.main' */
-	return ro_buflist_add(fname);
-#else
 	char_u	    *ptr;
 	int	    fnum;
 
-# ifdef VMS
+#ifdef VMS
 	vms_remove_version(fname);
-# endif
-# ifdef BACKSLASH_IN_FILENAME
+#endif
+#ifdef BACKSLASH_IN_FILENAME
 	if (directory != NULL)
 	    slash_adjust(directory);
 	slash_adjust(fname);
-# endif
+#endif
 	if (directory != NULL && !vim_isAbsName(fname)
 		&& (ptr = concat_fnames(directory, fname, TRUE)) != NULL)
 	{
@@ -1221,7 +1217,6 @@
 	    return fnum;
 	}
 	return buflist_add(fname, 0);
-#endif
     }
 }
 
@@ -1656,9 +1651,7 @@
 	    opened_window = TRUE;	/* close it when fail */
 	    p_swb = empty_option;	/* don't split again */
 	    swb_flags = 0;
-# ifdef FEAT_SCROLLBIND
-	    curwin->w_p_scb = FALSE;
-# endif
+	    RESET_BINDING(curwin);
 	    if (ll_ref != NULL)
 	    {
 		/* The new window should use the location list from the
@@ -2125,6 +2118,7 @@
 	--qi->qf_lists[idx].qf_count;
     }
     vim_free(qi->qf_lists[idx].qf_title);
+    qi->qf_lists[idx].qf_title = NULL;
 }
 
 /*
@@ -2244,6 +2238,7 @@
      * it if we have errors; otherwise, leave it closed.
      */
     if (qi->qf_lists[qi->qf_curlist].qf_nonevalid
+	    || qi->qf_lists[qi->qf_curlist].qf_count == 0
 	    || qi->qf_curlist >= qi->qf_listcount)
     {
 	if (win != NULL)
@@ -2333,9 +2328,7 @@
 	    win_goto(lastwin);
 	if (win_split(height, WSP_BELOW | WSP_NEWLOC) == FAIL)
 	    return;		/* not enough room for window */
-#ifdef FEAT_SCROLLBIND
-	curwin->w_p_scb = FALSE;
-#endif
+	RESET_BINDING(curwin);
 
 	if (eap->cmdidx == CMD_lopen || eap->cmdidx == CMD_lwindow)
 	{
@@ -2362,6 +2355,7 @@
 	    set_option_value((char_u *)"bt", 0L, (char_u *)"quickfix",
 								   OPT_LOCAL);
 	    set_option_value((char_u *)"bh", 0L, (char_u *)"wipe", OPT_LOCAL);
+	    RESET_BINDING(curwin);
 #ifdef FEAT_DIFF
 	    curwin->w_p_diff = FALSE;
 #endif
@@ -2744,6 +2738,13 @@
 #ifdef FEAT_AUTOCMD
     char_u	*au_name = NULL;
 
+    /* Redirect ":grep" to ":vimgrep" if 'grepprg' is "internal". */
+    if (grep_internal(eap->cmdidx))
+    {
+	ex_vimgrep(eap);
+	return;
+    }
+
     switch (eap->cmdidx)
     {
 	case CMD_make:	    au_name = (char_u *)"make"; break;
@@ -2765,13 +2766,6 @@
     }
 #endif
 
-    /* Redirect ":grep" to ":vimgrep" if 'grepprg' is "internal". */
-    if (grep_internal(eap->cmdidx))
-    {
-	ex_vimgrep(eap);
-	return;
-    }
-
     if (eap->cmdidx == CMD_lmake || eap->cmdidx == CMD_lgrep
 	|| eap->cmdidx == CMD_lgrepadd)
 	wp = curwin;
@@ -3051,18 +3045,22 @@
     int		flags = 0;
     colnr_T	col;
     long	tomatch;
-    char_u	dirname_start[MAXPATHL];
-    char_u	dirname_now[MAXPATHL];
+    char_u	*dirname_start = NULL;
+    char_u	*dirname_now = NULL;
     char_u	*target_dir = NULL;
 #ifdef FEAT_AUTOCMD
     char_u	*au_name =  NULL;
 
     switch (eap->cmdidx)
     {
-	case CMD_vimgrep: au_name = (char_u *)"vimgrep"; break;
-	case CMD_lvimgrep: au_name = (char_u *)"lvimgrep"; break;
-	case CMD_vimgrepadd: au_name = (char_u *)"vimgrepadd"; break;
+	case CMD_vimgrep:     au_name = (char_u *)"vimgrep"; break;
+	case CMD_lvimgrep:    au_name = (char_u *)"lvimgrep"; break;
+	case CMD_vimgrepadd:  au_name = (char_u *)"vimgrepadd"; break;
 	case CMD_lvimgrepadd: au_name = (char_u *)"lvimgrepadd"; break;
+	case CMD_grep:	      au_name = (char_u *)"grep"; break;
+	case CMD_lgrep:	      au_name = (char_u *)"lgrep"; break;
+	case CMD_grepadd:     au_name = (char_u *)"grepadd"; break;
+	case CMD_lgrepadd:    au_name = (char_u *)"lgrepadd"; break;
 	default: break;
     }
     if (au_name != NULL)
@@ -3130,6 +3128,11 @@
 	goto theend;
     }
 
+    dirname_start = alloc(MAXPATHL);
+    dirname_now = alloc(MAXPATHL);
+    if (dirname_start == NULL || dirname_now == NULL)
+	goto theend;
+
     /* Remember the current directory, because a BufRead autocommand that does
      * ":lcd %:p:h" changes the meaning of short path names. */
     mch_dirname(dirname_start, MAXPATHL);
@@ -3366,6 +3369,8 @@
     }
 
 theend:
+    vim_free(dirname_now);
+    vim_free(dirname_start);
     vim_free(target_dir);
     vim_free(regmatch.regprog);
 }
@@ -3435,6 +3440,7 @@
     char_u	*fname;
 {
     buf_T	*newbuf;
+    buf_T	*newbuf_to_wipe = NULL;
     int		failed = TRUE;
     aco_save_T	aco;
 
@@ -3471,15 +3477,19 @@
 	    failed = FALSE;
 	    if (curbuf != newbuf)
 	    {
-		/* Bloody autocommands changed the buffer! */
-		if (buf_valid(newbuf))
-		    wipe_buffer(newbuf, FALSE);
+		/* Bloody autocommands changed the buffer!  Can happen when
+		 * using netrw and editing a remote file.  Use the current
+		 * buffer instead, delete the dummy one after restoring the
+		 * window stuff. */
+		newbuf_to_wipe = newbuf;
 		newbuf = curbuf;
 	    }
 	}
 
 	/* restore curwin/curbuf and a few other things */
 	aucmd_restbuf(&aco);
+	if (newbuf_to_wipe != NULL && buf_valid(newbuf_to_wipe))
+	    wipe_buffer(newbuf_to_wipe, FALSE);
     }
 
     if (!buf_valid(newbuf))
@@ -3697,7 +3707,7 @@
     }
 
     if (qi->qf_lists[qi->qf_curlist].qf_index == 0)
-	/* empty list or no valid entry */
+	/* no valid entry */
 	qi->qf_lists[qi->qf_curlist].qf_nonevalid = TRUE;
     else
 	qi->qf_lists[qi->qf_curlist].qf_nonevalid = FALSE;
diff -Naur vim73.orig/src/regexp.c vim73/src/regexp.c
--- vim73.orig/src/regexp.c	2010-07-12 20:41:48.000000000 +0000
+++ vim73/src/regexp.c	2011-05-17 09:32:31.202580142 +0000
@@ -3538,6 +3538,7 @@
 
     regline = line;
     reglnum = 0;
+    reg_toolong = FALSE;
 
     /* Simplest case: Anchored match need be tried only once. */
     if (prog->reganch)
diff -Naur vim73.orig/src/screen.c vim73/src/screen.c
--- vim73.orig/src/screen.c	2010-08-13 13:21:27.000000000 +0000
+++ vim73/src/screen.c	2011-05-17 09:37:41.084186175 +0000
@@ -2317,7 +2317,7 @@
 		num = (long)lnum;
 	    else
 		/* 'relativenumber', don't use negative numbers */
-		num = (long)abs((int)get_cursor_rel_lnum(wp, lnum));
+		num = labs((long)get_cursor_rel_lnum(wp, lnum));
 
 	    sprintf((char *)buf, "%*ld ", w, num);
 #ifdef FEAT_RIGHTLEFT
@@ -3405,9 +3405,9 @@
 # endif
 		   )
 		{
-		    int_u	text_sign;
+		    int	text_sign;
 # ifdef FEAT_SIGN_ICONS
-		    int_u	icon_sign;
+		    int	icon_sign;
 # endif
 
 		    /* Draw two cells with the sign value or blank. */
@@ -3475,8 +3475,7 @@
 			    num = (long)lnum;
 			else
 			    /* 'relativenumber', don't use negative numbers */
-			    num = (long)abs((int)get_cursor_rel_lnum(wp,
-								    lnum));
+			    num = labs((long)get_cursor_rel_lnum(wp, lnum));
 
 			sprintf((char *)extra, "%*ld ",
 						number_width(wp), num);
@@ -6436,6 +6435,8 @@
     struct	stl_hlrec hltab[STL_MAX_ITEM];
     struct	stl_hlrec tabtab[STL_MAX_ITEM];
     int		use_sandbox = FALSE;
+    win_T	*ewp;
+    int		p_crb_save;
 
     /* setup environment for the task at hand */
     if (wp == NULL)
@@ -6514,16 +6515,31 @@
     if (maxwidth <= 0)
 	return;
 
+    /* Temporarily reset 'cursorbind', we don't want a side effect from moving
+     * the cursor away and back. */
+    ewp = wp == NULL ? curwin : wp;
+    p_crb_save = ewp->w_p_crb;
+    ewp->w_p_crb = FALSE;
+
     /* Make a copy, because the statusline may include a function call that
      * might change the option value and free the memory. */
     stl = vim_strsave(stl);
-    width = build_stl_str_hl(wp == NULL ? curwin : wp,
-				buf, sizeof(buf),
+    width = build_stl_str_hl(ewp, buf, sizeof(buf),
 				stl, use_sandbox,
 				fillchar, maxwidth, hltab, tabtab);
     vim_free(stl);
-    len = (int)STRLEN(buf);
+    ewp->w_p_crb = p_crb_save;
+
+    /* Make all characters printable. */
+    p = transstr(buf);
+    if (p != NULL)
+    {
+	vim_strncpy(buf, p, sizeof(buf) - 1);
+	vim_free(p);
+    }
 
+    /* fill up with "fillchar" */
+    len = (int)STRLEN(buf);
     while (width < maxwidth && len < (int)sizeof(buf) - 1)
     {
 #ifdef FEAT_MBYTE
diff -Naur vim73.orig/src/search.c vim73/src/search.c
--- vim73.orig/src/search.c	2010-07-14 14:49:41.000000000 +0000
+++ vim73/src/search.c	2011-05-17 09:39:31.623917761 +0000
@@ -1161,12 +1161,20 @@
 	{
 	    if (spats[RE_SEARCH].pat == NULL)	    /* no previous pattern */
 	    {
-		EMSG(_(e_noprevre));
-		retval = 0;
-		goto end_do_search;
+		pat = spats[RE_SUBST].pat;
+		if (pat == NULL)
+		{
+		    EMSG(_(e_noprevre));
+		    retval = 0;
+		    goto end_do_search;
+		}
+		searchstr = pat;
+	    }
+	    else
+	    {
+		/* make search_regcomp() use spats[RE_SEARCH].pat */
+		searchstr = (char_u *)"";
 	    }
-	    /* make search_regcomp() use spats[RE_SEARCH].pat */
-	    searchstr = (char_u *)"";
 	}
 
 	if (pat != NULL && *pat != NUL)	/* look for (new) offset */
@@ -4527,7 +4535,7 @@
 #if defined(FEAT_FIND_ID) || defined(PROTO)
 /*
  * Find identifiers or defines in included files.
- * if p_ic && (compl_cont_status & CONT_SOL) then ptr must be in lowercase.
+ * If p_ic && (compl_cont_status & CONT_SOL) then ptr must be in lowercase.
  */
     void
 find_pattern_in_path(ptr, dir, len, whole, skip_comments,
@@ -4573,9 +4581,6 @@
     char_u	*already = NULL;
     char_u	*startp = NULL;
     char_u	*inc_opt = NULL;
-#ifdef RISCOS
-    int		previous_munging = __riscosify_control;
-#endif
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
     win_T	*curwin_save = NULL;
 #endif
@@ -4588,11 +4593,6 @@
     if (file_line == NULL)
 	return;
 
-#ifdef RISCOS
-    /* UnixLib knows best how to munge c file names - turn munging back on. */
-    int __riscosify_control = 0;
-#endif
-
     if (type != CHECK_PATH && type != FIND_DEFINE
 #ifdef FEAT_INS_EXPAND
 	/* when CONT_SOL is set compare "ptr" with the beginning of the line
@@ -5075,9 +5075,7 @@
 			if (win_split(0, 0) == FAIL)
 #endif
 			    break;
-#ifdef FEAT_SCROLLBIND
-			curwin->w_p_scb = FALSE;
-#endif
+			RESET_BINDING(curwin);
 		    }
 		    if (depth == -1)
 		    {
@@ -5222,11 +5220,6 @@
     vim_free(regmatch.regprog);
     vim_free(incl_regmatch.regprog);
     vim_free(def_regmatch.regprog);
-
-#ifdef RISCOS
-   /* Restore previous file munging state. */
-    __riscosify_control = previous_munging;
-#endif
 }
 
     static void
diff -Naur vim73.orig/src/spell.c vim73/src/spell.c
--- vim73.orig/src/spell.c	2010-08-01 13:43:01.000000000 +0000
+++ vim73/src/spell.c	2011-05-17 09:38:29.902767943 +0000
@@ -303,10 +303,6 @@
  *			    few bytes as possible, see offset2bytes())
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for lseek(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 #if defined(FEAT_SPELL) || defined(PROTO)
@@ -327,6 +323,16 @@
 typedef long idx_T;
 #endif
 
+#ifdef VMS
+# define SPL_FNAME_TMPL  "%s_%s.spl"
+# define SPL_FNAME_ADD   "_add."
+# define SPL_FNAME_ASCII "_ascii."
+#else
+# define SPL_FNAME_TMPL  "%s.%s.spl"
+# define SPL_FNAME_ADD   ".add."
+# define SPL_FNAME_ASCII ".ascii."
+#endif
+
 /* Flags used for a word.  Only the lowest byte can be used, the region byte
  * comes above it. */
 #define WF_REGION   0x01	/* region byte follows */
@@ -2471,14 +2477,24 @@
 	 * Find the first spell file for "lang" in 'runtimepath' and load it.
 	 */
 	vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,
-					"spell/%s.%s.spl", lang, spell_enc());
+#ifdef VMS
+					"spell/%s_%s.spl",
+#else
+					"spell/%s.%s.spl",
+#endif
+							   lang, spell_enc());
 	r = do_in_runtimepath(fname_enc, FALSE, spell_load_cb, &sl);
 
 	if (r == FAIL && *sl.sl_lang != NUL)
 	{
 	    /* Try loading the ASCII version. */
 	    vim_snprintf((char *)fname_enc, sizeof(fname_enc) - 5,
-						  "spell/%s.ascii.spl", lang);
+#ifdef VMS
+						  "spell/%s_ascii.spl",
+#else
+						  "spell/%s.ascii.spl",
+#endif
+									lang);
 	    r = do_in_runtimepath(fname_enc, FALSE, spell_load_cb, &sl);
 
 #ifdef FEAT_AUTOCMD
@@ -2496,7 +2512,12 @@
 
     if (r == FAIL)
     {
-	smsg((char_u *)_("Warning: Cannot find word list \"%s.%s.spl\" or \"%s.ascii.spl\""),
+	smsg((char_u *)
+#ifdef VMS
+	_("Warning: Cannot find word list \"%s_%s.spl\" or \"%s_ascii.spl\""),
+#else
+	_("Warning: Cannot find word list \"%s.%s.spl\" or \"%s.ascii.spl\""),
+#endif
 						     lang, spell_enc(), lang);
     }
     else if (sl.sl_slang != NULL)
@@ -2530,7 +2551,7 @@
 int_wordlist_spl(fname)
     char_u	    *fname;
 {
-    vim_snprintf((char *)fname, MAXPATHL, "%s.%s.spl",
+    vim_snprintf((char *)fname, MAXPATHL, SPL_FNAME_TMPL,
 						  int_wordlist, spell_enc());
 }
 
@@ -2785,8 +2806,8 @@
 	if (lp->sl_fname == NULL)
 	    goto endFAIL;
 
-	/* Check for .add.spl. */
-	lp->sl_add = strstr((char *)gettail(fname), ".add.") != NULL;
+	/* Check for .add.spl (_add.spl for VMS). */
+	lp->sl_add = strstr((char *)gettail(fname), SPL_FNAME_ADD) != NULL;
     }
     else
 	lp = old_lp;
@@ -3613,7 +3634,7 @@
 	}
 
 	/* Add all flags to "sl_compallflags". */
-	if (vim_strchr((char_u *)"+*[]/", c) == NULL
+	if (vim_strchr((char_u *)"?*+[]/", c) == NULL
 		&& !byte_in_str(slang->sl_compallflags, c))
 	{
 	    *ap++ = c;
@@ -3643,7 +3664,7 @@
 	/* Copy flag to "sl_comprules", unless we run into a wildcard. */
 	if (crp != NULL)
 	{
-	    if (c == '+' || c == '*')
+	    if (c == '?' || c == '+' || c == '*')
 	    {
 		vim_free(slang->sl_comprules);
 		slang->sl_comprules = NULL;
@@ -3661,8 +3682,8 @@
 	}
 	else		    /* normal char, "[abc]" and '*' are copied as-is */
 	{
-	    if (c == '+' || c == '~')
-		*pp++ = '\\';	    /* "a+" becomes "a\+" */
+	    if (c == '?' || c == '+' || c == '~')
+		*pp++ = '\\';	    /* "a?" becomes "a\?", "a+" becomes "a\+" */
 #ifdef FEAT_MBYTE
 	    if (enc_utf8)
 		pp += mb_char2bytes(c, pp);
@@ -4679,7 +4700,7 @@
     buf_T	*buf;
     char_u	fname[MAXPATHL];
 
-    /* Go through all buffers and handle 'spelllang'. */ //<VN>
+    /* Go through all buffers and handle 'spelllang'. <VN> */
     for (buf = firstbuf; buf != NULL; buf = buf->b_next)
 	ga_clear(&buf->b_s.b_langp);
 
@@ -4930,6 +4951,8 @@
 
     sblock_T	*si_blocks;	/* memory blocks used */
     long	si_blocks_cnt;	/* memory blocks allocated */
+    int		si_did_emsg;	/* TRUE when ran out of memory */
+
     long	si_compress_cnt;    /* words to add before lowering
 				       compression limit */
     wordnode_T	*si_first_free; /* List of nodes that have been freed during
@@ -4951,7 +4974,7 @@
     char_u	*si_info;	/* info text chars or NULL  */
     int		si_region_count; /* number of regions supported (1 when there
 				    are no regions) */
-    char_u	si_region_name[16]; /* region names; used only if
+    char_u	si_region_name[17]; /* region names; used only if
 				     * si_region_count > 1) */
 
     garray_T	si_rep;		/* list of fromto_T entries from REP lines */
@@ -5456,21 +5479,25 @@
 	    }
 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDRULE", 2))
 	    {
-		/* Concatenate this string to previously defined ones, using a
-		 * slash to separate them. */
-		l = (int)STRLEN(items[1]) + 1;
-		if (compflags != NULL)
-		    l += (int)STRLEN(compflags) + 1;
-		p = getroom(spin, l, FALSE);
-		if (p != NULL)
+		/* Don't use the first rule if it is a number. */
+		if (compflags != NULL || *skipdigits(items[1]) != NUL)
 		{
+		    /* Concatenate this string to previously defined ones,
+		     * using a slash to separate them. */
+		    l = (int)STRLEN(items[1]) + 1;
 		    if (compflags != NULL)
+			l += (int)STRLEN(compflags) + 1;
+		    p = getroom(spin, l, FALSE);
+		    if (p != NULL)
 		    {
-			STRCPY(p, compflags);
-			STRCAT(p, "/");
+			if (compflags != NULL)
+			{
+			    STRCPY(p, compflags);
+			    STRCAT(p, "/");
+			}
+			STRCAT(p, items[1]);
+			compflags = p;
 		    }
-		    STRCAT(p, items[1]);
-		    compflags = p;
 		}
 	    }
 	    else if (is_aff_rule(items, itemcnt, "COMPOUNDWORDMAX", 2)
@@ -6270,7 +6297,7 @@
 
     for (p = compflags; *p != NUL; )
     {
-	if (vim_strchr((char_u *)"/*+[]", *p) != NULL)
+	if (vim_strchr((char_u *)"/?*+[]", *p) != NULL)
 	    /* Copy non-flag characters directly. */
 	    *tp++ = *p++;
 	else
@@ -6299,7 +6326,7 @@
 		    {
 			check_renumber(spin);
 			id = spin->si_newcompID--;
-		    } while (vim_strchr((char_u *)"/+*[]\\-^", id) != NULL);
+		    } while (vim_strchr((char_u *)"/?*+[]\\-^", id) != NULL);
 		    ci->ci_newID = id;
 		    hash_add(&aff->af_comp, ci->ci_key);
 		}
@@ -6930,7 +6957,7 @@
 			    if (ae->ae_add == NULL)
 				*newword = NUL;
 			    else
-				STRCPY(newword, ae->ae_add);
+				vim_strncpy(newword, ae->ae_add, MAXWLEN - 1);
 			    p = word;
 			    if (ae->ae_chop != NULL)
 			    {
@@ -6951,7 +6978,7 @@
 			else
 			{
 			    /* suffix: chop/add at the end of the word */
-			    STRCPY(newword, word);
+			    vim_strncpy(newword, word, MAXWLEN - 1);
 			    if (ae->ae_chop != NULL)
 			    {
 				/* Remove chop string. */
@@ -7343,10 +7370,21 @@
 
     if (bl == NULL || bl->sb_used + len > SBLOCKSIZE)
     {
-	/* Allocate a block of memory. This is not freed until much later. */
-	bl = (sblock_T *)alloc_clear((unsigned)(sizeof(sblock_T) + SBLOCKSIZE));
+	if (len >= SBLOCKSIZE)
+	    bl = NULL;
+	else
+	    /* Allocate a block of memory. It is not freed until much later. */
+	    bl = (sblock_T *)alloc_clear(
+				   (unsigned)(sizeof(sblock_T) + SBLOCKSIZE));
 	if (bl == NULL)
+	{
+	    if (!spin->si_did_emsg)
+	    {
+		EMSG(_("E845: Insufficient memory, word list will be incomplete"));
+		spin->si_did_emsg = TRUE;
+	    }
 	    return NULL;
+	}
 	bl->sb_next = spin->si_blocks;
 	spin->si_blocks = bl;
 	bl->sb_used = 0;
@@ -7361,6 +7399,7 @@
 
 /*
  * Make a copy of a string into memory allocated with getroom().
+ * Returns NULL when out of memory.
  */
     static char_u *
 getroom_save(spin, s)
@@ -7395,6 +7434,7 @@
 
 /*
  * Allocate the root of a word tree.
+ * Returns NULL when out of memory.
  */
     static wordnode_T *
 wordtree_alloc(spin)
@@ -7679,6 +7719,7 @@
 /*
  * Get a wordnode_T, either from the list of previously freed nodes or
  * allocate a new one.
+ * Returns NULL when out of memory.
  */
     static wordnode_T *
 get_wordnode(spin)
@@ -7696,7 +7737,8 @@
 	--spin->si_free_count;
     }
 #ifdef SPELL_PRINTTREE
-    n->wn_nr = ++spin->si_wordnode_nr;
+    if (n != NULL)
+	n->wn_nr = ++spin->si_wordnode_nr;
 #endif
     return n;
 }
@@ -8548,7 +8590,7 @@
     spellinfo_T	*spin;
     char_u	*wfname;
 {
-    char_u	fname[MAXPATHL];
+    char_u	*fname = NULL;
     int		len;
     slang_T	*slang;
     int		free_slang = FALSE;
@@ -8612,13 +8654,17 @@
      * Write the .sug file.
      * Make the file name by changing ".spl" to ".sug".
      */
-    STRCPY(fname, wfname);
+    fname = alloc(MAXPATHL);
+    if (fname == NULL)
+	goto theend;
+    vim_strncpy(fname, wfname, MAXPATHL - 1);
     len = (int)STRLEN(fname);
     fname[len - 2] = 'u';
     fname[len - 1] = 'g';
     sug_write(spin, fname);
 
 theend:
+    vim_free(fname);
     if (free_slang)
 	slang_free(slang);
     free_blocks(spin->si_blocks);
@@ -9064,8 +9110,8 @@
     int		overwrite;	    /* overwrite existing output file */
     int		added_word;	    /* invoked through "zg" */
 {
-    char_u	fname[MAXPATHL];
-    char_u	wfname[MAXPATHL];
+    char_u	*fname = NULL;
+    char_u	*wfname;
     char_u	**innames;
     int		incount;
     afffile_T	*(afile[8]);
@@ -9093,6 +9139,10 @@
     innames = &fnames[1];
     incount = fcount - 1;
 
+    wfname = alloc(MAXPATHL);
+    if (wfname == NULL)
+	return;
+
     if (fcount >= 1)
     {
 	len = (int)STRLEN(fnames[0]);
@@ -9102,32 +9152,32 @@
 	     * "path/en.latin1.add.spl". */
 	    innames = &fnames[0];
 	    incount = 1;
-	    vim_snprintf((char *)wfname, sizeof(wfname), "%s.spl", fnames[0]);
+	    vim_snprintf((char *)wfname, MAXPATHL, "%s.spl", fnames[0]);
 	}
 	else if (fcount == 1)
 	{
 	    /* For ":mkspell path/vim" output file is "path/vim.latin1.spl". */
 	    innames = &fnames[0];
 	    incount = 1;
-	    vim_snprintf((char *)wfname, sizeof(wfname), "%s.%s.spl", fnames[0],
-			     spin.si_ascii ? (char_u *)"ascii" : spell_enc());
+	    vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,
+		  fnames[0], spin.si_ascii ? (char_u *)"ascii" : spell_enc());
 	}
 	else if (len > 4 && STRCMP(fnames[0] + len - 4, ".spl") == 0)
 	{
 	    /* Name ends in ".spl", use as the file name. */
-	    vim_strncpy(wfname, fnames[0], sizeof(wfname) - 1);
+	    vim_strncpy(wfname, fnames[0], MAXPATHL - 1);
 	}
 	else
 	    /* Name should be language, make the file name from it. */
-	    vim_snprintf((char *)wfname, sizeof(wfname), "%s.%s.spl", fnames[0],
-			     spin.si_ascii ? (char_u *)"ascii" : spell_enc());
+	    vim_snprintf((char *)wfname, MAXPATHL, SPL_FNAME_TMPL,
+		  fnames[0], spin.si_ascii ? (char_u *)"ascii" : spell_enc());
 
 	/* Check for .ascii.spl. */
-	if (strstr((char *)gettail(wfname), ".ascii.") != NULL)
+	if (strstr((char *)gettail(wfname), SPL_FNAME_ASCII) != NULL)
 	    spin.si_ascii = TRUE;
 
 	/* Check for .add.spl. */
-	if (strstr((char *)gettail(wfname), ".add.") != NULL)
+	if (strstr((char *)gettail(wfname), SPL_FNAME_ADD) != NULL)
 	    spin.si_add = TRUE;
     }
 
@@ -9144,14 +9194,18 @@
 	if (!overwrite && mch_stat((char *)wfname, &st) >= 0)
 	{
 	    EMSG(_(e_exists));
-	    return;
+	    goto theend;
 	}
 	if (mch_isdir(wfname))
 	{
 	    EMSG2(_(e_isadir2), wfname);
-	    return;
+	    goto theend;
 	}
 
+	fname = alloc(MAXPATHL);
+	if (fname == NULL)
+	    goto theend;
+
 	/*
 	 * Init the aff and dic pointers.
 	 * Get the region names if there are more than 2 arguments.
@@ -9167,7 +9221,7 @@
 						|| innames[i][len - 3] != '_')
 		{
 		    EMSG2(_("E755: Invalid region in %s"), innames[i]);
-		    return;
+		    goto theend;
 		}
 		spin.si_region_name[i * 2] = TOLOWER_ASC(innames[i][len - 2]);
 		spin.si_region_name[i * 2 + 1] =
@@ -9184,7 +9238,7 @@
 		|| spin.si_prefroot == NULL)
 	{
 	    free_blocks(spin.si_blocks);
-	    return;
+	    goto theend;
 	}
 
 	/* When not producing a .add.spl file clear the character table when
@@ -9205,7 +9259,7 @@
 	    spin.si_conv.vc_type = CONV_NONE;
 	    spin.si_region = 1 << i;
 
-	    vim_snprintf((char *)fname, sizeof(fname), "%s.aff", innames[i]);
+	    vim_snprintf((char *)fname, MAXPATHL, "%s.aff", innames[i]);
 	    if (mch_stat((char *)fname, &st) >= 0)
 	    {
 		/* Read the .aff file.  Will init "spin->si_conv" based on the
@@ -9216,7 +9270,7 @@
 		else
 		{
 		    /* Read the .dic file and store the words in the trees. */
-		    vim_snprintf((char *)fname, sizeof(fname), "%s.dic",
+		    vim_snprintf((char *)fname, MAXPATHL, "%s.dic",
 								  innames[i]);
 		    if (spell_read_dic(&spin, fname, afile[i]) == FAIL)
 			error = TRUE;
@@ -9298,6 +9352,10 @@
 	    spell_make_sugfile(&spin, wfname);
 
     }
+
+theend:
+    vim_free(fname);
+    vim_free(wfname);
 }
 
 /*
@@ -9350,7 +9408,7 @@
     buf_T	*buf = NULL;
     int		new_spf = FALSE;
     char_u	*fname;
-    char_u	fnamebuf[MAXPATHL];
+    char_u	*fnamebuf = NULL;
     char_u	line[MAXWLEN * 2];
     long	fpos, fpos_next = 0;
     int		i;
@@ -9380,6 +9438,9 @@
 	    EMSG2(_(e_notset), "spellfile");
 	    return;
 	}
+	fnamebuf = alloc(MAXPATHL);
+	if (fnamebuf == NULL)
+	    return;
 
 	for (spf = curwin->w_s->b_p_spf, i = 1; *spf != NUL; ++i)
 	{
@@ -9389,6 +9450,7 @@
 	    if (*spf == NUL)
 	    {
 		EMSGN(_("E765: 'spellfile' does not have %ld entries"), idx);
+		vim_free(fnamebuf);
 		return;
 	    }
 	}
@@ -9400,6 +9462,7 @@
 	if (buf != NULL && bufIsChanged(buf))
 	{
 	    EMSG(_(e_bufloaded));
+	    vim_free(fnamebuf);
 	    return;
 	}
 
@@ -9494,6 +9557,7 @@
 
 	redraw_all_later(SOME_VALID);
     }
+    vim_free(fnamebuf);
 }
 
 /*
@@ -9502,7 +9566,7 @@
     static void
 init_spellfile()
 {
-    char_u	buf[MAXPATHL];
+    char_u	*buf;
     int		l;
     char_u	*fname;
     char_u	*rtp;
@@ -9512,6 +9576,10 @@
 
     if (*curwin->w_s->b_p_spl != NUL && curwin->w_s->b_langp.ga_len > 0)
     {
+	buf = alloc(MAXPATHL);
+	if (buf == NULL)
+	    return;
+
 	/* Find the end of the language name.  Exclude the region.  If there
 	 * is a path separator remember the start of the tail. */
 	for (lend = curwin->w_s->b_p_spl; *lend != NUL
@@ -9530,7 +9598,8 @@
 	    if (aspath)
 		/* Use directory of an entry with path, e.g., for
 		 * "/dir/lg.utf-8.spl" use "/dir". */
-		vim_strncpy(buf, curbuf->b_s.b_p_spl, lstart - curbuf->b_s.b_p_spl - 1);
+		vim_strncpy(buf, curbuf->b_s.b_p_spl,
+					    lstart - curbuf->b_s.b_p_spl - 1);
 	    else
 		/* Copy the path from 'runtimepath' to buf[]. */
 		copy_option_part(&rtp, buf, MAXPATHL, ",");
@@ -9539,13 +9608,14 @@
 		/* Use the first language name from 'spelllang' and the
 		 * encoding used in the first loaded .spl file. */
 		if (aspath)
-		    vim_strncpy(buf, curbuf->b_s.b_p_spl, lend - curbuf->b_s.b_p_spl);
+		    vim_strncpy(buf, curbuf->b_s.b_p_spl,
+						  lend - curbuf->b_s.b_p_spl);
 		else
 		{
 		    /* Create the "spell" directory if it doesn't exist yet. */
 		    l = (int)STRLEN(buf);
 		    vim_snprintf((char *)buf + l, MAXPATHL - l, "/spell");
-		    if (!filewritable(buf) != 2)
+		    if (filewritable(buf) != 2)
 			vim_mkdir(buf, 0755);
 
 		    l = (int)STRLEN(buf);
@@ -9553,7 +9623,8 @@
 				 "/%.*s", (int)(lend - lstart), lstart);
 		}
 		l = (int)STRLEN(buf);
-		fname = LANGP_ENTRY(curwin->w_s->b_langp, 0)->lp_slang->sl_fname;
+		fname = LANGP_ENTRY(curwin->w_s->b_langp, 0)
+							 ->lp_slang->sl_fname;
 		vim_snprintf((char *)buf + l, MAXPATHL - l, ".%s.add",
 			fname != NULL
 			  && strstr((char *)gettail(fname), ".ascii.") != NULL
@@ -9563,6 +9634,8 @@
 	    }
 	    aspath = FALSE;
 	}
+
+	vim_free(buf);
     }
 }
 
@@ -9837,10 +9910,7 @@
 	{
 	    /* be quick for ASCII */
 	    if (wp->w_s->b_spell_ismw[*p])
-	    {
 		s = p + 1;		/* skip a mid-word character */
-		l = MB_BYTE2LEN(*s);
-	    }
 	}
 	else
 	{
@@ -9848,10 +9918,7 @@
 	    if (c < 256 ? wp->w_s->b_spell_ismw[c]
 		    : (wp->w_s->b_spell_ismw_mb != NULL
 			   && vim_strchr(wp->w_s->b_spell_ismw_mb, c) != NULL))
-	    {
 		s = p + l;
-		l = MB_BYTE2LEN(*s);
-	    }
 	}
 
 	c = mb_ptr2char(s);
@@ -10223,7 +10290,7 @@
 
 	    /* The suggested word may replace only part of the bad word, add
 	     * the not replaced part. */
-	    STRCPY(wcopy, stp->st_word);
+	    vim_strncpy(wcopy, stp->st_word, MAXWLEN);
 	    if (sug.su_badlen > stp->st_orglen)
 		vim_strncpy(wcopy + stp->st_wordlen,
 					       sug.su_badptr + stp->st_orglen,
@@ -13124,7 +13191,7 @@
 	pbad = badsound2;
     }
 
-    if (lendiff > 0)
+    if (lendiff > 0 && stp->st_wordlen + lendiff < MAXWLEN)
     {
 	/* Add part of the bad word to the good word, so that we soundfold
 	 * what replaces the bad word. */
@@ -13811,11 +13878,8 @@
 		    su->su_sfmaxscore = cleanup_suggestions(gap,
 				      su->su_sfmaxscore, SUG_CLEAN_COUNT(su));
 		else
-		{
-		    i = su->su_maxscore;
 		    su->su_maxscore = cleanup_suggestions(gap,
 					su->su_maxscore, SUG_CLEAN_COUNT(su));
-		}
 	    }
 	}
     }
@@ -13840,7 +13904,7 @@
     for (i = gap->ga_len - 1; i >= 0; --i)
     {
 	/* Need to append what follows to check for "the the". */
-	STRCPY(longword, stp[i].st_word);
+	vim_strncpy(longword, stp[i].st_word, MAXWLEN);
 	len = stp[i].st_wordlen;
 	vim_strncpy(longword + len, su->su_badptr + stp[i].st_orglen,
 							       MAXWLEN - len);
@@ -14186,7 +14250,7 @@
 	*t = NUL;
     }
     else
-	STRCPY(word, s);
+	vim_strncpy(word, s, MAXWLEN - 1);
 
     smp = (salitem_T *)slang->sl_sal.ga_data;
 
diff -Naur vim73.orig/src/structs.h vim73/src/structs.h
--- vim73.orig/src/structs.h	2010-08-07 14:59:27.000000000 +0000
+++ vim73/src/structs.h	2011-05-17 09:39:31.623917761 +0000
@@ -378,6 +378,35 @@
 typedef long		    blocknr_T;
 
 /*
+ * mf_hashtab_T is a chained hashtable with blocknr_T key and arbitrary
+ * structures as items.  This is an intrusive data structure: we require
+ * that items begin with mf_hashitem_T which contains the key and linked
+ * list pointers.  List of items in each bucket is doubly-linked.
+ */
+
+typedef struct mf_hashitem_S mf_hashitem_T;
+
+struct mf_hashitem_S
+{
+    mf_hashitem_T   *mhi_next;
+    mf_hashitem_T   *mhi_prev;
+    blocknr_T	    mhi_key;
+};
+
+#define MHT_INIT_SIZE   64
+
+typedef struct mf_hashtab_S
+{
+    long_u	    mht_mask;	    /* mask used for hash value (nr of items
+				     * in array is "mht_mask" + 1) */
+    long_u	    mht_count;	    /* nr of items inserted into hashtable */
+    mf_hashitem_T   **mht_buckets;  /* points to mht_small_buckets or
+				     *dynamically allocated array */
+    mf_hashitem_T   *mht_small_buckets[MHT_INIT_SIZE];   /* initial buckets */
+    char	    mht_fixed;	    /* non-zero value forbids growth */
+} mf_hashtab_T;
+
+/*
  * for each (previously) used block in the memfile there is one block header.
  *
  * The block may be linked in the used list OR in the free list.
@@ -394,11 +423,11 @@
 
 struct block_hdr
 {
+    mf_hashitem_T bh_hashitem;      /* header for hash table and key */
+#define bh_bnum bh_hashitem.mhi_key /* block number, part of bh_hashitem */
+
     bhdr_T	*bh_next;	    /* next block_hdr in free or used list */
     bhdr_T	*bh_prev;	    /* previous block_hdr in used list */
-    bhdr_T	*bh_hash_next;	    /* next block_hdr in hash list */
-    bhdr_T	*bh_hash_prev;	    /* previous block_hdr in hash list */
-    blocknr_T	bh_bnum;	    /* block number */
     char_u	*bh_data;	    /* pointer to memory (for used block) */
     int		bh_page_count;	    /* number of pages in this block */
 
@@ -417,9 +446,9 @@
 
 struct nr_trans
 {
-    NR_TRANS	*nt_next;		/* next nr_trans in hash list */
-    NR_TRANS	*nt_prev;		/* previous nr_trans in hash list */
-    blocknr_T	nt_old_bnum;		/* old, negative, number */
+    mf_hashitem_T nt_hashitem;		/* header for hash table and key */
+#define nt_old_bnum nt_hashitem.mhi_key	/* old, negative, number */
+
     blocknr_T	nt_new_bnum;		/* new, positive, number */
 };
 
@@ -499,12 +528,6 @@
 
 typedef struct file_buffer buf_T;  /* forward declaration */
 
-/*
- * Simplistic hashing scheme to quickly locate the blocks in the used list.
- * 64 blocks are found directly (64 * 4K = 256K, most files are smaller).
- */
-#define MEMHASHSIZE	64
-#define MEMHASH(nr)	((nr) & (MEMHASHSIZE - 1))
 #define MF_SEED_LEN	8
 
 struct memfile
@@ -517,8 +540,8 @@
     bhdr_T	*mf_used_last;		/* lru block_hdr in used list */
     unsigned	mf_used_count;		/* number of pages in used list */
     unsigned	mf_used_count_max;	/* maximum number of pages in memory */
-    bhdr_T	*mf_hash[MEMHASHSIZE];	/* array of hash lists */
-    NR_TRANS	*mf_trans[MEMHASHSIZE];	/* array of trans lists */
+    mf_hashtab_T mf_hash;		/* hash lists */
+    mf_hashtab_T mf_trans;		/* trans lists */
     blocknr_T	mf_blocknr_max;		/* highest positive block number + 1*/
     blocknr_T	mf_blocknr_min;		/* lowest negative block number - 1 */
     blocknr_T	mf_neg_count;		/* number of negative blocks numbers */
@@ -979,9 +1002,10 @@
 struct mapblock
 {
     mapblock_T	*m_next;	/* next mapblock in list */
-    char_u	*m_keys;	/* mapped from */
+    char_u	*m_keys;	/* mapped from, lhs */
     int		m_keylen;	/* strlen(m_keys) */
-    char_u	*m_str;		/* mapped to */
+    char_u	*m_str;		/* mapped to, rhs */
+    char_u	*m_orig_str;	/* rhs as entered by the user */
     int		m_mode;		/* valid mode */
     int		m_noremap;	/* if non-zero no re-mapping for m_str */
     char	m_silent;	/* <silent> used, don't echo commands */
@@ -1563,6 +1587,9 @@
 
     /* end of buffer options */
 
+    linenr_T	b_no_eol_lnum;	/* non-zero lnum when last line of next binary
+				 * write should not have an end-of-line */
+
     int		b_start_eol;	/* last line had eol when it was read */
     int		b_start_ffc;	/* first char of 'ff' when edit started */
 #ifdef FEAT_MBYTE
@@ -2339,11 +2366,6 @@
     MenuHandle	menu_handle;
     MenuHandle	submenu_handle;
 #endif
-#ifdef RISCOS
-    int		*id;		    /* Not used, but gui.c needs it */
-    int		greyed_out;	    /* Flag */
-    int		hidden;
-#endif
 #ifdef FEAT_GUI_PHOTON
     PtWidget_t	*id;
     PtWidget_t	*submenu_id;
diff -Naur vim73.orig/src/syntax.c vim73/src/syntax.c
--- vim73.orig/src/syntax.c	2010-08-08 13:17:03.000000000 +0000
+++ vim73/src/syntax.c	2011-05-17 09:38:27.335052926 +0000
@@ -68,6 +68,8 @@
 
 #define HL_TABLE() ((struct hl_group *)((highlight_ga.ga_data)))
 
+#define MAX_HL_ID       20000	/* maximum value for a highlight ID. */
+
 #ifdef FEAT_CMDL_COMPL
 /* Flags to indicate an additional string for highlight name completion. */
 static int include_none = 0;	/* when 1 include "None" */
@@ -219,16 +221,19 @@
 
 /*
  * Syntax group IDs have different types:
- *     0 -  9999  normal syntax groups
- * 10000 - 14999  ALLBUT indicator (current_syn_inc_tag added)
- * 15000 - 19999  TOP indicator (current_syn_inc_tag added)
- * 20000 - 24999  CONTAINED indicator (current_syn_inc_tag added)
- * >= 25000	  cluster IDs (subtract SYNID_CLUSTER for the cluster ID)
- */
-#define SYNID_ALLBUT	10000	    /* syntax group ID for contains=ALLBUT */
-#define SYNID_TOP	15000	    /* syntax group ID for contains=TOP */
-#define SYNID_CONTAINED	20000	    /* syntax group ID for contains=CONTAINED */
-#define SYNID_CLUSTER	25000	    /* first syntax group ID for clusters */
+ *     0 - 19999  normal syntax groups
+ * 20000 - 20999  ALLBUT indicator (current_syn_inc_tag added)
+ * 21000 - 21999  TOP indicator (current_syn_inc_tag added)
+ * 22000 - 22999  CONTAINED indicator (current_syn_inc_tag added)
+ * 23000 - 32767  cluster IDs (subtract SYNID_CLUSTER for the cluster ID)
+ */
+#define SYNID_ALLBUT	MAX_HL_ID   /* syntax group ID for contains=ALLBUT */
+#define SYNID_TOP	21000	    /* syntax group ID for contains=TOP */
+#define SYNID_CONTAINED	22000	    /* syntax group ID for contains=CONTAINED */
+#define SYNID_CLUSTER	23000	    /* first syntax group ID for clusters */
+
+#define MAX_SYN_INC_TAG	999	    /* maximum before the above overflow */
+#define MAX_CLUSTER_ID  (32767 - SYNID_CLUSTER)
 
 /*
  * Annoying Hack(TM):  ":syn include" needs this pointer to pass to
@@ -3442,6 +3447,9 @@
     /* free the stored states */
     syn_stack_free_all(block);
     invalidate_current_state();
+
+    /* Reset the counter for ":syn include" */
+    running_syn_inc_tag = 0;
 }
 
 /*
@@ -4537,6 +4545,13 @@
 		;
 #endif
 	    }
+#ifdef FEAT_CONCEAL
+	    if (!vim_isprintc_strict(*conceal_char))
+	    {
+		EMSG(_("E844: invalid cchar value"));
+		return NULL;
+	    }
+#endif
 	    arg = skipwhite(arg + 7);
 	}
 	else
@@ -4654,6 +4669,8 @@
 	    return;
 	}
 	sgl_id = syn_check_cluster(arg, (int)(group_name_end - arg));
+	if (sgl_id == 0)
+	    return;
 	/* separate_nextcmd() and expand_filename() depend on this */
 	eap->arg = rest;
     }
@@ -4682,6 +4699,11 @@
      * Save and restore the existing top-level grouplist id and ":syn
      * include" tag around the actual inclusion.
      */
+    if (running_syn_inc_tag >= MAX_SYN_INC_TAG)
+    {
+	EMSG((char_u *)_("E847: Too many syntax includes"));
+	return;
+    }
     prev_syn_inc_tag = current_syn_inc_tag;
     current_syn_inc_tag = ++running_syn_inc_tag;
     prev_toplvl_grp = curwin->w_s->b_syn_topgrp;
@@ -4705,7 +4727,7 @@
     char_u	*group_name_end;
     int		syn_id;
     char_u	*rest;
-    char_u	*keyword_copy;
+    char_u	*keyword_copy = NULL;
     char_u	*p;
     char_u	*kw;
     syn_opt_arg_T syn_opt_arg;
@@ -4717,9 +4739,9 @@
     if (rest != NULL)
     {
 	syn_id = syn_check_group(arg, (int)(group_name_end - arg));
-
-	/* allocate a buffer, for removing the backslashes in the keyword */
-	keyword_copy = alloc((unsigned)STRLEN(rest) + 1);
+	if (syn_id != 0)
+	    /* allocate a buffer, for removing backslashes in the keyword */
+	    keyword_copy = alloc((unsigned)STRLEN(rest) + 1);
 	if (keyword_copy != NULL)
 	{
 	    syn_opt_arg.flags = 0;
@@ -5126,7 +5148,8 @@
 			    (item == ITEM_SKIP) ? SPTYPE_SKIP : SPTYPE_END;
 		    SYN_ITEMS(curwin->w_s)[idx].sp_flags |= syn_opt_arg.flags;
 		    SYN_ITEMS(curwin->w_s)[idx].sp_syn.id = syn_id;
-		    SYN_ITEMS(curwin->w_s)[idx].sp_syn.inc_tag = current_syn_inc_tag;
+		    SYN_ITEMS(curwin->w_s)[idx].sp_syn.inc_tag =
+							  current_syn_inc_tag;
 		    SYN_ITEMS(curwin->w_s)[idx].sp_syn_match_id =
 							ppp->pp_matchgroup_id;
 #ifdef FEAT_CONCEAL
@@ -5419,6 +5442,14 @@
 	curwin->w_s->b_syn_clusters.ga_growsize = 10;
     }
 
+    len = curwin->w_s->b_syn_clusters.ga_len;
+    if (len >= MAX_CLUSTER_ID)
+    {
+	EMSG((char_u *)_("E848: Too many syntax clusters"));
+	vim_free(name);
+	return 0;
+    }
+
     /*
      * Make room for at least one other cluster entry.
      */
@@ -5427,7 +5458,6 @@
 	vim_free(name);
 	return 0;
     }
-    len = curwin->w_s->b_syn_clusters.ga_len;
 
     vim_memset(&(SYN_CLSTR(curwin->w_s)[len]), 0, sizeof(syn_cluster_T));
     SYN_CLSTR(curwin->w_s)[len].scl_name = name;
@@ -5469,8 +5499,10 @@
 
     if (rest != NULL)
     {
-	scl_id = syn_check_cluster(arg, (int)(group_name_end - arg))
-							      - SYNID_CLUSTER;
+	scl_id = syn_check_cluster(arg, (int)(group_name_end - arg));
+	if (scl_id == 0)
+	    return;
+	scl_id -= SYNID_CLUSTER;
 
 	for (;;)
 	{
@@ -5509,7 +5541,7 @@
 	if (got_clstr)
 	{
 	    redraw_curbuf_later(SOME_VALID);
-	    syn_stack_free_all(curwin->w_s);	/* Need to recompute all syntax. */
+	    syn_stack_free_all(curwin->w_s);	/* Need to recompute all. */
 	}
     }
 
@@ -6431,7 +6463,6 @@
 
 #endif /* FEAT_SYN_HL */
 
-
 /**************************************
  *  Highlighting stuff		      *
  **************************************/
@@ -7600,10 +7631,10 @@
 		/*
 		 * Copy characters from arg[] to buf[], translating <> codes.
 		 */
-		for (p = arg, off = 0; off < 100 && *p; )
+		for (p = arg, off = 0; off < 100 - 6 && *p; )
 		{
 		    len = trans_special(&p, buf + off, FALSE);
-		    if (len)		    /* recognized special char */
+		    if (len > 0)	    /* recognized special char */
 			off += len;
 		    else		    /* copy as normal char */
 			buf[off++] = *p++;
@@ -8545,8 +8576,8 @@
 		if (iarg & hl_attr_table[i])
 		{
 		    if (buf[0] != NUL)
-			STRCAT(buf, ",");
-		    STRCAT(buf, hl_name_table[i]);
+			vim_strcat(buf, (char_u *)",", 100);
+		    vim_strcat(buf, (char_u *)hl_name_table[i], 100);
 		    iarg &= ~hl_attr_table[i];	    /* don't want "inverse" */
 		}
 	    }
@@ -8965,6 +8996,13 @@
 	highlight_ga.ga_growsize = 10;
     }
 
+    if (highlight_ga.ga_len >= MAX_HL_ID)
+    {
+	EMSG(_("E849: Too many highlight and syntax groups"));
+	vim_free(name);
+	return 0;
+    }
+
     /*
      * Make room for at least one other syntax_highlight entry.
      */
diff -Naur vim73.orig/src/tag.c vim73/src/tag.c
--- vim73.orig/src/tag.c	2010-08-10 07:25:22.000000000 +0000
+++ vim73/src/tag.c	2011-05-17 09:38:29.902767943 +0000
@@ -11,10 +11,6 @@
  * Code to handle tags and the tag stack
  */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for lseek(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 /*
@@ -208,7 +204,7 @@
     else
     {
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-	if (g_do_tagpreview)
+	if (g_do_tagpreview != 0)
 	    use_tagstack = FALSE;
 	else
 #endif
@@ -226,7 +222,7 @@
 		    ))
 	{
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-	    if (g_do_tagpreview)
+	    if (g_do_tagpreview != 0)
 	    {
 		if (ptag_entry.tagname != NULL
 			&& STRCMP(ptag_entry.tagname, tag) == 0)
@@ -282,7 +278,7 @@
 	{
 	    if (
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-		    g_do_tagpreview ? ptag_entry.tagname == NULL :
+		    g_do_tagpreview != 0 ? ptag_entry.tagname == NULL :
 #endif
 		    tagstacklen == 0)
 	    {
@@ -365,7 +361,7 @@
 	       )
 	    {
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-		if (g_do_tagpreview)
+		if (g_do_tagpreview != 0)
 		{
 		    cur_match = ptag_entry.cur_match;
 		    cur_fnum = ptag_entry.cur_fnum;
@@ -403,7 +399,7 @@
 		prevtagstackidx = tagstackidx;
 
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-		if (g_do_tagpreview)
+		if (g_do_tagpreview != 0)
 		{
 		    cur_match = ptag_entry.cur_match;
 		    cur_fnum = ptag_entry.cur_fnum;
@@ -441,7 +437,7 @@
 	}
 
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-	if (g_do_tagpreview)
+	if (g_do_tagpreview != 0)
 	{
 	    if (type != DT_SELECT && type != DT_JUMP)
 	    {
@@ -496,7 +492,7 @@
 	if (use_tagstack)
 	    name = tagstack[tagstackidx].tagname;
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-	else if (g_do_tagpreview)
+	else if (g_do_tagpreview != 0)
 	    name = ptag_entry.tagname;
 #endif
 	else
@@ -624,7 +620,7 @@
 		    parse_match(matches[i], &tagp);
 		    if (!new_tag && (
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-				(g_do_tagpreview
+				(g_do_tagpreview != 0
 				 && i == ptag_entry.cur_match) ||
 #endif
 				(use_tagstack
@@ -779,17 +775,25 @@
 	    {
 		list_T	*list;
 		char_u	tag_name[128 + 1];
-		char_u	fname[MAXPATHL + 1];
-		char_u	cmd[CMDBUFFSIZE + 1];
+		char_u	*fname;
+		char_u	*cmd;
 
 		/*
 		 * Add the matching tags to the location list for the current
 		 * window.
 		 */
 
+		fname = alloc(MAXPATHL + 1);
+		cmd = alloc(CMDBUFFSIZE + 1);
 		list = list_alloc();
-		if (list == NULL)
+		if (list == NULL || fname == NULL || cmd == NULL)
+		{
+		    vim_free(cmd);
+		    vim_free(fname);
+		    if (list != NULL)
+			list_free(list, TRUE);
 		    goto end_do_tag;
+		}
 
 		for (i = 0; i < num_matches; ++i)
 		{
@@ -810,7 +814,7 @@
 		    p = tag_full_fname(&tagp);
 		    if (p == NULL)
 			continue;
-		    STRCPY(fname, p);
+		    vim_strncpy(fname, p, MAXPATHL);
 		    vim_free(p);
 
 		    /*
@@ -915,6 +919,8 @@
 		set_errorlist(curwin, list, ' ', IObuff);
 
 		list_free(list, TRUE);
+		vim_free(fname);
+		vim_free(cmd);
 
 		cur_match = 0;		/* Jump to the first tag */
 	    }
@@ -966,7 +972,7 @@
 		++tagstackidx;
 	    }
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-	    else if (g_do_tagpreview)
+	    else if (g_do_tagpreview != 0)
 	    {
 		ptag_entry.cur_match = cur_match;
 		ptag_entry.cur_fnum = cur_fnum;
@@ -3114,7 +3120,7 @@
 #endif
 
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-    if (g_do_tagpreview)
+    if (g_do_tagpreview != 0)
     {
 	postponed_split = 0;	/* don't split again below */
 	curwin_save = curwin;	/* Save current window */
@@ -3143,9 +3149,7 @@
     {
 	win_split(postponed_split > 0 ? postponed_split : 0,
 						       postponed_split_flags);
-# ifdef FEAT_SCROLLBIND
-	curwin->w_p_scb = FALSE;
-# endif
+	RESET_BINDING(curwin);
     }
 #endif
 
@@ -3154,7 +3158,7 @@
 	/* A :ta from a help file will keep the b_help flag set.  For ":ptag"
 	 * we need to use the flag from the window where we came from. */
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-	if (g_do_tagpreview)
+	if (g_do_tagpreview != 0)
 	    keep_help_flag = curwin_save->w_buffer->b_help;
 	else
 #endif
@@ -3328,7 +3332,8 @@
 	}
 
 #if defined(FEAT_WINDOWS) && defined(FEAT_QUICKFIX)
-	if (g_do_tagpreview && curwin != curwin_save && win_valid(curwin_save))
+	if (g_do_tagpreview != 0
+			   && curwin != curwin_save && win_valid(curwin_save))
 	{
 	    /* Return cursor to where we were */
 	    validate_cursor();
@@ -3782,8 +3787,9 @@
     char_u  *start;		/* start of the value */
     char_u  *end;		/* after the value; can be NULL */
 {
-    char_u	buf[MAXPATHL];
+    char_u	*buf;
     int		len = 0;
+    int		retval;
 
     /* check that the field name doesn't exist yet */
     if (dict_find(dict, (char_u *)field_name, -1) != NULL)
@@ -3796,6 +3802,9 @@
 	}
 	return FAIL;
     }
+    buf = alloc(MAXPATHL);
+    if (buf == NULL)
+	return FAIL;
     if (start != NULL)
     {
 	if (end == NULL)
@@ -3805,12 +3814,14 @@
 		--end;
 	}
 	len = (int)(end - start);
-	if (len > (int)sizeof(buf) - 1)
-	    len = sizeof(buf) - 1;
+	if (len > MAXPATHL - 1)
+	    len = MAXPATHL - 1;
 	vim_strncpy(buf, start, len);
     }
     buf[len] = NUL;
-    return dict_add_nr_str(dict, field_name, 0L, buf);
+    retval = dict_add_nr_str(dict, field_name, 0L, buf);
+    vim_free(buf);
+    return retval;
 }
 
 /*
diff -Naur vim73.orig/src/term.c vim73/src/term.c
--- vim73.orig/src/term.c	2010-07-25 13:30:31.000000000 +0000
+++ vim73/src/term.c	2011-05-17 09:39:31.623917761 +0000
@@ -52,7 +52,7 @@
 
 /*
  * Here are the builtin termcap entries.  They are not stored as complete
- * Tcarr structures, as such a structure is too big.
+ * structures with all entries, as such a structure is too big.
  *
  * The entries are compact, therefore they normally are included even when
  * HAVE_TGETENT is defined. When HAVE_TGETENT is defined, the builtin entries
@@ -199,71 +199,6 @@
 #endif
 
 #ifndef NO_BUILTIN_TCAPS
-# if defined(RISCOS) || defined(ALL_BUILTIN_TCAPS)
-/*
- * Default for the Acorn.
- */
-    {(int)KS_NAME,	"riscos"},
-    {(int)KS_CL,	"\014"},		/* Cls and Home Cursor */
-    {(int)KS_CM,	"\001%d\001%d\002"},	/* Position cursor */
-
-    {(int)KS_CCO,	"16"},			/* Allow 16 colors */
-
-    {(int)KS_CAF,	"\001%d\021"},		/* Set foreground colour */
-    {(int)KS_CAB,	"\001%d\022"},		/* Set background colour */
-
-
-    {(int)KS_ME,	"\004"},		/* Normal mode */
-    {(int)KS_MR,	"\005"},		/* Reverse */
-
-    {(int)KS_VI,	"\016"},		/* Cursor invisible */
-    {(int)KS_VE,	"\017"},		/* Cursor visible */
-    {(int)KS_VS,	"\020"},		/* Cursor very visible */
-
-    {(int)KS_CS,	"\001%d\001%d\003"},	/* Set scroll region */
-    {(int)KS_SR,	"\023"},		/* Scroll text down */
-    {K_UP,		"\217"},
-    {K_DOWN,		"\216"},
-    {K_LEFT,		"\214"},
-    {K_RIGHT,		"\215"},
-    {K_S_UP,		"\237"},
-    {K_S_DOWN,		"\236"},
-    {K_S_LEFT,		"\234"},
-    {K_S_RIGHT,		"\235"},
-
-    {K_F1,		"\201"},
-    {K_F2,		"\202"},
-    {K_F3,		"\203"},
-    {K_F4,		"\204"},
-    {K_F5,		"\205"},
-    {K_F6,		"\206"},
-    {K_F7,		"\207"},
-    {K_F8,		"\210"},
-    {K_F9,		"\211"},
-    {K_F10,		"\312"},
-    {K_F11,		"\313"},
-    {K_F12,		"\314"},
-    {K_S_F1,		"\221"},
-    {K_S_F2,		"\222"},
-    {K_S_F3,		"\223"},
-    {K_S_F4,		"\224"},
-    {K_S_F5,		"\225"},
-    {K_S_F6,		"\226"},
-    {K_S_F7,		"\227"},
-    {K_S_F8,		"\230"},
-    {K_S_F9,		"\231"},
-    {K_S_F10,		"\332"},
-    {K_S_F11,		"\333"},
-    {K_S_F12,		"\334"},
-    {K_BS,		"\010"},
-    {K_INS,		"\315"},
-    {K_DEL,		"\177"},
-    {K_HOME,		"\036"},
-    {K_END,		"\213"},
-    {K_PAGEUP,		"\237"},
-    {K_PAGEDOWN,	"\236"},
-# endif	/* Acorn terminal */
-
 
 # if defined(AMIGA) || defined(ALL_BUILTIN_TCAPS)
 /*
@@ -1399,10 +1334,6 @@
 /*
  * DEFAULT_TERM is used, when no terminal is specified with -T option or $TERM.
  */
-#ifdef RISCOS
-# define DEFAULT_TERM	(char_u *)"riscos"
-#endif
-
 #ifdef AMIGA
 # define DEFAULT_TERM	(char_u *)"amiga"
 #endif
@@ -3053,10 +2984,13 @@
     int		old_Rows = Rows;
     int		old_Columns = Columns;
 
-    (void)ui_get_shellsize();
-    check_shellsize();
-    if (old_Rows != Rows || old_Columns != Columns)
-	shell_resized();
+    if (!exiting)
+    {
+	(void)ui_get_shellsize();
+	check_shellsize();
+	if (old_Rows != Rows || old_Columns != Columns)
+	    shell_resized();
+    }
 }
 
 /*
@@ -3828,6 +3762,7 @@
  * Check from typebuf.tb_buf[typebuf.tb_off] to typebuf.tb_buf[typebuf.tb_off
  * + max_offset].
  * Return 0 for no match, -1 for partial match, > 0 for full match.
+ * Return KEYLEN_REMOVED when a key code was deleted.
  * With a match, the match is removed, the replacement code is inserted in
  * typebuf.tb_buf[] and the number of characters in typebuf.tb_buf[] is
  * returned.
@@ -3845,6 +3780,7 @@
     int		slen = 0;	/* init for GCC */
     int		modslen;
     int		len;
+    int		retval = 0;
     int		offset;
     char_u	key_name[2];
     int		modifiers;
@@ -4940,6 +4876,13 @@
 #endif
 		string[new_slen++] = key_name[1];
 	}
+	else if (new_slen == 0 && key_name[0] == KS_EXTRA
+						  && key_name[1] == KE_IGNORE)
+	{
+	    /* Do not put K_IGNORE into the buffer, do return KEYLEN_REMOVED
+	     * to indicate what happened. */
+	    retval = KEYLEN_REMOVED;
+	}
 	else
 	{
 	    string[new_slen++] = K_SPECIAL;
@@ -4976,7 +4919,7 @@
 						   (size_t)(buflen - offset));
 	    mch_memmove(buf + offset, string, (size_t)new_slen);
 	}
-	return (len + extra + offset);
+	return retval == 0 ? (len + extra + offset) : retval;
     }
 
     return 0;			    /* no match found */
diff -Naur vim73.orig/src/termlib.c vim73/src/termlib.c
--- vim73.orig/src/termlib.c	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/termlib.c	2011-05-17 09:39:31.627917317 +0000
@@ -13,7 +13,7 @@
 #include "vim.h"
 #include "termlib.pro"
 
-#if !defined(AMIGA) && !defined(VMS) && !defined(MACOS) && !defined(RISCOS)
+#if !defined(AMIGA) && !defined(VMS) && !defined(MACOS)
 # include <sgtty.h>
 #endif
 
diff -Naur vim73.orig/src/testdir/Make_amiga.mak vim73/src/testdir/Make_amiga.mak
--- vim73.orig/src/testdir/Make_amiga.mak	2010-08-04 14:34:34.000000000 +0000
+++ vim73/src/testdir/Make_amiga.mak	2011-05-17 09:37:47.947424441 +0000
@@ -27,7 +27,8 @@
 		test56.out test57.out test58.out test59.out test60.out \
 		test61.out test62.out test63.out test64.out test65.out \
 		test66.out test67.out test68.out test69.out test70.out \
-		test71.out test72.out test73.out
+		test71.out test72.out test73.out test74.out test75.out \
+		test76.out test77.out
 
 .SUFFIXES: .in .out
 
@@ -120,3 +121,7 @@
 test71.out: test71.in
 test72.out: test72.in
 test73.out: test73.in
+test74.out: test74.in
+test75.out: test75.in
+test76.out: test76.in
+test77.out: test77.in
diff -Naur vim73.orig/src/testdir/Make_dos.mak vim73/src/testdir/Make_dos.mak
--- vim73.orig/src/testdir/Make_dos.mak	2010-08-13 16:27:19.000000000 +0000
+++ vim73/src/testdir/Make_dos.mak	2011-05-17 09:37:47.947424441 +0000
@@ -27,7 +27,8 @@
 		test30.out test31.out test32.out test33.out test34.out \
 		test37.out test38.out test39.out test40.out test41.out \
 		test42.out test52.out test65.out test66.out test67.out \
-		test68.out test69.out test71.out test72.out test73.out
+		test68.out test69.out test71.out test72.out test73.out \
+		test74.out test75.out test76.out test77.out
 
 SCRIPTS32 =	test50.out test70.out
 
diff -Naur vim73.orig/src/testdir/Make_ming.mak vim73/src/testdir/Make_ming.mak
--- vim73.orig/src/testdir/Make_ming.mak	2010-08-04 14:34:47.000000000 +0000
+++ vim73/src/testdir/Make_ming.mak	2011-05-17 09:37:47.947424441 +0000
@@ -47,7 +47,8 @@
 		test30.out test31.out test32.out test33.out test34.out \
 		test37.out test38.out test39.out test40.out test41.out \
 		test42.out test52.out test65.out test66.out test67.out \
-		test68.out test69.out test71.out test72.out test72.out
+		test68.out test69.out test71.out test72.out test73.out \
+		test74.out test75.out test76.out test77.out
 
 SCRIPTS32 =	test50.out test70.out
 
diff -Naur vim73.orig/src/testdir/Make_os2.mak vim73/src/testdir/Make_os2.mak
--- vim73.orig/src/testdir/Make_os2.mak	2010-08-04 14:34:55.000000000 +0000
+++ vim73/src/testdir/Make_os2.mak	2011-05-17 09:37:47.947424441 +0000
@@ -27,7 +27,8 @@
 		test56.out test57.out test58.out test59.out test60.out \
 		test61.out test62.out test63.out test64.out test65.out \
 		test66.out test67.out test68.out test69.out test70.out \
-		test71.out test72.out test73.out
+		test71.out test72.out test73.out test74.out test75.out \
+		test76.out test77.out
 
 .SUFFIXES: .in .out
 
diff -Naur vim73.orig/src/testdir/Make_vms.mms vim73/src/testdir/Make_vms.mms
--- vim73.orig/src/testdir/Make_vms.mms	2010-08-04 14:35:46.000000000 +0000
+++ vim73/src/testdir/Make_vms.mms	2011-05-17 09:38:50.816446812 +0000
@@ -4,7 +4,7 @@
 # Authors:	Zoltan Arpadffy, <arpadffy@polarhome.com>
 #		Sandor Kopanyi,  <sandor.kopanyi@mailbox.hu>
 #
-# Last change:  2010 Aug 04
+# Last change:  2011 Mar 03
 #
 # This has been tested on VMS 6.2 to 8.3 on DEC Alpha, VAX and IA64.
 # Edit the lines in the Configuration section below to select.
@@ -74,7 +74,8 @@
 	 test56.out test57.out test60.out \
 	 test61.out test62.out test63.out test64.out test65.out \
 	 test66.out test67.out test68.out test69.out \
-	 test71.out test72.out
+	 test71.out test72.out test74.out test75.out test76.out \
+	 test77.out
 
 # Known problems:
 # Test 30: a problem around mac format - unknown reason
diff -Naur vim73.orig/src/testdir/Makefile vim73/src/testdir/Makefile
--- vim73.orig/src/testdir/Makefile	2010-08-15 12:56:30.000000000 +0000
+++ vim73/src/testdir/Makefile	2011-05-17 09:37:47.947424441 +0000
@@ -10,6 +10,7 @@
 #   This will make testing about 10 times as slow.
 # VALGRIND = valgrind --tool=memcheck --leak-check=yes --num-callers=15 --log-file=valgrind.$*
 
+
 SCRIPTS = test1.out test2.out test3.out test4.out test5.out test6.out \
 		test7.out test8.out test9.out test10.out test11.out \
 		test12.out  test13.out test14.out test15.out test17.out \
@@ -23,7 +24,8 @@
 		test54.out test55.out test56.out test57.out test58.out \
 		test59.out test60.out test61.out test62.out test63.out \
 		test64.out test65.out test66.out test67.out test68.out \
-		test69.out test70.out test71.out test72.out test73.out
+		test69.out test70.out test71.out test72.out test73.out \
+		test74.out test75.out test76.out test77.out
 
 SCRIPTS_GUI = test16.out
 
@@ -44,7 +46,7 @@
 $(SCRIPTS) $(SCRIPTS_GUI): $(VIMPROG)
 
 clean:
-	-rm -rf *.out *.failed *.rej *.orig test.log tiny.vim small.vim mbyte.vim mzscheme.vim test.ok X* valgrind.pid* viminfo
+	-rm -rf *.out *.failed *.rej *.orig test.log tiny.vim small.vim mbyte.vim mzscheme.vim test.ok X* valgrind.* viminfo
 
 test1.out: test1.in
 	-rm -f $*.failed tiny.vim small.vim mbyte.vim mzscheme.vim test.ok X* viminfo
@@ -69,7 +71,7 @@
 		  fi \
 		else echo $* NO OUTPUT >>test.log; \
 		fi"
-	-rm -rf X* test.ok viminfo
+#	-rm -rf X* test.ok viminfo
 
 test49.out: test49.vim
 
diff -Naur vim73.orig/src/testdir/main.aap vim73/src/testdir/main.aap
--- vim73.orig/src/testdir/main.aap	2010-07-30 20:03:23.000000000 +0000
+++ vim73/src/testdir/main.aap	2011-05-17 09:33:30.879956357 +0000
@@ -13,7 +13,7 @@
 		test33.out test34.out test35.out test36.out test37.out
 		test38.out test39.out test40.out test41.out test42.out
 		test43.out test44.out test45.out test46.out test47.out
-		test48.out test49.out
+		test48.out test49.out test74.out
 
 ScriptsGUI = test16.out
 
diff -Naur vim73.orig/src/testdir/test3.in vim73/src/testdir/test3.in
--- vim73.orig/src/testdir/test3.in	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/testdir/test3.in	2011-05-17 09:39:13.657911728 +0000
@@ -1315,6 +1315,76 @@
 }
 
 STARTTEST
+:set cino=(0,ts
+2kdd=][
+ENDTEST
+
+void func(int a
+#if defined(FOO)
+		  , int b
+		  , int c
+#endif
+		 )
+{
+}
+
+STARTTEST
+:set cino=(0
+2kdd=][
+ENDTEST
+
+void
+func(int a
+#if defined(FOO)
+		  , int b
+		  , int c
+#endif
+		 )
+{
+}
+
+STARTTEST
+:set cino&
+2kdd=][
+ENDTEST
+
+void func(void)
+{
+	if(x==y)
+		if(y==z)
+			foo=1;
+		else { bar=1;
+			baz=2;
+		}
+	printf("Foo!\n");
+}
+
+STARTTEST
+:set cino&
+2kdd=][
+ENDTEST
+
+void func(void)
+{
+	cout << "a"
+	<< "b"
+	<< ") :"
+	<< "c";
+}
+
+STARTTEST
+:set com=s1:/*,m:*,ex:*/
+]]3jofoo();
+ENDTEST
+
+void func(void)
+{
+	/*
+	 * This is a comment.
+	 */
+}
+
+STARTTEST
 :g/^STARTTEST/.,/^ENDTEST/d
 :1;/start of AUTO/,$wq! test.out
 ENDTEST
diff -Naur vim73.orig/src/testdir/test3.ok vim73/src/testdir/test3.ok
--- vim73.orig/src/testdir/test3.ok	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/testdir/test3.ok	2011-05-17 09:39:13.657911728 +0000
@@ -1183,3 +1183,54 @@
 		foo;
 }
 
+
+void func(int a
+#if defined(FOO)
+		  , int b
+		  , int c
+#endif
+		 )
+{
+}
+
+
+	void
+func(int a
+#if defined(FOO)
+	 , int b
+	 , int c
+#endif
+	)
+{
+}
+
+
+void func(void)
+{
+	if(x==y)
+		if(y==z)
+			foo=1;
+		else { bar=1;
+			baz=2;
+		}
+	printf("Foo!\n");
+}
+
+
+void func(void)
+{
+	cout << "a"
+		<< "b"
+		<< ") :"
+		<< "c";
+}
+
+
+void func(void)
+{
+	/*
+	 * This is a comment.
+	 */
+	foo();
+}
+
diff -Naur vim73.orig/src/testdir/test49.vim vim73/src/testdir/test49.vim
--- vim73.orig/src/testdir/test49.vim	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/testdir/test49.vim	2011-05-17 09:32:57.239690189 +0000
@@ -1,6 +1,6 @@
 " Vim script language tests
 " Author:	Servatius Brandt <Servatius.Brandt@fujitsu-siemens.com>
-" Last Change:	2006 Apr 28
+" Last Change:	2010 Sep 29
 
 "-------------------------------------------------------------------------------
 " Test environment							    {{{1
@@ -8711,7 +8711,7 @@
 		endif
 	    else
 		if cmd == "let"
-		    let match = MATCH(0, thrmsg, 'E106', "Unknown variable")
+		    let match = MATCH(0, thrmsg, 'E121', "Undefined variable")
 		elseif cmd == "unlet"
 		    let match = MATCH(0, thrmsg, 'E108', "No such variable")
 		endif
diff -Naur vim73.orig/src/testdir/test55.in vim73/src/testdir/test55.in
--- vim73.orig/src/testdir/test55.in	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/testdir/test55.in	2011-05-17 09:34:28.453566145 +0000
@@ -342,7 +342,18 @@
 :$put =(d == d)
 :$put =(l != deepcopy(l))
 :$put =(d != deepcopy(d))
+:"
+:" compare complex recursively linked list and dict
+:let l = []
+:call add(l, l)
+:let dict4 = {"l": l}
+:call add(dict4.l, dict4)
+:let lcopy = deepcopy(l)
+:let dict4copy = deepcopy(dict4)
+:$put =(l == lcopy)
+:$put =(dict4 == dict4copy)
 :endfun
+:"
 :call Test(1, 2, [3, 4], {5: 6})  " This may take a while
 :"
 :delfunc Test
diff -Naur vim73.orig/src/testdir/test55.ok vim73/src/testdir/test55.ok
--- vim73.orig/src/testdir/test55.ok	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/testdir/test55.ok	2011-05-17 09:34:28.457565701 +0000
@@ -109,3 +109,5 @@
 1
 0
 0
+1
+1
diff -Naur vim73.orig/src/testdir/test57.in vim73/src/testdir/test57.in
--- vim73.orig/src/testdir/test57.in	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/testdir/test57.in	2011-05-17 09:33:28.676200957 +0000
@@ -53,15 +53,19 @@
 t02: numeric
 abc
 ab
-a
 a321
 a123
 a122
+a
+x-22
 b321
 b123
+
 c123d
+-24
  123b
 c321d
+0
 b322b
 b321
 b321b
diff -Naur vim73.orig/src/testdir/test57.ok vim73/src/testdir/test57.ok
--- vim73.orig/src/testdir/test57.ok	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/testdir/test57.ok	2011-05-17 09:33:28.676200957 +0000
@@ -21,6 +21,10 @@
 a
 
 
+
+-24
+x-22
+0
 a122
 a123
 b123
diff -Naur vim73.orig/src/testdir/test61.in vim73/src/testdir/test61.in
--- vim73.orig/src/testdir/test61.in	2010-06-27 03:07:58.000000000 +0000
+++ vim73/src/testdir/test61.in	2011-05-17 09:32:33.558318670 +0000
@@ -4,6 +4,10 @@
 Also tests :earlier and :later.
 
 STARTTEST
+:echo undotree().entries
+ENDTEST
+
+STARTTEST
 :" Delete three characters and undo
 Gx:set ul=100
 x:set ul=100
diff -Naur vim73.orig/src/testdir/test68.in vim73/src/testdir/test68.in
--- vim73.orig/src/testdir/test68.in	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/testdir/test68.in	2011-05-17 09:33:08.538436105 +0000
@@ -51,6 +51,17 @@
 }
 
 STARTTEST
+/^{/+2
+:set tw& fo=a
+I^^
+ENDTEST
+
+{
+   1aa
+   2bb
+}
+
+STARTTEST
 :g/^STARTTEST/.,/^ENDTEST/d
 :1;/^Results/,$wq! test.out
 ENDTEST
diff -Naur vim73.orig/src/testdir/test68.ok vim73/src/testdir/test68.ok
--- vim73.orig/src/testdir/test68.ok	2010-05-15 11:04:10.000000000 +0000
+++ vim73/src/testdir/test68.ok	2011-05-17 09:33:08.538436105 +0000
@@ -33,3 +33,6 @@
 #a b
 }
 
+
+{ 1aa ^^2bb }
+
diff -Naur vim73.orig/src/testdir/test74.in vim73/src/testdir/test74.in
--- vim73.orig/src/testdir/test74.in	1970-01-01 00:00:00.000000000 +0000
+++ vim73/src/testdir/test74.in	2011-05-17 09:33:30.879956357 +0000
@@ -0,0 +1,36 @@
+" Tests for storing global variables in the .viminfo file vim: set ft=vim:
+
+STARTTEST
+:so small.vim
+:" Do all test in a separate window to avoid E211 when we recursively
+:" delete the Xfind directory during cleanup
+:"
+:" This will cause a few errors, do it silently.
+:set visualbell
+:set nocp viminfo+=!,nviminfo
+:let MY_GLOBAL_DICT={'foo': 1, 'bar': 0, 'longvarible': 1000}
+:" store a really long list, so line wrapping will occur in viminfo file
+:let MY_GLOBAL_LIST=range(1,100)
+:wv! Xviminfo
+:unlet MY_GLOBAL_DICT
+:unlet MY_GLOBAL_LIST
+:rv! Xviminfo
+:call delete('Xviminfo')
+:if exists("MY_GLOBAL_DICT")
+:redir >> test.out
+:echo MY_GLOBAL_DICT
+:redir end
+:endif
+:if exists("MY_GLOBAL_LIST")
+:redir >> test.out
+:echo MY_GLOBAL_LIST
+:redir end
+:endif
+:redir >> test.out
+:echo "foobar"
+:redir end
+:endif
+:qa!
+ENDTEST
+
+eof
diff -Naur vim73.orig/src/testdir/test74.ok vim73/src/testdir/test74.ok
--- vim73.orig/src/testdir/test74.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim73/src/testdir/test74.ok	2011-05-17 09:33:30.879956357 +0000
@@ -0,0 +1,5 @@
+
+{'foo': 1, 'longvarible': 1000, 'bar': 0}
+[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]
+
+foobar
diff -Naur vim73.orig/src/testdir/test75.in vim73/src/testdir/test75.in
--- vim73.orig/src/testdir/test75.in	1970-01-01 00:00:00.000000000 +0000
+++ vim73/src/testdir/test75.in	2011-05-17 09:33:35.471446735 +0000
@@ -0,0 +1,16 @@
+" Tests for functions.
+
+STARTTEST
+:so small.vim
+:" Test maparg() with a string result
+:map foo<C-V> is<F4>foo
+:vnoremap <script> <buffer> <expr> <silent> bar isbar
+:call append('$', maparg('foo<C-V>'))
+:call append('$', string(maparg('foo<C-V>', '', 0, 1)))
+:call append('$', string(maparg('bar', '', 0, 1)))
+:"
+:/^eof/+1,$w! test.out
+:qa!
+ENDTEST
+
+eof
diff -Naur vim73.orig/src/testdir/test75.ok vim73/src/testdir/test75.ok
--- vim73.orig/src/testdir/test75.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim73/src/testdir/test75.ok	2011-05-17 09:33:35.471446735 +0000
@@ -0,0 +1,3 @@
+is<F4>foo
+{'silent': 0, 'noremap': 0, 'lhs': 'foo<C-V>', 'mode': ' ', 'expr': 0, 'sid': 0, 'rhs': 'is<F4>foo', 'buffer': 0}
+{'silent': 1, 'noremap': 1, 'lhs': 'bar', 'mode': 'v', 'expr': 1, 'sid': 0, 'rhs': 'isbar', 'buffer': 1}
diff -Naur vim73.orig/src/testdir/test76.in vim73/src/testdir/test76.in
--- vim73.orig/src/testdir/test76.in	1970-01-01 00:00:00.000000000 +0000
+++ vim73/src/testdir/test76.in	2011-05-17 09:34:21.862297719 +0000
@@ -0,0 +1,46 @@
+Tests for completefunc/omnifunc. vim: set ft=vim :
+
+STARTTEST
+:"Test that nothing happens if the 'completefunc' opens
+:"a new window (no completion, no crash)
+:so small.vim
+:function! DummyCompleteOne(findstart, base)
+:  if a:findstart
+:    return 0
+:  else
+:    wincmd n
+:    return ['onedef', 'oneDEF']
+:  endif
+:endfunction
+:setlocal completefunc=DummyCompleteOne
+/^one
+A:q!
+:function! DummyCompleteTwo(findstart, base)
+:  if a:findstart
+:    wincmd n
+:    return 0
+:  else
+:    return ['twodef', 'twoDEF']
+:  endif
+:endfunction
+:setlocal completefunc=DummyCompleteTwo
+/^two
+A:q!
+:"Test that 'completefunc' works when it's OK.
+:function! DummyCompleteThree(findstart, base)
+:  if a:findstart
+:    return 0
+:  else
+:    return ['threedef', 'threeDEF']
+:  endif
+:endfunction
+:setlocal completefunc=DummyCompleteThree
+/^three
+A:/^+++/,/^three/w! test.out
+:qa!
+ENDTEST
+
++++
+one
+two
+three
diff -Naur vim73.orig/src/testdir/test76.ok vim73/src/testdir/test76.ok
--- vim73.orig/src/testdir/test76.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim73/src/testdir/test76.ok	2011-05-17 09:34:21.862297719 +0000
@@ -0,0 +1,4 @@
++++
+
+two
+threeDEF
diff -Naur vim73.orig/src/testdir/test77.in vim73/src/testdir/test77.in
--- vim73.orig/src/testdir/test77.in	1970-01-01 00:00:00.000000000 +0000
+++ vim73/src/testdir/test77.in	2011-05-17 09:37:47.947424441 +0000
@@ -0,0 +1,27 @@
+Inserts 2 million lines with consecutive integers starting from 1
+(essentially, the output of GNU's seq 1 2000000), writes them to Xtest
+and writes its cksum to test.out.
+
+We need 2 million lines to trigger a call to mf_hash_grow().  If it would mess
+up the lines the checksum would differ.
+
+cksum is part of POSIX and so should be available on most Unixes.
+If it isn't available then the test will be skipped.
+
+STARTTEST
+:so small.vim
+:if !executable("cksum")
+: e! test.ok
+: w! test.out
+: qa!
+:endif
+:set fileformat=unix undolevels=-1
+ggdG
+:let i = 1
+:while i <= 2000000 | call append(i, range(i, i + 99)) | let i += 100 | endwhile
+ggdd
+:w! Xtest
+:!cksum Xtest > test.out
+:qa!
+ENDTEST
+
diff -Naur vim73.orig/src/testdir/test77.ok vim73/src/testdir/test77.ok
--- vim73.orig/src/testdir/test77.ok	1970-01-01 00:00:00.000000000 +0000
+++ vim73/src/testdir/test77.ok	2011-05-17 09:37:47.947424441 +0000
@@ -0,0 +1 @@
+3678979763 14888896 Xtest
diff -Naur vim73.orig/src/ui.c vim73/src/ui.c
--- vim73.orig/src/ui.c	2010-08-08 13:17:30.000000000 +0000
+++ vim73/src/ui.c	2011-05-17 09:32:48.052709885 +0000
@@ -469,7 +469,7 @@
      */
 #ifdef FEAT_X11
     /* Always own the selection, we might have lost it without being
-     * notified. */
+     * notified, e.g. during a ":sh" command. */
     if (cbd->available)
     {
 	int was_owned = cbd->owned;
@@ -1944,10 +1944,9 @@
  */
 
 static Boolean	clip_x11_convert_selection_cb __ARGS((Widget, Atom *, Atom *, Atom *, XtPointer *, long_u *, int *));
-
 static void  clip_x11_lose_ownership_cb __ARGS((Widget, Atom *));
-
 static void clip_x11_timestamp_cb __ARGS((Widget w, XtPointer n, XEvent *event, Boolean *cont));
+static void  clip_x11_request_selection_cb __ARGS((Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *));
 
 /*
  * Property callback to get a timestamp for XtOwnSelection.
@@ -1985,8 +1984,17 @@
 	return;
 
     /* Get the selection, using the event timestamp. */
-    XtOwnSelection(w, xproperty->atom, xproperty->time,
-	    clip_x11_convert_selection_cb, clip_x11_lose_ownership_cb, NULL);
+    if (XtOwnSelection(w, xproperty->atom, xproperty->time,
+	    clip_x11_convert_selection_cb, clip_x11_lose_ownership_cb,
+	    NULL) == OK)
+    {
+	/* Set the "owned" flag now, there may have been a call to
+	 * lose_ownership_cb in between. */
+	if (xproperty->atom == clip_plus.sel_atom)
+	    clip_plus.owned = TRUE;
+	else
+	    clip_star.owned = TRUE;
+    }
 }
 
     void
@@ -1997,8 +2005,6 @@
 	    /*(XtEventHandler)*/clip_x11_timestamp_cb, (XtPointer)NULL);
 }
 
-static void  clip_x11_request_selection_cb __ARGS((Widget, XtPointer, Atom *, Atom *, XtPointer, long_u *, int *));
-
     static void
 clip_x11_request_selection_cb(w, success, sel_atom, type, value, length,
 			      format)
@@ -2336,7 +2342,7 @@
 
     void
 clip_x11_lose_selection(myShell, cbd)
-    Widget	myShell;
+    Widget		myShell;
     VimClipboard	*cbd;
 {
     XtDisownSelection(myShell, cbd->sel_atom, CurrentTime);
@@ -2344,14 +2350,29 @@
 
     int
 clip_x11_own_selection(myShell, cbd)
-    Widget	myShell;
+    Widget		myShell;
     VimClipboard	*cbd;
 {
-    /* Get the time by a zero-length append, clip_x11_timestamp_cb will be
-     * called with the current timestamp.  */
-    if (!XChangeProperty(XtDisplay(myShell), XtWindow(myShell), cbd->sel_atom,
-	    timestamp_atom, 32, PropModeAppend, NULL, 0))
+    /* When using the GUI we have proper timestamps, use the one of the last
+     * event.  When in the console we don't get events (the terminal gets
+     * them), Get the time by a zero-length append, clip_x11_timestamp_cb will
+     * be called with the current timestamp.  */
+#ifdef FEAT_GUI
+    if (gui.in_use)
+    {
+	if (XtOwnSelection(myShell, cbd->sel_atom,
+	       XtLastTimestampProcessed(XtDisplay(myShell)),
+	       clip_x11_convert_selection_cb, clip_x11_lose_ownership_cb,
+	       NULL) == False)
 	return FAIL;
+    }
+    else
+#endif
+    {
+	if (!XChangeProperty(XtDisplay(myShell), XtWindow(myShell),
+		  cbd->sel_atom, timestamp_atom, 32, PropModeAppend, NULL, 0))
+	return FAIL;
+    }
     /* Flush is required in a terminal as nothing else is doing it. */
     XFlush(XtDisplay(myShell));
     return OK;
diff -Naur vim73.orig/src/undo.c vim73/src/undo.c
--- vim73.orig/src/undo.c	2010-08-07 10:48:15.000000000 +0000
+++ vim73/src/undo.c	2011-05-17 09:36:25.592564861 +0000
@@ -81,10 +81,6 @@
 #define UH_MAGIC 0x18dade	/* value for uh_magic when in use */
 #define UE_MAGIC 0xabc123	/* value for ue_magic when in use */
 
-#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64)
-# include "vimio.h"	/* for vim_read(), must be before vim.h */
-#endif
-
 #include "vim.h"
 
 static void u_unch_branch __ARGS((u_header_T *uhp));
@@ -1386,7 +1382,7 @@
 		char_u	mbuf[UF_START_MAGIC_LEN];
 		int	len;
 
-		len = vim_read(fd, mbuf, UF_START_MAGIC_LEN);
+		len = read_eintr(fd, mbuf, UF_START_MAGIC_LEN);
 		close(fd);
 		if (len < UF_START_MAGIC_LEN
 		      || memcmp(mbuf, UF_START_MAGIC, UF_START_MAGIC_LEN) != 0)
@@ -1861,6 +1857,7 @@
     curbuf->b_u_seq_cur = seq_cur;
     curbuf->b_u_time_cur = seq_time;
     curbuf->b_u_save_nr_last = last_save_nr;
+    curbuf->b_u_save_nr_cur = last_save_nr;
 
     curbuf->b_u_synced = TRUE;
     vim_free(uhp_table);
@@ -2794,7 +2791,7 @@
 								uhp->uh_time);
 	    if (uhp->uh_save_nr > 0)
 	    {
-		while (STRLEN(IObuff) < 32)
+		while (STRLEN(IObuff) < 33)
 		    STRCAT(IObuff, " ");
 		vim_snprintf_add((char *)IObuff, IOSIZE,
 						   "  %3ld", uhp->uh_save_nr);
@@ -2849,7 +2846,7 @@
 	sort_strings((char_u **)ga.ga_data, ga.ga_len);
 
 	msg_start();
-	msg_puts_attr((char_u *)_("number changes  time            saved"),
+	msg_puts_attr((char_u *)_("number changes  when               saved"),
 							      hl_attr(HLF_T));
 	for (i = 0; i < ga.ga_len && !got_int; ++i)
 	{
@@ -2879,7 +2876,15 @@
     if (time(NULL) - tt >= 100)
     {
 	curtime = localtime(&tt);
-	(void)strftime((char *)buf, buflen, "%H:%M:%S", curtime);
+	if (time(NULL) - tt < (60L * 60L * 12L))
+	    /* within 12 hours */
+	    (void)strftime((char *)buf, buflen, "%H:%M:%S", curtime);
+	else if (time(NULL) - tt < (60L * 60L * 24L * 180L))
+	    /* within 6 months */
+	    (void)strftime((char *)buf, buflen, "%m/%d %H:%M:%S", curtime);
+	else
+	    /* long ago */
+	    (void)strftime((char *)buf, buflen, "%Y/%m/%d %H:%M:%S", curtime);
     }
     else
 #endif
@@ -3299,7 +3304,7 @@
 #ifdef FEAT_QUICKFIX
 	    !bt_dontwrite(buf) &&
 #endif
-	    (buf->b_changed || file_ff_differs(buf));
+	    (buf->b_changed || file_ff_differs(buf, TRUE));
 }
 
     int
@@ -3309,7 +3314,7 @@
 #ifdef FEAT_QUICKFIX
 	!bt_dontwrite(curbuf) &&
 #endif
-	(curbuf->b_changed || file_ff_differs(curbuf));
+	(curbuf->b_changed || file_ff_differs(curbuf, TRUE));
 }
 
 #if defined(FEAT_EVAL) || defined(PROTO)
diff -Naur vim73.orig/src/version.c vim73/src/version.c
--- vim73.orig/src/version.c	2010-08-01 13:45:48.000000000 +0000
+++ vim73/src/version.c	2011-05-17 09:39:36.371390862 +0000
@@ -715,6 +715,384 @@
 static int included_patches[] =
 {   /* Add new patch number below this line */
 /**/
+    189,
+/**/
+    188,
+/**/
+    187,
+/**/
+    186,
+/**/
+    185,
+/**/
+    184,
+/**/
+    183,
+/**/
+    182,
+/**/
+    181,
+/**/
+    180,
+/**/
+    179,
+/**/
+    178,
+/**/
+    177,
+/**/
+    176,
+/**/
+    175,
+/**/
+    174,
+/**/
+    173,
+/**/
+    172,
+/**/
+    171,
+/**/
+    170,
+/**/
+    169,
+/**/
+    168,
+/**/
+    167,
+/**/
+    166,
+/**/
+    165,
+/**/
+    164,
+/**/
+    163,
+/**/
+    162,
+/**/
+    161,
+/**/
+    160,
+/**/
+    159,
+/**/
+    158,
+/**/
+    157,
+/**/
+    156,
+/**/
+    155,
+/**/
+    154,
+/**/
+    153,
+/**/
+    152,
+/**/
+    151,
+/**/
+    150,
+/**/
+    149,
+/**/
+    148,
+/**/
+    147,
+/**/
+    146,
+/**/
+    145,
+/**/
+    144,
+/**/
+    143,
+/**/
+    142,
+/**/
+    141,
+/**/
+    140,
+/**/
+    139,
+/**/
+    138,
+/**/
+    137,
+/**/
+    136,
+/**/
+    135,
+/**/
+    134,
+/**/
+    133,
+/**/
+    132,
+/**/
+    131,
+/**/
+    130,
+/**/
+    129,
+/**/
+    128,
+/**/
+    127,
+/**/
+    126,
+/**/
+    125,
+/**/
+    124,
+/**/
+    123,
+/**/
+    122,
+/**/
+    121,
+/**/
+    120,
+/**/
+    119,
+/**/
+    118,
+/**/
+    117,
+/**/
+    116,
+/**/
+    115,
+/**/
+    114,
+/**/
+    113,
+/**/
+    112,
+/**/
+    111,
+/**/
+    110,
+/**/
+    109,
+/**/
+    108,
+/**/
+    107,
+/**/
+    106,
+/**/
+    105,
+/**/
+    104,
+/**/
+    103,
+/**/
+    102,
+/**/
+    101,
+/**/
+    100,
+/**/
+    99,
+/**/
+    98,
+/**/
+    97,
+/**/
+    96,
+/**/
+    95,
+/**/
+    94,
+/**/
+    93,
+/**/
+    92,
+/**/
+    91,
+/**/
+    90,
+/**/
+    89,
+/**/
+    88,
+/**/
+    87,
+/**/
+    86,
+/**/
+    85,
+/**/
+    84,
+/**/
+    83,
+/**/
+    82,
+/**/
+    81,
+/**/
+    80,
+/**/
+    79,
+/**/
+    78,
+/**/
+    77,
+/**/
+    76,
+/**/
+    75,
+/**/
+    74,
+/**/
+    73,
+/**/
+    72,
+/**/
+    71,
+/**/
+    70,
+/**/
+    69,
+/**/
+    68,
+/**/
+    67,
+/**/
+    66,
+/**/
+    65,
+/**/
+    64,
+/**/
+    63,
+/**/
+    62,
+/**/
+    61,
+/**/
+    60,
+/**/
+    59,
+/**/
+    58,
+/**/
+    57,
+/**/
+    56,
+/**/
+    55,
+/**/
+    54,
+/**/
+    53,
+/**/
+    52,
+/**/
+    51,
+/**/
+    50,
+/**/
+    49,
+/**/
+    48,
+/**/
+    47,
+/**/
+    46,
+/**/
+    45,
+/**/
+    44,
+/**/
+    43,
+/**/
+    42,
+/**/
+    41,
+/**/
+    40,
+/**/
+    39,
+/**/
+    38,
+/**/
+    37,
+/**/
+    36,
+/**/
+    35,
+/**/
+    34,
+/**/
+    33,
+/**/
+    32,
+/**/
+    31,
+/**/
+    30,
+/**/
+    29,
+/**/
+    28,
+/**/
+    27,
+/**/
+    26,
+/**/
+    25,
+/**/
+    24,
+/**/
+    23,
+/**/
+    22,
+/**/
+    21,
+/**/
+    20,
+/**/
+    19,
+/**/
+    18,
+/**/
+    17,
+/**/
+    16,
+/**/
+    15,
+/**/
+    14,
+/**/
+    13,
+/**/
+    12,
+/**/
+    11,
+/**/
+    10,
+/**/
+    9,
+/**/
+    8,
+/**/
+    7,
+/**/
+    6,
+/**/
+    5,
+/**/
+    4,
+/**/
+    3,
+/**/
+    2,
+/**/
+    1,
+/**/
     0
 };
 
@@ -833,9 +1211,6 @@
 # endif
 #endif
 
-#ifdef RISCOS
-    MSG_PUTS(_("\nRISC OS version"));
-#endif
 #ifdef VMS
     MSG_PUTS(_("\nOpenVMS version"));
 # ifdef HAVE_PATHDEF
@@ -1262,9 +1637,9 @@
 	if (highest_patch())
 	{
 	    /* Check for 9.9x or 9.9xx, alpha/beta version */
-	    if (isalpha((int)mediumVersion[3]))
+	    if (isalpha((int)vers[3]))
 	    {
-		if (isalpha((int)mediumVersion[4]))
+		if (isalpha((int)vers[4]))
 		    sprintf((char *)vers + 5, ".%d%s", highest_patch(),
 							   mediumVersion + 5);
 		else
diff -Naur vim73.orig/src/vim.h vim73/src/vim.h
--- vim73.orig/src/vim.h	2010-07-29 18:46:39.000000000 +0000
+++ vim73/src/vim.h	2011-05-17 09:39:31.627917317 +0000
@@ -27,6 +27,11 @@
 # endif
 #endif
 
+#if defined(MSDOS) || defined(WIN16) || defined(WIN32) || defined(_WIN64) \
+	|| defined(__EMX__)
+# include "vimio.h"
+#endif
+
 /* ============ the header file puzzle (ca. 50-100 pieces) ========= */
 
 #ifdef HAVE_CONFIG_H	/* GNU autoconf (or something else) was here */
@@ -179,9 +184,6 @@
 #  define SIZEOF_INT 2
 # endif
 #endif
-#ifdef RISCOS
-# define SIZEOF_INT 4
-#endif
 
 
 #include "feature.h"	/* #defines for optionals and features */
@@ -192,8 +194,8 @@
 #endif
 
 #ifdef NO_X11_INCLUDES
-    /* In os_mac_conv.c NO_X11_INCLUDES is defined to avoid X11 headers.
-     * Disable all X11 related things to avoid conflicts. */
+    /* In os_mac_conv.c and os_macosx.m NO_X11_INCLUDES is defined to avoid
+     * X11 headers.  Disable all X11 related things to avoid conflicts. */
 # ifdef FEAT_X11
 #  undef FEAT_X11
 # endif
@@ -335,10 +337,6 @@
 # include "os_mac.h"
 #endif
 
-#ifdef RISCOS
-# include "os_riscos.h"
-#endif
-
 #ifdef __QNX__
 # include "os_qnx.h"
 #endif
@@ -475,6 +473,11 @@
 # include <sys/stat.h>
 #endif
 
+#if defined(HAVE_ERRNO_H) || defined(DJGPP) || defined(WIN16) \
+	|| defined(WIN32) || defined(_WIN64) || defined(__EMX__)
+# include <errno.h>
+#endif
+
 /*
  * Allow other (non-unix) systems to configure themselves now
  * These are also in os_unix.h, because osdef.sh needs them there.
@@ -798,6 +801,7 @@
 #define WILD_KEEP_ALL		32
 #define WILD_SILENT		64
 #define WILD_ESCAPE		128
+#define WILD_ICASE		256
 
 /* Flags for expand_wildcards() */
 #define EW_DIR		0x01	/* include directory names */
@@ -808,6 +812,7 @@
 #define EW_SILENT	0x20	/* don't print "1 returned" from shell */
 #define EW_EXEC		0x40	/* executable files */
 #define EW_PATH		0x80	/* search in 'path' too */
+#define EW_ICASE	0x100	/* ignore case */
 /* Note: mostly EW_NOTFOUND and EW_SILENT are mutually exclusive: EW_NOTFOUND
  * is used when executing commands and EW_SILENT for interactive expanding. */
 
@@ -1423,6 +1428,8 @@
 
 #define IOSIZE	   (1024+1)	/* file i/o and sprintf buffer size */
 
+#define DIALOG_MSG_SIZE 1000	/* buffer size for dialog_msg() */
+
 #ifdef FEAT_MBYTE
 # define MSG_BUF_LEN 480	/* length of buffer for small messages */
 # define MSG_BUF_CLEN  (MSG_BUF_LEN / 6)    /* cell length (worst case: utf-8
@@ -1640,6 +1647,11 @@
 # define USE_INPUT_BUF
 #endif
 
+#ifndef EINTR
+# define read_eintr(fd, buf, count) vim_read((fd), (buf), (count))
+# define write_eintr(fd, buf, count) vim_write((fd), (buf), (count))
+#endif
+
 #ifdef MSWIN
 /* On MS-Windows the third argument isn't size_t.  This matters for Win64,
  * where sizeof(size_t)==8, not 4 */
@@ -1842,7 +1854,8 @@
 #define VV_OP		52
 #define VV_SEARCHFORWARD 53
 #define VV_OLDFILES	54
-#define VV_LEN		55	/* number of v: vars */
+#define VV_WINDOWID	55
+#define VV_LEN		56	/* number of v: vars */
 
 #ifdef FEAT_CLIPBOARD
 
@@ -2193,4 +2206,14 @@
 #define MSCR_LEFT	-1
 #define MSCR_RIGHT	-2
 
+#define KEYLEN_PART_KEY -1	/* keylen value for incomplete key-code */
+#define KEYLEN_PART_MAP -2	/* keylen value for incomplete mapping */
+#define KEYLEN_REMOVED  9999	/* keylen value for removed sequence */
+
+/* Return values from win32_fileinfo(). */
+#define FILEINFO_OK	     0
+#define FILEINFO_ENC_FAIL    1	/* enc_to_utf16() failed */
+#define FILEINFO_READ_FAIL   2	/* CreateFile() failed */
+#define FILEINFO_INFO_FAIL   3	/* GetFileInformationByHandle() failed */
+
 #endif /* VIM__H */
diff -Naur vim73.orig/src/window.c vim73/src/window.c
--- vim73.orig/src/window.c	2010-07-20 20:23:49.000000000 +0000
+++ vim73/src/window.c	2011-05-17 09:36:07.634558005 +0000
@@ -70,7 +70,8 @@
 #endif /* FEAT_WINDOWS */
 
 static win_T *win_alloc __ARGS((win_T *after, int hidden));
-static void win_new_height __ARGS((win_T *, int));
+static void set_fraction __ARGS((win_T *wp));
+static void win_new_height __ARGS((win_T *wp, int height));
 
 #define URL_SLASH	1		/* path_is_url() has found "://" */
 #define URL_BACKSLASH	2		/* path_is_url() has found ":\\" */
@@ -525,9 +526,7 @@
 		    setpcmark();
 		    if (win_split(0, 0) == OK)
 		    {
-# ifdef FEAT_SCROLLBIND
-			curwin->w_p_scb = FALSE;
-# endif
+			RESET_BINDING(curwin);
 			(void)do_ecmd(0, ptr, NULL, NULL, ECMD_LASTL,
 							   ECMD_HIDE, NULL);
 			if (nchar == 'F' && lnum >= 0)
@@ -985,10 +984,17 @@
     else
 	frame_append(curfrp, frp);
 
+    /* Set w_fraction now so that the cursor keeps the same relative
+     * vertical position. */
+    if (oldwin->w_height > 0)
+	set_fraction(oldwin);
+    wp->w_fraction = oldwin->w_fraction;
+
 #ifdef FEAT_VERTSPLIT
     if (flags & WSP_VERT)
     {
 	wp->w_p_scr = curwin->w_p_scr;
+
 	if (need_status)
 	{
 	    win_new_height(oldwin, oldwin->w_height - 1);
@@ -3277,9 +3283,7 @@
     if (aucmd_win != NULL)
     {
 	win_init_some(aucmd_win, curwin);
-# ifdef FEAT_SCROLLBIND
-	aucmd_win->w_p_scb = FALSE;
-# endif
+	RESET_BINDING(aucmd_win);
 	new_frame(aucmd_win);
     }
 }
@@ -3320,10 +3324,8 @@
 	/* First window in new tab page, initialize it from "oldwin". */
 	win_init(curwin, oldwin, 0);
 
-# ifdef FEAT_SCROLLBIND
-	/* We don't want scroll-binding in the first window. */
-	curwin->w_p_scb = FALSE;
-# endif
+	/* We don't want cursor- and scroll-binding in the first window. */
+	RESET_BINDING(curwin);
     }
 #endif
 
@@ -5459,6 +5461,19 @@
 
 #endif /* FEAT_WINDOWS */
 
+#define FRACTION_MULT	16384L
+
+/*
+ * Set wp->w_fraction for the current w_wrow and w_height.
+ */
+    static void
+set_fraction(wp)
+    win_T	*wp;
+{
+    wp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT
+				    + FRACTION_MULT / 2) / (long)wp->w_height;
+}
+
 /*
  * Set the height of a window.
  * This takes care of the things inside the window, not what happens to the
@@ -5471,7 +5486,6 @@
 {
     linenr_T	lnum;
     int		sline, line_size;
-#define FRACTION_MULT	16384L
 
     /* Don't want a negative height.  Happens when splitting a tiny window.
      * Will equalize heights soon to fix it. */
@@ -5481,8 +5495,7 @@
 	return;	    /* nothing to do */
 
     if (wp->w_wrow != wp->w_prev_fraction_row && wp->w_height > 0)
-	wp->w_fraction = ((long)wp->w_wrow * FRACTION_MULT
-				    + FRACTION_MULT / 2) / (long)wp->w_height;
+	set_fraction(wp);
 
     wp->w_height = height;
     wp->w_skipcol = 0;
diff -Naur vim73.orig/src/workshop.c vim73/src/workshop.c
--- vim73.orig/src/workshop.c	2010-08-08 13:18:24.000000000 +0000
+++ vim73/src/workshop.c	2011-05-17 09:35:40.557563272 +0000
@@ -16,7 +16,6 @@
 #include <sys/types.h>
 #include <netdb.h>
 #include <netinet/in.h>
-#include <errno.h>
 #include <sys/socket.h>
 #ifdef HAVE_LIBGEN_H
 # include <libgen.h>
diff -Naur vim73.orig/src/xxd/xxd.c vim73/src/xxd/xxd.c
--- vim73.orig/src/xxd/xxd.c	2010-05-15 11:04:06.000000000 +0000
+++ vim73/src/xxd/xxd.c	2011-05-17 09:38:29.902767943 +0000
@@ -49,6 +49,8 @@
  *	    option -b added: 01000101 binary output in normal format.
  * 16.05.00 Added VAXC changes by Stephen P. Wall
  * 16.05.00 Improved MMS file and merge for VMS by Zoltan Arpadffy
+ * 2011 March  Better error handling by Florian Zumbiehl.
+ * 2011 April  Formatting by Bram Moolenaar
  *
  * (c) 1990-1998 by Juergen Weigert (jnweiger@informatik.uni-erlangen.de)
  *
@@ -207,8 +209,9 @@
 
 /* Let's collect some prototypes */
 /* CodeWarrior is really picky about missing prototypes */
-static void exit_with_usage __P((char *));
-static int huntype __P((FILE *, FILE *, FILE *, char *, int, int, long));
+static void exit_with_usage __P((void));
+static void die __P((int));
+static int huntype __P((FILE *, FILE *, FILE *, int, int, long));
 static void xxdline __P((FILE *, char *, int));
 
 #define TRY_SEEK	/* attempt to use lseek, or skip forward by reading */
@@ -223,9 +226,10 @@
 #define HEX_CINCLUDE 2
 #define HEX_BITS 3		/* not hex a dump, but bits: 01111001 */
 
-static void
-exit_with_usage(pname)
-char *pname;
+static char *pname;
+
+  static void
+exit_with_usage()
 {
   fprintf(stderr, "Usage:\n       %s [options] [infile [outfile]]\n", pname);
   fprintf(stderr, "    or\n       %s -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]]\n", pname);
@@ -252,6 +256,15 @@
   exit(1);
 }
 
+  static void
+die(ret)
+  int ret;
+{
+  fprintf(stderr, "%s: ", pname);
+  perror(NULL);
+  exit(ret);
+}
+
 /*
  * Max. cols binary characters are decoded from the input stream per line.
  * Two adjacent garbage characters after evaluated data delimit valid data.
@@ -259,12 +272,11 @@
  *
  * The name is historic and came from 'undo type opt h'.
  */
-static int
-huntype(fpi, fpo, fperr, pname, cols, hextype, base_off)
-FILE *fpi, *fpo, *fperr;
-char *pname;
-int cols, hextype;
-long base_off;
+  static int
+huntype(fpi, fpo, fperr, cols, hextype, base_off)
+  FILE *fpi, *fpo, *fperr;
+  int cols, hextype;
+  long base_off;
 {
   int c, ign_garb = 1, n1 = -1, n2 = 0, n3, p = cols;
   long have_off = 0, want_off = 0;
@@ -318,7 +330,8 @@
 
       if (base_off + want_off != have_off)
 	{
-	  fflush(fpo);
+	  if (fflush(fpo) != 0)
+	    die(3);
 #ifdef TRY_SEEK
 	  c = fseek(fpo, base_off + want_off - have_off, 1);
 	  if (c >= 0)
@@ -330,12 +343,14 @@
 	      return 5;
 	    }
 	  for (; have_off < base_off + want_off; have_off++)
-	    putc(0, fpo);
+	    if (putc(0, fpo) == EOF)
+	      die(3);
 	}
 
       if (n2 >= 0 && n1 >= 0)
 	{
-	  putc((n2 << 4) | n1, fpo);
+	  if (putc((n2 << 4) | n1, fpo) == EOF)
+	    die(3);
 	  have_off++;
 	  want_off++;
 	  n1 = -1;
@@ -345,6 +360,8 @@
 	      want_off = 0;
 	      while ((c = getc(fpi)) != '\n' && c != EOF)
 		;
+	      if (c == EOF && ferror(fpi))
+		die(2);
 	      ign_garb = 1;
 	    }
 	}
@@ -355,15 +372,20 @@
 	    want_off = 0;
 	  while ((c = getc(fpi)) != '\n' && c != EOF)
 	    ;
+	  if (c == EOF && ferror(fpi))
+	    die(2);
 	  ign_garb = 1;
 	}
     }
-  fflush(fpo);
+  if (fflush(fpo) != 0)
+    die(3);
 #ifdef TRY_SEEK
   fseek(fpo, 0L, 2);
 #endif
-  fclose(fpo);
-  fclose(fpi);
+  if (fclose(fpo) != 0)
+    die(3);
+  if (fclose(fpi) != 0)
+    die(2);
   return 0;
 }
 
@@ -379,11 +401,11 @@
  *
  * If nz is always positive, lines are never suppressed.
  */
-static void
+  static void
 xxdline(fp, l, nz)
-FILE *fp;
-char *l;
-int nz;
+  FILE *fp;
+  char *l;
+  int nz;
 {
   static char z[LLEN+1];
   static int zero_seen = 0;
@@ -398,12 +420,15 @@
 	  if (nz < 0)
 	    zero_seen--;
 	  if (zero_seen == 2)
-	    fputs(z, fp);
+	    if (fputs(z, fp) == EOF)
+	      die(3);
 	  if (zero_seen > 2)
-	    fputs("*\n", fp);
+	    if (fputs("*\n", fp) == EOF)
+	      die(3);
 	}
       if (nz >= 0 || zero_seen > 0)
-	fputs(l, fp);
+	if (fputs(l, fp) == EOF)
+	  die(3);
       if (nz)
 	zero_seen = 0;
     }
@@ -439,10 +464,10 @@
     0070,0071,0372,0373,0374,0375,0376,0377
 };
 
-int
+  int
 main(argc, argv)
-int argc;
-char *argv[];
+  int argc;
+  char *argv[];
 {
   FILE *fp, *fpo;
   int c, e, p = 0, relseek = 1, negseek = 0, revert = 0;
@@ -451,8 +476,8 @@
   int octspergrp = -1;	/* number of octets grouped in output */
   int grplen;		/* total chars per octet group */
   long length = -1, n = 0, seekoff = 0;
-  char l[LLEN+1];
-  char *pname, *pp;
+  static char l[LLEN+1];  /* static because it may be too big for stack */
+  char *pp;
 
 #ifdef AMIGA
   /* This program doesn't work when started from the Workbench */
@@ -495,7 +520,7 @@
 	  else
 	    {
 	      if (!argv[2])
-		exit_with_usage(pname);
+		exit_with_usage();
 	      cols = (int)strtol(argv[2], NULL, 0);
 	      argv++;
 	      argc--;
@@ -508,7 +533,7 @@
 	  else
 	    {
 	      if (!argv[2])
-		exit_with_usage(pname);
+		exit_with_usage();
 	      octspergrp = (int)strtol(argv[2], NULL, 0);
 	      argv++;
 	      argc--;
@@ -531,7 +556,7 @@
 	  else
 	    {
 	      if (!argv[2])
-		exit_with_usage(pname);
+		exit_with_usage();
 #ifdef TRY_SEEK
 	      if (argv[2][0] == '+')
 		relseek++;
@@ -550,7 +575,7 @@
 	  else
 	    {
 	      if (!argv[2])
-		exit_with_usage(pname);
+		exit_with_usage();
 	      length = strtol(argv[2], (char **)NULL, 0);
 	      argv++;
 	      argc--;
@@ -563,7 +588,7 @@
 	  break;
 	}
       else if (pp[0] == '-' && pp[1])	/* unknown option */
-	exit_with_usage(pname);
+	exit_with_usage();
       else
 	break;				/* not an option */
 
@@ -602,7 +627,7 @@
     octspergrp = cols;
 
   if (argc > 3)
-    exit_with_usage(pname);
+    exit_with_usage();
 
   if (argc == 1 || (argv[1][0] == '-' && !argv[1][1]))
     BIN_ASSIGN(fp = stdin, !revert);
@@ -640,7 +665,7 @@
 	  fprintf(stderr, "%s: sorry, cannot revert this type of hexdump\n", pname);
 	  return -1;
 	}
-      return huntype(fp, fpo, stderr, pname, cols, hextype,
+      return huntype(fp, fpo, stderr, cols, hextype,
 		negseek ? -seekoff : seekoff);
     }
 
@@ -664,7 +689,18 @@
 	  long s = seekoff;
 
 	  while (s--)
-	    (void)getc(fp);
+	    if (getc(fp) == EOF)
+	    {
+	      if (ferror(fp))
+		{
+		  die(2);
+		}
+	      else
+		{
+		  fprintf(stderr, "%s: sorry cannot seek.\n", pname);
+		  return 4;
+		}
+	    }
 	}
     }
 
@@ -672,54 +708,75 @@
     {
       if (fp != stdin)
 	{
-	  fprintf(fpo, "unsigned char %s", isdigit((int)argv[1][0]) ? "__" : "");
+	  if (fprintf(fpo, "unsigned char %s", isdigit((int)argv[1][0]) ? "__" : "") < 0)
+	    die(3);
 	  for (e = 0; (c = argv[1][e]) != 0; e++)
-	    putc(isalnum(c) ? c : '_', fpo);
-	  fputs("[] = {\n", fpo);
+	    if (putc(isalnum(c) ? c : '_', fpo) == EOF)
+	      die(3);
+	  if (fputs("[] = {\n", fpo) == EOF)
+	    die(3);
 	}
 
       p = 0;
+      c = 0;
       while ((length < 0 || p < length) && (c = getc(fp)) != EOF)
 	{
-	  fprintf(fpo, (hexx == hexxa) ? "%s0x%02x" : "%s0X%02X",
-	    (p % cols) ? ", " : ",\n  "+2*!p,  c);
+	  if (fprintf(fpo, (hexx == hexxa) ? "%s0x%02x" : "%s0X%02X",
+		(p % cols) ? ", " : ",\n  "+2*!p,  c) < 0)
+	    die(3);
 	  p++;
 	}
+      if (c == EOF && ferror(fp))
+	die(2);
 
       if (p)
-	fputs("\n};\n"+3*(fp == stdin), fpo);
+	if (fputs("\n};\n" + 3 * (fp == stdin), fpo) == EOF)
+	  die(3);
 
       if (fp != stdin)
 	{
-	  fprintf(fpo, "unsigned int %s", isdigit((int)argv[1][0]) ? "__" : "");
+	  if (fprintf(fpo, "unsigned int %s", isdigit((int)argv[1][0]) ? "__" : "") < 0)
+	    die(3);
 	  for (e = 0; (c = argv[1][e]) != 0; e++)
-	    putc(isalnum(c) ? c : '_', fpo);
-	  fprintf(fpo, "_len = %d;\n", p);
+	    if (putc(isalnum(c) ? c : '_', fpo) == EOF)
+	      die(3);
+	  if (fprintf(fpo, "_len = %d;\n", p) < 0)
+	    die(3);
 	}
 
-      fclose(fp);
-      fclose(fpo);
+      if (fclose(fp))
+	die(2);
+      if (fclose(fpo))
+	die(3);
       return 0;
     }
 
   if (hextype == HEX_POSTSCRIPT)
     {
       p = cols;
+      e = 0;
       while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
 	{
-	  putchar(hexx[(e >> 4) & 0xf]);
-	  putchar(hexx[(e     ) & 0xf]);
+	  if (putc(hexx[(e >> 4) & 0xf], fpo) == EOF
+		  || putc(hexx[e & 0xf], fpo) == EOF)
+	    die(3);
 	  n++;
 	  if (!--p)
 	    {
-	      putchar('\n');
+	      if (putc('\n', fpo) == EOF)
+		die(3);
 	      p = cols;
 	    }
 	}
+      if (e == EOF && ferror(fp))
+	die(2);
       if (p < cols)
-	putchar('\n');
-      fclose(fp);
-      fclose(fpo);
+	if (putc('\n', fpo) == EOF)
+	  die(3);
+      if (fclose(fp))
+	die(2);
+      if (fclose(fpo))
+	die(3);
       return 0;
     }
 
@@ -730,6 +787,7 @@
   else	/* hextype == HEX_BITS */
     grplen = 8 * octspergrp + 1;
 
+  e = 0;
   while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
     {
       if (p == 0)
@@ -771,6 +829,8 @@
 	  p = 0;
 	}
     }
+  if (e == EOF && ferror(fp))
+    die(2);
   if (p)
     {
       l[c = (11 + (grplen * cols - 1)/octspergrp + p)] = '\n'; l[++c] = '\0';
@@ -779,7 +839,11 @@
   else if (autoskip)
     xxdline(fpo, l, -1);	/* last chance to flush out suppressed lines */
 
-  fclose(fp);
-  fclose(fpo);
+  if (fclose(fp))
+    die(2);
+  if (fclose(fpo))
+    die(3);
   return 0;
 }
+
+/* vi:set ts=8 sw=4 sts=2 cino+={2 cino+=n-2 : */
