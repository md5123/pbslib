Description: Handle partition devices without corresponding disk devices
 On Xen, it's possible to assign disk images in the host to things that are
 named rather like partitions in the guest (e.g. /dev/sda1), but that don't
 have an associated disk (e.g. /dev/sda); indeed, the latter device is
 nonexistent.  This confuses grub_util_biosdisk_get_grub_dev.
 .
 There's really no other situation in which I think it's terribly plausible
 that you might have /dev/sda1 but not /dev/sda, so it seems to me that in
 this case we can reasonably treat the apparent "partition" as a disk in its
 own right.
Author: Colin Watson <cjwatson@ubuntu.com>
Bug-Ubuntu: https://bugs.launchpad.net/bugs/623609
Forwarded: yes
Applied-Upstream: http://bazaar.launchpad.net/~vcs-imports/grub/grub2-bzr/revision/2832
Last-Update: 2010-09-21

Index: b/kern/emu/hostdisk.c
===================================================================
--- a/kern/emu/hostdisk.c
+++ b/kern/emu/hostdisk.c
@@ -1348,12 +1348,15 @@
 #endif /* defined(__NetBSD__) */
 
 static int
-find_system_device (const char *os_dev, struct stat *st)
+find_system_device (const char *os_dev, struct stat *st, int convert)
 {
   unsigned int i;
   char *os_disk;
 
-  os_disk = convert_system_partition_to_system_disk (os_dev, st);
+  if (convert)
+    os_disk = convert_system_partition_to_system_disk (os_dev, st);
+  else
+    os_disk = xstrdup (os_dev);
   if (! os_disk)
     return -1;
 
@@ -1436,7 +1439,7 @@
       return 0;
     }
 
-  drive = find_system_device (os_dev, &st);
+  drive = find_system_device (os_dev, &st, 1);
   if (drive < 0)
     {
       grub_error (GRUB_ERR_UNKNOWN_DEVICE,
@@ -1542,7 +1545,32 @@
     free (name);
 
     if (! disk)
-      return 0;
+      {
+	/* We already know that the partition exists.  Given that we already
+	   checked the device map above, we can only get
+	   GRUB_ERR_UNKNOWN_DEVICE at this point if the disk does not exist.
+	   This can happen on Xen, where disk images in the host can be
+	   assigned to devices that have partition-like names in the guest
+	   but are really more like disks.  */
+	if (grub_errno == GRUB_ERR_UNKNOWN_DEVICE)
+	  {
+	    grub_util_info
+	      ("disk does not exist, so falling back to partition device %s",
+	       os_dev);
+
+	    drive = find_system_device (os_dev, &st, 0);
+	    if (drive < 0)
+	      {
+		grub_error (GRUB_ERR_UNKNOWN_DEVICE,
+			    "no mapping exists for `%s'", os_dev);
+		return 0;
+	      }
+
+	    return make_device_name (drive, -1, -1);
+	  }
+	else
+	  return 0;
+      }
 
     partname = NULL;
     grub_partition_iterate (disk, find_partition);
