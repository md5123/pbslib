Description: Adjust hostdisk id for hard disks
 This allows grub-setup to use its standard workaround for broken BIOSes.
Author: Colin Watson <cjwatson@ubuntu.com>
Bug: http://savannah.gnu.org/bugs/?29464
Bug-Ubuntu: https://bugs.launchpad.net/bugs/555500
Forwarded: http://savannah.gnu.org/bugs/?29464
Last-Update: 2010-04-08

Index: b/kern/emu/hostdisk.c
===================================================================
--- a/kern/emu/hostdisk.c
+++ b/kern/emu/hostdisk.c
@@ -223,6 +223,8 @@
 
   disk->has_partitions = 1;
   disk->id = drive;
+  if (strncmp (map[drive].drive, "hd", 2) == 0)
+    disk->id += 0x80;
   disk->data = data = xmalloc (sizeof (struct grub_util_biosdisk_data));
   data->dev = NULL;
   data->access_mode = 0;
@@ -571,9 +573,9 @@
 
     part_start = grub_partition_get_start (disk->partition);
 
-    strcpy (dev, map[disk->id].device);
+    strcpy (dev, map[disk->id & 0x7f].device);
     if (disk->partition && sector >= part_start
-	&& strncmp (map[disk->id].device, "/dev/", 5) == 0)
+	&& strncmp (map[disk->id & 0x7f].device, "/dev/", 5) == 0)
       is_partition = linux_find_partition (dev, part_start);
 
     if (data->dev && strcmp (data->dev, dev) == 0 &&
@@ -628,7 +630,7 @@
     }
 #endif
 
-  if (data->dev && strcmp (data->dev, map[disk->id].device) == 0 &&
+  if (data->dev && strcmp (data->dev, map[disk->id & 0x7f].device) == 0 &&
       data->access_mode == (flags & O_ACCMODE))
     {
       grub_dprintf ("hostdisk", "reusing open device `%s'\n", data->dev);
@@ -640,10 +642,10 @@
       if (data->fd != -1)
 	close (data->fd);
 
-      fd = open (map[disk->id].device, flags);
+      fd = open (map[disk->id & 0x7f].device, flags);
       if (fd >= 0)
 	{
-	  data->dev = xstrdup (map[disk->id].device);
+	  data->dev = xstrdup (map[disk->id & 0x7f].device);
 	  data->access_mode = (flags & O_ACCMODE);
 	  data->fd = fd;
 	}
@@ -661,12 +663,12 @@
 #if defined(__APPLE__)
   /* If we can't have exclusive access, try shared access */
   if (fd < 0)
-    fd = open(map[disk->id].device, flags | O_SHLOCK);
+    fd = open(map[disk->id & 0x7f].device, flags | O_SHLOCK);
 #endif
 
   if (fd < 0)
     {
-      grub_error (GRUB_ERR_BAD_DEVICE, "cannot open `%s' in open_device()", map[disk->id].device);
+      grub_error (GRUB_ERR_BAD_DEVICE, "cannot open `%s' in open_device()", map[disk->id & 0x7f].device);
       return -1;
     }
 #endif /* ! __linux__ */
@@ -688,7 +690,7 @@
     offset = (loff_t) sector << GRUB_DISK_SECTOR_BITS;
     if (_llseek (fd, offset >> 32, offset & 0xffffffff, &result, SEEK_SET))
       {
-	grub_error (GRUB_ERR_BAD_DEVICE, "cannot seek `%s'", map[disk->id].device);
+	grub_error (GRUB_ERR_BAD_DEVICE, "cannot seek `%s'", map[disk->id & 0x7f].device);
 	close (fd);
 	return -1;
       }
@@ -699,7 +701,7 @@
 
     if (lseek (fd, offset, SEEK_SET) != offset)
       {
-	grub_error (GRUB_ERR_BAD_DEVICE, "cannot seek `%s'", map[disk->id].device);
+	grub_error (GRUB_ERR_BAD_DEVICE, "cannot seek `%s'", map[disk->id & 0x7f].device);
 	close (fd);
 	return -1;
       }
@@ -797,7 +799,7 @@
 	 parts. -jochen  */
       if (nread (fd, buf, GRUB_DISK_SECTOR_SIZE) != GRUB_DISK_SECTOR_SIZE)
 	{
-	  grub_error (GRUB_ERR_READ_ERROR, "cannot read `%s'", map[disk->id].device);
+	  grub_error (GRUB_ERR_READ_ERROR, "cannot read `%s'", map[disk->id & 0x7f].device);
 	  close (fd);
 	  return grub_errno;
 	}
@@ -809,7 +811,7 @@
 
   if (nread (fd, buf, size << GRUB_DISK_SECTOR_BITS)
       != (ssize_t) (size << GRUB_DISK_SECTOR_BITS))
-    grub_error (GRUB_ERR_READ_ERROR, "cannot read from `%s'", map[disk->id].device);
+    grub_error (GRUB_ERR_READ_ERROR, "cannot read from `%s'", map[disk->id & 0x7f].device);
 
   return grub_errno;
 }
@@ -843,7 +845,7 @@
 
   if (nwrite (fd, buf, size << GRUB_DISK_SECTOR_BITS)
       != (ssize_t) (size << GRUB_DISK_SECTOR_BITS))
-    grub_error (GRUB_ERR_WRITE_ERROR, "cannot write to `%s'", map[disk->id].device);
+    grub_error (GRUB_ERR_WRITE_ERROR, "cannot write to `%s'", map[disk->id & 0x7f].device);
 
   return grub_errno;
 }
@@ -1634,5 +1636,5 @@
 const char *
 grub_util_biosdisk_get_osdev (grub_disk_t disk)
 {
-  return map[disk->id].device;
+  return map[disk->id & 0x7f].device;
 }
