Description: Fix LVM/RAID probing without device.map
 When probing LVM or RAID without a device.map, probe all devices in order
 that we will know about the underlying physical volumes.
Bug-Ubuntu: https://bugs.launchpad.net/bugs/525085
Forwarded: http://lists.gnu.org/archive/html/grub-devel/2010-03/msg00084.html
Last-Update: 2010-03-22

=== added file 'ChangeLog.lvm-raid-probe'
Index: b/ChangeLog.lvm-raid-probe
===================================================================
--- /dev/null
+++ b/ChangeLog.lvm-raid-probe
@@ -0,0 +1,16 @@
+2010-05-28  Colin Watson  <cjwatson@ubuntu.com>
+
+	* kern/emu/hostdisk.c (store_grub_dev): New function.
+	(grub_util_biosdisk_probe_device): New function.
+	* include/grub/emu/hostdisk.h (grub_util_biosdisk_probe_device):
+	Add prototype.
+	* util/grub-probe.c (probe): If we don't have a device map and the
+	requested device has an abstraction, probe all devices and
+	reinitialise abstraction modules.
+	(main): Pass device map to probe.
+	* util/i386/pc/grub-setup.c (main): If we don't have a device map,
+	probe all devices.
+	* util/sparc64/ieee1275/grub-setup.c (main): Likewise.
+	* conf/common.rmk (grub_probe_SOURCES): Add util/deviceiter.c.
+	* conf/i386-pc.rmk (grub_setup_SOURCES): Likewise.
+	* conf/sparc64-ieee1275.rmk (grub_setup_SOURCES): Likewise.
Index: b/conf/common.rmk
===================================================================
--- a/conf/common.rmk
+++ b/conf/common.rmk
@@ -26,6 +26,7 @@
 util/grub-probe.c_DEPENDENCIES = grub_probe_init.h
 grub_probe_SOURCES = gnulib/progname.c util/grub-probe.c	\
 	kern/emu/hostdisk.c util/misc.c kern/emu/misc.c kern/emu/getroot.c kern/emu/mm.c	\
+	util/deviceiter.c					\
 	kern/device.c kern/disk.c kern/err.c kern/misc.c	\
 	kern/partition.c kern/file.c kern/list.c	\
 	\
Index: b/conf/i386-pc.rmk
===================================================================
--- a/conf/i386-pc.rmk
+++ b/conf/i386-pc.rmk
@@ -65,6 +65,7 @@
 util/i386/pc/grub-setup.c_DEPENDENCIES = grub_setup_init.h
 grub_setup_SOURCES = gnulib/progname.c util/i386/pc/grub-setup.c	\
 	util/misc.c kern/emu/misc.c kern/emu/getroot.c			\
+	util/deviceiter.c						\
 	kern/emu/hostdisk.c kern/device.c kern/disk.c kern/err.c	\
 	kern/misc.c kern/partition.c kern/file.c			\
 	kern/emu/mm.c kern/fs.c kern/env.c kern/list.c fs/fshelp.c	\
Index: b/conf/sparc64-ieee1275.rmk
===================================================================
--- a/conf/sparc64-ieee1275.rmk
+++ b/conf/sparc64-ieee1275.rmk
@@ -48,8 +48,9 @@
 util/sparc64/ieee1275/grub-setup.c_DEPENDENCIES = grub_setup_init.h
 grub_setup_SOURCES = util/sparc64/ieee1275/grub-setup.c			\
 	util/ieee1275/ofpath.c util/misc.c kern/emu/hostdisk.c		\
-	kern/emu/misc.c kern/emu/getroot.c kern/emu/mm.c kern/device.c	\
-	kern/disk.c kern/err.c kern/misc.c 				\
+	kern/emu/misc.c kern/emu/getroot.c kern/emu/mm.c		\
+	util/deviceiter.c						\
+	kern/device.c kern/disk.c kern/err.c kern/misc.c 		\
 	kern/partition.c kern/file.c kern/fs.c kern/env.c kern/list.c	\
 	fs/fshelp.c							\
 									\
Index: b/include/grub/emu/hostdisk.h
===================================================================
--- a/include/grub/emu/hostdisk.h
+++ b/include/grub/emu/hostdisk.h
@@ -24,6 +24,7 @@
 
 void grub_util_biosdisk_init (const char *dev_map);
 void grub_util_biosdisk_fini (void);
+int grub_util_biosdisk_probe_device (const char *name, int is_floppy);
 char *grub_util_biosdisk_get_grub_dev (const char *os_dev);
 const char *grub_util_biosdisk_get_osdev (grub_disk_t disk);
 
Index: b/kern/emu/hostdisk.c
===================================================================
--- a/kern/emu/hostdisk.c
+++ b/kern/emu/hostdisk.c
@@ -1373,6 +1373,55 @@
   return i;
 }
 
+static void
+store_grub_dev (const char *grub_disk, const char *os_disk)
+{
+  unsigned int i;
+
+  for (i = 0; i < ARRAY_SIZE (map); i++)
+    if (! map[i].device)
+      break;
+    else if (strcmp (map[i].drive, grub_disk) == 0)
+      {
+	if (strcmp (map[i].device, os_disk) == 0)
+	  return;
+	grub_util_error (_("drive `%s' already mapped to `%s'"),
+			 map[i].drive, map[i].device);
+      }
+
+  if (i == ARRAY_SIZE (map))
+    grub_util_error (_("device count exceeds limit"));
+
+  map[i].drive = xstrdup (grub_disk);
+  map[i].device = xstrdup (os_disk);
+}
+
+static int num_hd = 0;
+static int num_fd = 0;
+
+int
+grub_util_biosdisk_probe_device (const char *name, int is_floppy)
+{
+  char *real_name;
+  char *grub_disk;
+
+  real_name = canonicalize_file_name (name);
+  if (! real_name)
+    return 0;
+
+  if (is_floppy)
+    grub_disk = xasprintf ("fd%d", num_fd++);
+  else
+    grub_disk = xasprintf ("hd%d", num_hd++);
+
+  store_grub_dev (grub_disk, real_name);
+
+  free (grub_disk);
+  free (real_name);
+
+  return 0;
+}
+
 char *
 grub_util_biosdisk_get_grub_dev (const char *os_dev)
 {
Index: b/util/grub-probe.c
===================================================================
--- a/util/grub-probe.c
+++ b/util/grub-probe.c
@@ -29,6 +29,7 @@
 #include <grub/msdos_partition.h>
 #include <grub/emu/hostdisk.h>
 #include <grub/emu/getroot.h>
+#include <grub/util/deviceiter.h>
 #include <grub/term.h>
 #include <grub/env.h>
 #include <grub/raid.h>
@@ -110,13 +111,14 @@
 }
 
 static void
-probe (const char *path, char *device_name)
+probe (const char *path, char *device_name, const char *dev_map)
 {
   char *drive_name = NULL;
   char *grub_path = NULL;
   char *filebuf_via_grub = NULL, *filebuf_via_sys = NULL;
   grub_device_t dev = NULL;
   grub_fs_t fs;
+  struct stat dev_map_stat;
 
   if (path == NULL)
     {
@@ -140,6 +142,22 @@
       goto end;
     }
 
+  if (stat (dev_map, &dev_map_stat) == -1 &&
+      grub_util_get_dev_abstraction (device_name) != GRUB_DEV_ABSTRACTION_NONE)
+    {
+      /* If we don't have a device map, then we won't yet know about the
+         physical volumes underlying this device, so probe all devices.  */
+      grub_util_iterate_devices (grub_util_biosdisk_probe_device, 0);
+
+      /* Now reinitialise the higher layers.  */
+      grub_lvm_fini ();
+      grub_mdraid_fini ();
+      grub_raid_fini ();
+      grub_raid_init ();
+      grub_mdraid_init ();
+      grub_lvm_init ();
+    }
+
   drive_name = grub_util_get_grub_dev (device_name);
   if (! drive_name)
     grub_util_error ("cannot find a GRUB drive for %s.  Check your device.map", device_name);
@@ -444,9 +462,9 @@
 
   /* Do it.  */
   if (argument_is_device)
-    probe (NULL, argument);
+    probe (NULL, argument, dev_map ? : DEFAULT_DEVICE_MAP);
   else
-    probe (argument, NULL);
+    probe (argument, NULL, dev_map ? : DEFAULT_DEVICE_MAP);
 
   /* Free resources.  */
   grub_fini_all ();
Index: b/util/i386/pc/grub-setup.c
===================================================================
--- a/util/i386/pc/grub-setup.c
+++ b/util/i386/pc/grub-setup.c
@@ -36,6 +36,7 @@
 #include <grub/util/raid.h>
 #include <grub/util/lvm.h>
 #include <grub/emu/getroot.h>
+#include <grub/util/deviceiter.h>
 
 static const grub_gpt_part_type_t grub_gpt_partition_type_bios_boot = GRUB_GPT_PARTITION_TYPE_BIOS_BOOT;
 
@@ -684,6 +685,7 @@
   char *core_file = 0;
   char *dir = 0;
   char *dev_map = 0;
+  struct stat dev_map_stat;
   char *root_dev = 0;
   char *dest_dev;
   int must_embed = 0, force = 0, fs_probe = 1;
@@ -782,6 +784,9 @@
   /* Initialize the emulated biosdisk driver.  */
   grub_util_biosdisk_init (dev_map ? : DEFAULT_DEVICE_MAP);
 
+  if (stat (dev_map ? : DEFAULT_DEVICE_MAP, &dev_map_stat) == -1)
+    grub_util_iterate_devices (grub_util_biosdisk_probe_device, 0);
+
   /* Initialize all modules. */
   grub_init_all ();
 
Index: b/util/sparc64/ieee1275/grub-setup.c
===================================================================
--- a/util/sparc64/ieee1275/grub-setup.c
+++ b/util/sparc64/ieee1275/grub-setup.c
@@ -47,6 +47,7 @@
 #include <sys/stat.h>
 #include <dirent.h>
 #include <grub/emu/getroot.h>
+#include <grub/util/deviceiter.h>
 
 #define _GNU_SOURCE	1
 #include <getopt.h>
@@ -618,6 +619,7 @@
 main (int argc, char *argv[])
 {
   struct grub_setup_info ginfo;
+  struct stat dev_map_stat;
 
   set_program_name (argv[0]);
 
@@ -630,6 +632,9 @@
   /* Initialize the emulated biosdisk driver.  */
   grub_util_biosdisk_init (ginfo.dev_map ? ginfo.dev_map : DEFAULT_DEVICE_MAP);
 
+  if (stat (ginfo.dev_map ? : DEFAULT_DEVICE_MAP, &dev_map_stat) == -1)
+    grub_util_iterate_devices (grub_util_biosdisk_probe_device, 0);
+
   /* Initialize all modules. */
   grub_init_all ();
 
