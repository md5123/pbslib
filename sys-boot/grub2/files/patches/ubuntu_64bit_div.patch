Description: Complete 64-bit division support
 Needed to support ubuntu_btrfs_huge_chunk.patch.
Author: Vladimir Serbinenko <phcoder@gmail.com>
Forwarded: yes
Applied-Upstream: http://bazaar.launchpad.net/~vcs-imports/grub/grub2-bzr/revision/3221
Last-Update: 2011-04-20

Index: b/grub-core/kern/misc.c
===================================================================
--- a/grub-core/kern/misc.c
+++ b/grub-core/kern/misc.c
@@ -597,23 +597,23 @@
 
 /* Divide N by D, return the quotient, and store the remainder in *R.  */
 grub_uint64_t
-grub_divmod64 (grub_uint64_t n, grub_uint32_t d, grub_uint32_t *r)
+grub_divmod64_full (grub_uint64_t n, grub_uint64_t d, grub_uint64_t *r)
 {
   /* This algorithm is typically implemented by hardware. The idea
      is to get the highest bit in N, 64 times, by keeping
-     upper(N * 2^i) = upper((Q * 10 + M) * 2^i), where upper
+     upper(N * 2^i) = (Q * D + M), where upper
      represents the high 64 bits in 128-bits space.  */
   unsigned bits = 64;
-  unsigned long long q = 0;
-  unsigned m = 0;
+  grub_uint64_t q = 0;
+  grub_uint64_t m = 0;
 
   /* Skip the slow computation if 32-bit arithmetic is possible.  */
-  if (n < 0xffffffff)
+  if (n < 0xffffffff && d < 0xffffffff)
     {
       if (r)
-	*r = ((grub_uint32_t) n) % d;
+	*r = ((grub_uint32_t) n) % (grub_uint32_t) d;
 
-      return ((grub_uint32_t) n) / d;
+      return ((grub_uint32_t) n) / (grub_uint32_t) d;
     }
 
   while (bits--)
Index: b/include/grub/misc.h
===================================================================
--- a/include/grub/misc.h
+++ b/include/grub/misc.h
@@ -287,8 +287,20 @@
 char *EXPORT_FUNC(grub_xvasprintf) (const char *fmt, va_list args) __attribute__ ((warn_unused_result));
 void EXPORT_FUNC(grub_exit) (void) __attribute__ ((noreturn));
 void EXPORT_FUNC(grub_abort) (void) __attribute__ ((noreturn));
-grub_uint64_t EXPORT_FUNC(grub_divmod64) (grub_uint64_t n,
-					  grub_uint32_t d, grub_uint32_t *r);
+grub_uint64_t EXPORT_FUNC(grub_divmod64_full) (grub_uint64_t n,
+					       grub_uint64_t d,
+					       grub_uint64_t *r);
+static inline grub_uint64_t grub_divmod64 (grub_uint64_t n,
+					   grub_uint32_t d,
+					   grub_uint32_t *r)
+{
+  grub_uint64_t ret, rr;
+  
+  ret = grub_divmod64_full (n, d, &rr);
+  if (r)
+    *r = rr;
+  return ret;
+}
 
 #if NEED_ENABLE_EXECUTE_STACK && !defined(GRUB_UTIL)
 void EXPORT_FUNC(__enable_execute_stack) (void *addr);
