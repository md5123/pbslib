diff -Nurb likewise-open-6.0.0.53010.old/git-build/build/components/lwconfig.comp likewise-open-6.0.0.53010/git-build/build/components/lwconfig.comp
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/git-build/build/components/lwconfig.comp	2011-02-24 10:56:55.000000000 -0800
@@ -0,0 +1,82 @@
+#!/bin/sh
+
+COMP_NAME="lwconfig"
+COMP_SOURCES="${BUILD_ROOT}/${COMP_NAME}"
+
+
+function _setup_build_env
+{
+    set_compiler_env
+
+    cd ${COMP_SOURCES}/.
+    exit_on_error $?
+
+    CPPFLAGS="${_cppflags} -I/usr/include/libxml2"
+    CFLAGS="${_cflags}"
+    LDFLAGS="${_ldflags}"
+
+    export PATH CPPFLAGS LDFLAGS CFLAGS CC
+}
+
+function component_configure
+{
+    _setup_build_env
+
+    run_autogen ${COMP_SOURCES}
+    exit_on_error $?
+
+    ./configure                          \
+	--prefix=${PREFIXDIR}            \
+        --libdir=${PREFIXDIR}/${_lib}    \
+        --localstatedir=${LOCALSTATEDIR} \
+	--sysconfdir=${SYSCONFDIR}
+    exit_on_error $?
+}
+
+function component_build
+{
+    _setup_build_env
+
+    ${MAKE} ${_mflags} all
+}
+
+function component_install
+{
+    _setup_build_env
+
+    local INSTALL_ROOT="${STAGE_COMP_DIR}/${COMP_NAME}"
+
+    [ "$INSTALL_ROOT" != "/" ] && rm -rf $INSTALL_ROOT
+    mkdir -p ${INSTALL_ROOT}
+    mkdir -p ${STAGE_INSTALL_DIR}
+
+    ${MAKE} DESTDIR=${INSTALL_ROOT} install
+
+    rsync -a ${INSTALL_ROOT}/ ${STAGE_INSTALL_DIR}/
+
+    libtool_rewrite_staging
+}
+
+function component_populate
+{
+    local INSTALL_ROOT="${STAGE_COMP_DIR}/${COMP_NAME}"
+    local INSTALL_PREFIX_DIR="${INSTALL_ROOT}/${PREFIXDIR}"
+    local STAGING_PREFIX_DIR="${STAGE_INSTALL_DIR}/${PREFIXDIR}"
+    local STAGING_SYSCONF_DIR="${STAGE_INSTALL_DIR}/${SYSCONFDIR}"
+
+    local POPULATE_DIR="$1"
+    local EXCLUDE_FILE="${POPULATE_DIR}/../exclude.files"
+
+    if [ -z "${POPULATE_DIR}" ] || [ ! -d "${POPULATE_DIR}" ]; then
+	echo "Non-existent or invalid populate dircetory given: ${POPULATE_DIR}"
+	return 1
+    fi
+
+    cat <<EOF > ${EXCLUDE_FILE}
+share
+*.a
+*.la
+EOF
+
+    rsync -a --exclude-from=${EXCLUDE_FILE} ${INSTALL_ROOT}/ ${POPULATE_DIR}/
+}
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/autogen.sh likewise-open-6.0.0.53010/lwconfig/autogen.sh
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/autogen.sh	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,2 @@
+#!/bin/sh
+autoreconf -fi
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/configure.ac likewise-open-6.0.0.53010/lwconfig/configure.ac
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/configure.ac	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,187 @@
+AC_PREREQ(2.59)
+AC_INIT(lwconfig, 5.4, support@likewise.com)
+AC_CANONICAL_TARGET
+AM_INIT_AUTOMAKE([-Wall -Werror foreign])
+AC_CONFIG_HEADERS([include/config.h])
+AC_CONFIG_MACRO_DIR(m4])
+
+AM_CPPFLAGS=""
+AM_CFLAGS=""
+AM_LDFLAGS=""
+
+default_skeldirs="/etc/skel"
+default_homedir_prefix="/home"
+enable_nss_enum_default="false"
+
+case "$host_os:$host_cpu" in
+    linux*:*)
+        AC_DEFINE([__LWI_LINUX___], [], [Defined if OS is Linux])
+        ;;
+    solaris*:*)
+        AC_DEFINE([__LWI_SOLARIS__], [], [Define if OS is Solaris])
+        ;;
+    darwin*:*)
+        default_skeldirs="System/LibraryUser Template/Non_localized, /System/Library/User Template/English.lproj"
+        default_homedir_prefix="/Users"
+        enable_nss_enum_default="true"
+        AC_DEFINE([__LWI_DARWIN__], [], [Define if OS is Darwin])
+        ;;
+    freebsd*:*)
+        AC_DEFINE([__LWI_FREEBSD__], [], [Define if OS is FreeBSD])
+        ;;
+    hpux*:hppa*)
+        AC_DEFINE([__LWI_HP_UX__], [], [Define if OS is HP-UX])
+        AC_DEFINE([_XOPEN_SOURCE_EXTENDED], [1], [Define on HP-UX])
+        ;;
+    hpux*:ia64*)
+        AC_DEFINE([__LWI_HP_UX__], [], [Define if OS is HP-UX])
+        AC_DEFINE([_XOPEN_SOURCE_EXTENDED], [1], [Define on HP-UX])
+        ;;
+    aix*:*)
+        AC_DEFINE([__LWI_AIX__], [], [Define if OS is AIX])
+        AC_DEFINE([_LINUX_SOURCE_COMPAT], [], [Enable Linux source compatibility on AIX])
+        ;;
+esac
+
+AC_SUBST(default_skeldirs)
+AC_SUBST(default_homedir_prefix)
+AC_SUBST(enable_nss_enum_default)
+
+# debugging
+
+AC_ARG_ENABLE([debug],
+        [AC_HELP_STRING([--enable-debug], [enable debugging (default: disabled)])],
+        [
+                if test x"$enableval" = x"yes"
+                then
+                    AM_CFLAGS="$AM_CFLAGS -g -O0"
+                    AM_CPPFLAGS="$AM_CPPFLAGS -DDEBUG"
+                fi
+        ])
+
+AC_ARG_WITH([lwadvapi],
+            [AC_HELP_STRING([--with-lwadvapi=<dir>], [use lwadvapi located in prefix <dir>])],
+            [
+                LWADVAPI_INCLUDES="-I$withval/include"
+                LWADVAPI_LDFLAGS="-L$withval/lib"
+            ])
+AC_ARG_WITH([lwadvapi-includes],
+            [AC_HELP_STRING([--with-lwadvapi-includes=<dir>], [use lwadvapi includes located in <dir>])],
+            [
+             LWADVAPI_INCLUDES="-I$withval"
+            ])
+AC_ARG_WITH([lwadvapi-libs],
+            [AC_HELP_STRING([--with-lwadvapi-libs=<dir>], [use lwadvapi libs located in <dir>])],
+            [
+             LWADVAPI_LDFLAGS="-L$withval"
+             ])
+
+LWADVAPI_LIBS="-llwadvapi"
+LWADVAPI_NOTHR_LIBS="-llwadvapi_nothr"
+
+AC_SUBST(LWADVAPI_INCLUDES)
+AC_SUBST(LWADVAPI_LDFLAGS)
+AC_SUBST(LWADVAPI_LIBS)
+AC_SUBST(LWADVAPI_NOTHR_LIBS)
+
+# lwbase
+
+AC_ARG_WITH([lwbase],
+        [AC_HELP_STRING([--with-lwbase=<dir>], [use lwbase located in prefix <dir>])],
+        [
+        LWBASE_INCLUDES="-I$withval/include"
+        LWBASE_LDFLAGS="-L$withval/lib"
+        ])
+
+AC_ARG_WITH([lwbase-includes],
+        [AC_HELP_STRING([--with-lwbase-includes=<dir>], [use lwbase includes located in <dir>])],
+        [
+        LWBASE_INCLUDES="-I$withval"
+        ])
+
+AC_ARG_WITH([lwbase-libs],
+        [AC_HELP_STRING([--with-lwbase-libs=<dir>], [use lwbase libs located in <dir>])],
+        [
+        LWBASE_LDFLAGS="-L$withval"
+        ])
+LWBASE_LIBS=-llwbase
+
+AC_SUBST(LWBASE_INCLUDES)
+AC_SUBST(LWBASE_LDFLAGS)
+AC_SUBST(LWBASE_LIBS)
+
+
+# lwreg
+
+AC_ARG_WITH([lwreg],
+        [AC_HELP_STRING([--with-lwreg=<dir>], [use lwreg located in prefix <dir>])],
+        [
+        LWREG_INCLUDES="-I$withval/include"
+        LWREG_LDFLAGS="-L$withval/lib"
+        ])
+
+AC_ARG_WITH([lwreg-includes],
+        [AC_HELP_STRING([--with-lwreg-includes=<dir>], [use lwreg includes located in <dir>])],
+        [
+        LWREG_INCLUDES="-I$withval"
+        ])
+
+AC_ARG_WITH([lwreg-libs],
+        [AC_HELP_STRING([--with-lwreg-libs=<dir>], [use lwreg libs located in <dir>])],
+        [
+        LWREG_LDFLAGS="-L$withval"
+        ])
+
+LWREG_LIBS=-lregclient
+
+AC_SUBST(LWREG_INCLUDES)
+AC_SUBST(LWREG_LDFLAGS)
+AC_SUBST(LWREG_LIBS)
+
+XML2_INCLUDES=""
+XML2_LDFLAGS=""
+XML2_LIBS="-lxml2"
+AC_SUBST(XML2_INCLUDES)
+AC_SUBST(XML2_LDFLAGS)
+AC_SUBST(XML2_LIBS)
+
+if test x"$localstatedir" = x"/var"; then
+    lwconfigdir="$localstatedir/lib/likewise"
+else
+    lwconfigdir="$localstatedir"
+fi
+AC_SUBST(lwconfigdir)
+AC_DEFINE_UNQUOTED(LWCONFIG_XML, "${lwconfigdir}/lwconfig.xml", "Path to lwconfig.xml")
+
+# Checks for library functions
+AC_FUNC_MALLOC
+AC_CHECK_FUNCS([strndup strncasecmp strtoul strtoll __strtoll])
+
+# Checks for header files.
+AC_CHECK_HEADERS([string.h strings.h sys/types.h sys/varargs.h])
+
+CPPFLAGS="$CPPFLAGS -D_REENTRANT -D_GNU_SOURCE"
+
+AM_CPPFLAGS="$AM_CPPFLAGS -I${top_srcdir}/include"
+AM_CFLAGS="$AM_CFLAGS -Wall -Werror -fno-strict-aliasing"
+
+AC_SUBST(AM_CPPFLAGS)
+AC_SUBST(AM_CFLAGS)
+AC_SUBST(AM_LDFLAGS)
+
+# Checks for programs.
+AC_PROG_CC
+AC_PROG_LIBTOOL
+
+# Checks for typedefs, structures, and compiler characteristics.
+AC_C_BIGENDIAN
+
+# Checks for library functions.
+AC_HEADER_STDC
+
+AC_CONFIG_FILES([Makefile
+                 etc/Makefile
+                 etc/lwconfig.xml
+                 src/Makefile])
+
+AC_OUTPUT
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/COPYING-GPL likewise-open-6.0.0.53010/lwconfig/COPYING-GPL
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/COPYING-GPL	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,339 @@
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+ 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License along
+    with this program; if not, write to the Free Software Foundation, Inc.,
+    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) year name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/etc/lwconfig.xml.in likewise-open-6.0.0.53010/lwconfig/etc/lwconfig.xml.in
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/etc/lwconfig.xml.in	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,721 @@
+<?xml version="1.0" encoding="utf-8"?> <capabilities>
+<section section="Eventlog">
+
+    <capability>
+        <name>AllowDeleteTo</name>
+        <description>List of users that can delete entries from log</description>
+        <registry
+            type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\eventlog\Parameters\AllowDeleteTo"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\eventlog\Parameters\AllowDeleteTo"
+            >
+
+            <description>A list of user names, group names, or SIDS separated by commas.</description>
+            <default><value></value></default>
+            <apply command="/usr/bin/lwsm restart eventlog" />
+        </registry>
+    </capability>
+
+    <capability>
+        <name>AllowReadTo</name>
+        <description>Allowed users that can read entries from log</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\eventlog\Parameters\AllowReadTo"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\eventlog\Parameters\AllowReadTo">
+            <description>A list of user names, group names, or SIDS separated by commas.</description>
+            <default>
+                <value></value>
+            </default>
+            <apply command="/usr/bin/lwsm restart eventlog" />
+        </registry>
+    </capability>
+
+    <capability>
+        <name>AllowWriteTo</name>
+        <description>Allowed users that can delete entries from log</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\eventlog\Parameters\AllowWriteTo"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\eventlog\Parameters\AllowWriteTo" >
+            <description>A list of user names, group names, or SIDS separated by commas.</description>
+            <default>
+                <value></value>
+            </default>
+            <apply command="/usr/bin/lwsm restart eventlog" />
+        </registry>
+    </capability>
+    <capability>
+        <name>MaxDiskUsage</name>
+        <description>Max size in bytes of eventlog database</description>
+        <registry type="dword"
+            lp-path="HKEY_THIS_MACHINE\Services\eventlog\Parameters\MaxDiskUsage"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\eventlog\Parameters\MaxDiskUsage" >
+            <description>Size in bytes</description>
+            <default>
+                <value>100MB</value>
+            </default>
+            <accept>
+                <range min="100" max="2147483648" />
+            </accept>
+            <unit suffix="B"  multiplier="1" />
+            <unit suffix="KB" multiplier="1024" />
+            <unit suffix="MB" multiplier="1048576" />
+            <apply command="/usr/bin/lwsm restart eventlog" />
+        </registry>
+    </capability>
+    <capability>
+        <name>MaxEventLifespan</name>
+        <description>Maximum number of days that events are saved in eventlog</description>
+        <registry type="dword"
+            lp-path="HKEY_THIS_MACHINE\Services\eventlog\Parameters\MaxEventLifespan"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\eventlog\Parameters\MaxEventLifespan" >
+            <description>days</description>
+            <default>
+                <value>90</value>
+            </default>
+            <accept>
+                <range min="1" max="365" />
+            </accept>
+            <apply command="/usr/bin/lwsm restart eventlog" />
+        </registry>
+    </capability>
+    <capability>
+        <name>MaxNumEvents</name>
+        <description>Maximum number of events to hold in eventlog database</description>
+        <registry type="dword"
+            lp-path="HKEY_THIS_MACHINE\Services\eventlog\Parameters\MaxNumEvents"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\eventlog\Parameters\MaxNumEvents" >
+            <description>number of events</description>
+            <default>
+                <value>100000</value>
+            </default>
+            <accept>
+                <range min="100" max="2000000" />
+            </accept>
+            <apply command="/usr/bin/lwsm restart eventlog" />
+        </registry>
+    </capability>
+  </section>
+<section section="Lsass">
+    <capability>
+        <name>DomainSeparator</name>
+        <description>Character used to designate the domain name separator</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\DomainSeparator"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\DomainSeparator" >
+            <description>A single character this is not alphanumeric or the SpaceReplacement character.</description>
+            <default>
+                <value>\</value>
+            </default>
+            <reject>
+                <pattern>..+</pattern>
+                <pattern>[a-zA-Z0-9]</pattern>
+            </reject>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>SpaceReplacement</name>
+        <description>Character used to designate space characters in names of objects</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\SpaceReplacement"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\SpaceReplacement" >
+            <description>A single character used in place of spaces in names of objects</description>
+            <default>
+                <value>^</value>
+            </default>
+            <reject>
+                <pattern>..+</pattern>
+                <pattern>[a-zA-Z0-9]</pattern>
+            </reject>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>EnableEventlog</name>
+        <description>Configure lsass to log events to the event log</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\EnableEventLog"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\EnableEventLog" >
+            <default>
+                <value>false</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>LogInvalidPasswords</name>
+        <description>Configure lsass to log events for failed authentication attempts due to invalid passwords</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\LogInvalidPasswords"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\LogInvalidPasswords" >
+            <default>
+                <value>false</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+</section>
+<section section="Lsass - PAM">
+    <capability>
+        <name>DisplayMotd</name>
+        <description>Display message of the day</description>
+            <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\PAM\DisplayMotd"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\PAM\DisplayMotd" >
+                <default>
+                    <value>false</value>
+                </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>PAMLogLevel</name>
+        <description>Configure PAM lsass logging detail level</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\PAM\LogLevel"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\PAM\LogLevel" >
+            <default>
+                <value>error</value>
+            </default>
+            <accept>
+                <value>disabled</value>
+                <value>error</value>
+                <value>warning</value>
+                <value>info</value>
+                <value>verbose</value>
+            </accept>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>UserNotAllowedError</name>
+        <description>Message displayed at console logon failed attempt</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\PAM\UserNotAllowedError"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\PAM\UserNotAllowedError" >
+            <description>Not allowed error</description>
+            <default>
+                <value>Access Denied</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+</section>
+<section section="Lsass - Active Directory provider">
+    <capability>
+        <name>AssumeDefaultDomain</name>
+        <description>Apply domain name prefix to account name at logon</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\AssumeDefaultDomain"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\AssumeDefaultDomain" >
+            <default>
+                <value>false</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>CreateHomeDir</name>
+        <description>Whether home directories should be automatically created upon user logon</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\CreateHomeDir"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\CreateHomeDir" >
+            <default>
+                <value>true</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>CreateK5Login</name>
+        <description>Whether .k5login file is to be created upon user logon</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\CreateK5Login"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\CreateK5Login" >
+            <default>
+                <value>true</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>SyncSystemTime</name>
+        <description>Whether system time should be syncronized with AD domain controller</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\SyncSystemTime"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\SyncSystemTime" >
+            <default>
+                <value>true</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>TrimUserMembership</name>
+        <description>Whether to remove a cached group membership entry derived from PAC with information from LDAP showing the user disappearing from a group.</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\TrimUserMembership"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\TrimUserMembership" >
+            <default>
+                <value>true</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>LdapSignAndSeal</name>
+        <description>Whether all LDAP traffic should be sent both signed and sealed</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\LdapSignAndSeal"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\LdapSignAndSeal" >
+            <default>
+                <value>false</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+      <name>LogADNetworkConnectionEvents</name>
+      <description>Configure lsass to log events for offline query failures and transitions</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\LogNetworkConnectionEvents"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\LogNetworkConnectionEvents" >
+            <default>
+                <value>true</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+      <name>NssEnumerationEnabled</name>
+      <description>Whether to enumerate users or groups for NSS</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\NssEnumerationEnabled"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\NssEnumerationEnabled" >
+            <default>
+                <value>@enable_nss_enum_default@</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>NssGroupMembersQueryCacheOnly</name>
+        <description>Whether to return only cached info for NSS group members</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\NssGroupMembersQueryCacheOnly"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\NssGroupMembersQueryCacheOnly" >
+            <default>
+                <value>true</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>NssUserMembershipQueryCacheOnly</name>
+        <description>Whether to return only cached info for NSS user's groups</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\NssUserMembershipQueryCacheOnly"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\NssUserMembershipQueryCacheOnly" >
+            <default>
+                <value>false</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>RefreshUserCredentials</name>
+        <description>Whether to refresh user credentials agaist AD domain controller</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\RefreshUserCredentials"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\RefreshUserCredentials" >
+            <default>
+                <value>true</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>CacheEntryExpiry</name>
+        <description>Duration for when lsass object cache entries are marked stale</description>
+        <registry type="dword"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\CacheEntryExpiry"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\CacheEntryExpiry" >
+            <description>Duration in seconds (s), minutes (m), hours (h) or days (d)</description>
+            <default>
+                <value>4h</value>
+            </default>
+            <accept>
+                <range min="0" max="86400" />
+            </accept>
+            <unit suffix="s" multiplier="1" />
+            <unit suffix="m" multiplier="60" />
+            <unit suffix="h" multiplier="3600" />
+            <unit suffix="d" multiplier="86400" />
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>TrustEnumerationWait</name>
+        <description>If true, wait for trust enumeration to complete before completing initialization.</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\TrustEnumerationWait"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\TrustEnumerationWait" >
+            <default>
+                <value>false</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>TrustEnumerationWaitSeconds</name>
+        <description>If TrustEnumerationWait is true, the amount of time to wait for trust enumeration to complete before continuing. Use 0 to wait forever.  </description>
+        <registry type="dword"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\TrustEnumerationWaitSeconds"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\TrustEnumerationWaitSeconds" >
+            <description>Duration in seconds (s), minutes (m), hours (h) or days (d)</description>
+            <default>
+                <value>0s</value>
+            </default>
+            <accept>
+                <range min="0" max="86400" />
+            </accept>
+            <unit suffix="s" multiplier="1" />
+            <unit suffix="m" multiplier="60" />
+            <unit suffix="h" multiplier="3600" />
+            <unit suffix="d" multiplier="86400" />
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>DomainManagerCheckDomainOnlineInterval</name>
+        <description>How often the domain manager should check whether a domain is back online</description>
+        <registry type="dword"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\DomainManagerCheckDomainOnlineInterval"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\DomainManagerCheckDomainOnlineInterval" >
+            <description>Duration in seconds (s), minutes (m), hours (h) or days (d)</description>
+            <default>
+                <value>5m</value>
+            </default>
+            <accept>
+                <range min="60" max="86400" />
+            </accept>
+            <unit suffix="s" multiplier="1" />
+            <unit suffix="m" multiplier="60" />
+            <unit suffix="h" multiplier="3600" />
+            <unit suffix="d" multiplier="86400" />
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>DomainManagerUnknownDomainCacheTimeout</name>
+        <description>How long an unknown domain is cached as unknown in the domain manager</description>
+        <registry type="dword"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\DomainManagerUnknownDomainCacheTimeout"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\DomainManagerUnknownDomainCacheTimeout" >
+            <description>Duration in seconds (s), minutes (m), hours (h) or days (d)</description>
+            <default>
+               <value>1h</value>
+            </default>
+            <accept>
+               <range min="60" max="86400" />
+            </accept>
+            <unit suffix="s" multiplier="1" />
+            <unit suffix="m" multiplier="60" />
+            <unit suffix="h" multiplier="3600" />
+            <unit suffix="d" multiplier="86400" />
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>MachinePasswordLifespan</name>
+        <description>Machine password expiration lifespan in seconds.</description>
+        <registry type="dword"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\MachinePasswordLifespan"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\MachinePasswordLifespan" >
+            <description>Duration in seconds (s), minutes (m), hours (h) or days (d). Example: 1d</description>
+            <default>
+                <value>30d</value>
+            </default>
+            <accept>
+                <range min="3600" max="31536000" />
+            </accept>
+            <accept>
+                <range min="0" max="0" />
+            </accept>
+            <unit suffix="s" multiplier="1" />
+            <unit suffix="m" multiplier="60" />
+            <unit suffix="h" multiplier="3600" />
+            <unit suffix="d" multiplier="86400" />
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>MemoryCacheSizeCap</name>
+        <description>The maximum bytes to use for the in-memory cache. Old data will be purged if the total cache size exceeds this limit. A value of 0 indicates no limit.</description>
+        <registry type="dword"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\MemoryCacheSizeCap"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\MemoryCacheSizeCap" >
+            <description>Size in bytes</description>
+            <default>
+                <value>0</value>
+            </default>
+            <unit suffix="B"  multiplier="1" />
+            <unit suffix="KB" multiplier="1024" />
+            <unit suffix="MB" multiplier="1048576" />
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>HomeDirPrefix</name>
+        <description>Prefix path for user's home directory. This value is used in place of the %H in the HomeDirTemplate setting. Value must be an absolute path.</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\HomeDirPrefix"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\HomeDirPrefix" >
+            <description>Absolute path to the home directory.</description>
+            <default>
+                <value>@default_homedir_prefix@</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>HomeDirTemplate</name>
+        <description>Format string for user's home directory path. This value can contain substitution string markers for HomeDirPrefix (%H), Domain (%D), and User (%U).</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\HomeDirTemplate"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\HomeDirTemplate" >
+            <description>Absolute path to the home directory.</description>
+            <default>
+                <value>%H/local/%D/%U</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>HomeDirUmask</name>
+        <description>Umask for home directories</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\HomeDirUmask"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\HomeDirUmask" >
+            <description>String of octal digits for home directory umask</description>
+            <default>
+                <value>022</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>LoginShellTemplate</name>
+        <description>Default login shell template</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\LoginShellTemplate"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\LoginShellTemplate" >
+            <description>Path to shell</description>
+            <default>
+                <value>/bin/sh</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>SkeletonDirs</name>
+        <description>Skeleton home directory template directories</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\SkeletonDirs"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\SkeletonDirs" >
+            <description>Comma separated list of skeleton directories.</description>
+            <default>
+                <value>@default_skeldirs@</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>UserDomainPrefix</name>
+        <description>Domain short name prefix to be used when AssumeDefaultDomain setting is enabled</description>
+      <Allowed>Domain short name of Active Directory domain that the user accounts reside. Blank will use the domain name which the computer is joined to.</Allowed>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\UserDomainPrefix"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\UserDomainPrefix" >
+            <description>Short name of Active Directory domain where the user accounts reside. Blank means use the domain name to which the computer is joined.</description>
+            <default>
+                <value></value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+            <apply command="/usr/bin/lw-ad-cache --delete-all" />
+        </registry>
+    </capability>
+    <capability>
+        <name>DomainManagerIgnoreAllTrusts</name>
+        <description>When true, ignore all trusts during domain enumeration.</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\DomainManagerIgnoreAllTrusts"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\DomainManagerIgnoreAllTrusts" >
+            <default>
+                <value>false</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>DomainManagerIncludeTrustsList</name>
+        <description>When DomainManagerIgnoreAllTrusts is true, these trusts are included</description>
+        <registry type="multistring"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\DomainManagerIncludeTrustsList"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\DomainManagerIncludeTrustsList" >
+            <description>A list of trusts.</description>
+            <default>
+                <value></value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>DomainManagerExcludeTrustsList</name>
+        <description>When DomainManagerIgnoreAllTrusts is false, these trusts are excluded.</description>
+        <registry type="multistring"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\DomainManagerExcludeTrustsList"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\DomainManagerExcludeTrustsList" >
+            <description>A list of trusts.</description>
+            <default>
+                <value></value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>RequireMembershipOf</name>
+        <description>Restrict logon access to computer to specific users or group members, or SIDs</description>
+        <registry type="multistring"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\ActiveDirectory\RequireMembershipOf"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\ActiveDirectory\RequireMembershipOf" >
+            <description>User names, group names, or SIDs.</description>
+            <default>
+                <value></value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+</section>
+<section section="Lsass - Local provider">
+    <capability>
+        <name>Local_AcceptNTLMv1</name>
+        <description></description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\Local\AcceptNTLMv1"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\Local\AcceptNTLMv1" >
+            <default>
+                <value>true</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>Local_HomeDirTemplate</name>
+        <description>Format string for lsass local provider account user's home directory path. This value can contain substitution string markers for HomeDirPrefix (%H), Domain (%D), and User (%U).</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\Local\HomeDirTemplate"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\Local\HomeDirTemplate" >
+            <description>Absolute path to the home directory.</description>
+            <default>
+                <value>%H/local/%D/%U</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>Local_HomeDirUmask</name>
+        <description>Umask for lsass local provider account home directories</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\Local\HomeDirUmask"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\Local\HomeDirUmask" >
+            <description>Absolute path to the home directory.</description>
+            <default>
+                <value>022</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>Local_LoginShellTemplate</name>
+        <description>Default login shell template for lsass local provider accounts</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\Local\LoginShellTemplate"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\Local\LoginShellTemplate" >
+            <description>Absolute path to the home directory.</description>
+            <default>
+                <value>/bin/sh</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+    <capability>
+        <name>Local_SkeletonDirs</name>
+        <description>Skeleton home directory template directories for lsass local provider accounts</description>
+        <registry type="string"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Parameters\Providers\Local\SkeletonDirs"
+            gp-path="HKEY_THIS_MACHINE\Policy\Services\lsass\Parameters\Providers\Local\SkeletonDirs" >
+            <description>Absolute path to the home directory.</description>
+            <default>
+                <value>@default_skeldirs@</value>
+            </default>
+            <apply command="/usr/bin/lwsm refresh lsass" />
+        </registry>
+    </capability>
+  </section>
+  <section section="System Initialization">
+    <capability>
+        <name>LsassAutostart</name>
+        <description>Start lsassd when lwsmd starts.</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\lsass\Autostart" >
+            <default>
+                <value>true</value>
+            </default>
+        </registry>
+    </capability>
+    <capability>
+        <name>EventlogAutostart</name>
+        <description>Start eventlogd when lwsmd starts.</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\eventlog\Autostart" >
+            <default>
+                <value>true</value>
+            </default>
+        </registry>
+    </capability>
+    <capability>
+        <name>GpagentAutostart</name>
+        <description>Start gpagentd when lwsmd starts.</description>
+        <registry type="boolean"
+            lp-path="HKEY_THIS_MACHINE\Services\gpagent\Autostart" >
+            <default>
+                <value>true</value>
+            </default>
+        </registry>
+    </capability>
+  </section>
+</capabilities>
+
+<!--
+#Additional Likewise settings to be converted to Capabilities
+
+[HKEY_THIS_MACHINE\Services\lsass\Parameters\NTLM]
+"SendNTLMv2"=dword:00000000
+"Support128bit"=dword:00000001
+"Support56bit"=dword:00000001
+"SupportKeyExchange"=dword:00000001
+"SupportNTLM2SessionSecurity"=dword:00000001
+"SupportUnicode"=dword:00000001
+
+-->
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/etc/Makefile.am likewise-open-6.0.0.53010/lwconfig/etc/Makefile.am
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/etc/Makefile.am	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1 @@
+lwconfig_DATA = lwconfig.xml
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/include/keep-me likewise-open-6.0.0.53010/lwconfig/include/keep-me
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/include/keep-me	2011-02-23 17:47:17.000000000 -0800
@@ -0,0 +1 @@
+keep-this-file
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/Makefile.am likewise-open-6.0.0.53010/lwconfig/Makefile.am
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/Makefile.am	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,3 @@
+SUBDIRS = \
+    etc \
+    src
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/src/capability.c likewise-open-6.0.0.53010/lwconfig/src/capability.c
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/src/capability.c	2011-02-23 16:23:58.000000000 -0800
@@ -0,0 +1,1788 @@
+/*
+ * Copyright (c) Likewise Software.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.  You should have received a copy of the GNU General
+ * Public License along with this program.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * LIKEWISE SOFTWARE MAKES THIS SOFTWARE AVAILABLE UNDER OTHER LICENSING
+ * TERMS AS WELL.  IF YOU HAVE ENTERED INTO A SEPARATE LICENSE AGREEMENT
+ * WITH LIKEWISE SOFTWARE, THEN YOU MAY ELECT TO USE THE SOFTWARE UNDER THE
+ * TERMS OF THAT SOFTWARE LICENSE AGREEMENT INSTEAD OF THE TERMS OF THE GNU
+ * GENERAL PUBLIC LICENSE, NOTWITHSTANDING THE ABOVE NOTICE.  IF YOU
+ * HAVE QUESTIONS, OR WISH TO REQUEST A COPY OF THE ALTERNATE LICENSING
+ * TERMS OFFERED BY LIKEWISE SOFTWARE, PLEASE CONTACT LIKEWISE SOFTWARE AT
+ * license@likewise.com
+ */
+
+#include "includes.h"
+
+static
+xmlNodePtr
+FindNext(
+    xmlNodePtr pxChild,
+    PSTR pszChild
+    );
+
+static
+DWORD
+DefaultValue(
+    xmlDocPtr xmlDoc,
+    xmlNodePtr pxDefault,
+    PSTR *ppszValue
+    );
+
+static
+DWORD
+GetLocalPolicyValue(
+    PCAPABILITY pCapability,
+    PSTR *ppszaValue
+    );
+
+static
+DWORD
+RegistryAllocate(
+    xmlDocPtr xmlDoc,
+    xmlNodePtr pxRegistry,
+    PREGISTRY *ppRegistry)
+{
+    DWORD dwError = 0;
+    PREGISTRY pRegistry = NULL;
+    xmlChar *xszLocalPath = NULL;
+    PSTR pszLocalPath = NULL;
+    xmlChar *xszPolicyPath = NULL;
+    PSTR pszPolicyPath = NULL;
+    xmlChar *xszType = NULL;
+    PSTR pszType = NULL;
+    xmlChar *xszDescription = NULL;
+    PSTR pszDescription = NULL;
+    PSTR pszaDefault = NULL;
+    xmlNodePtr child = NULL;
+
+    xszLocalPath = xmlGetProp(pxRegistry, (const xmlChar*)"lp-path");
+    xszPolicyPath = xmlGetProp(pxRegistry, (const xmlChar*)"gp-path");
+    xszType = xmlGetProp(pxRegistry, (const xmlChar*)"type");
+
+    if (!xszLocalPath && !xszPolicyPath)
+    {
+        dwError = APP_ERROR_XML_MISSING_ATTRIBUTE;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (!xszType)
+    {
+        dwError = APP_ERROR_XML_MISSING_ATTRIBUTE;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (xszLocalPath)
+    {
+        dwError = LwAllocateString((PCSTR)xszLocalPath, &pszLocalPath);
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (xszPolicyPath)
+    {
+        dwError = LwAllocateString((PCSTR)xszPolicyPath, &pszPolicyPath);
+        BAIL_ON_ERROR(dwError);
+    }
+
+    dwError = LwAllocateString((PCSTR)xszType, &pszType);
+    BAIL_ON_ERROR(dwError);
+
+    for (child = pxRegistry->xmlChildrenNode; child; child = child->next)
+    {
+        if (child->type != XML_ELEMENT_NODE)
+            continue;
+        if (!xmlStrcmp(child->name, (const xmlChar*)"default"))
+        {
+            dwError = DefaultValue(xmlDoc, child, &pszaDefault);
+            BAIL_ON_ERROR(dwError);
+        }
+        else if (!xmlStrcmp(child->name, (const xmlChar*)"description"))
+        {
+            xszDescription = xmlNodeListGetString(xmlDoc,
+                   child->xmlChildrenNode, TRUE);
+            if (xszDescription)
+            {
+                dwError = LwAllocateString((PCSTR)xszDescription, &pszDescription);
+                BAIL_ON_ERROR(dwError);
+            }
+        }
+    }
+
+    dwError = LwAllocateMemory(sizeof(*pRegistry), (PVOID*)&pRegistry);
+    BAIL_ON_ERROR(dwError);
+
+    pRegistry->pxRegistry = pxRegistry;
+    pRegistry->pszLocalPath = pszLocalPath;
+    pRegistry->pszPolicyPath = pszPolicyPath;
+    pRegistry->pszType = pszType;
+    pRegistry->pszDescription = pszDescription;
+    pRegistry->pszaDefault = pszaDefault;
+
+    *ppRegistry = pRegistry;
+
+cleanup:
+
+    xmlFree(xszLocalPath);
+    xmlFree(xszPolicyPath);
+    xmlFree(xszType);
+    xmlFree(xszDescription);
+    return dwError;
+
+error:
+    LW_SAFE_FREE_STRING(pszLocalPath);
+    LW_SAFE_FREE_STRING(pszPolicyPath);
+    LW_SAFE_FREE_STRING(pszType);
+    LW_SAFE_FREE_STRING(pszDescription);
+    LW_SAFE_FREE_MEMORY(pszaDefault);
+    LW_SAFE_FREE_MEMORY(pRegistry);
+    goto cleanup;
+}
+
+static
+void
+RegistryFree(
+    PREGISTRY pRegistry
+    )
+{
+    if (pRegistry)
+    {
+        LW_SAFE_FREE_STRING(pRegistry->pszLocalPath);
+        LW_SAFE_FREE_STRING(pRegistry->pszPolicyPath);
+        LW_SAFE_FREE_STRING(pRegistry->pszType);
+        LW_SAFE_FREE_STRING(pRegistry->pszDescription);
+        LW_SAFE_FREE_MEMORY(pRegistry->pszaDefault);
+
+        LW_SAFE_FREE_MEMORY(pRegistry);
+    }
+}
+
+
+DWORD
+CapabilityAllocate(
+    xmlDocPtr xmlDoc,
+    xmlNodePtr xmlNodeCapability,
+    PCAPABILITY *ppCapability
+    )
+{
+    DWORD dwError = 0;
+    xmlChar *xszName = NULL;
+    PSTR pszName = NULL;
+    xmlChar *xszDescription = NULL;
+    PSTR pszDescription = NULL;
+    xmlNodePtr child = NULL;
+    PREGISTRY pRegistry = NULL;
+    PCAPABILITY pCapability = NULL;
+
+    if (!xmlNodeCapability)
+    {
+        dwError = ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    for (child = xmlNodeCapability->xmlChildrenNode; child; child = child->next)
+    {
+        if (child->type != XML_ELEMENT_NODE)
+            continue;
+
+        if (!xmlStrcmp(child->name, (const xmlChar*)"name"))
+        {
+            if (xszName)
+            {
+                dwError = APP_ERROR_XML_DUPLICATED_ELEMENT;
+                BAIL_ON_ERROR(dwError);
+            }
+            xszName = xmlNodeListGetString(
+                            xmlDoc,
+                            child->xmlChildrenNode,
+                            TRUE);
+        }
+        else if (!xmlStrcmp(child->name, (const xmlChar*)"description"))
+        {
+            if (xszDescription)
+            {
+                dwError = APP_ERROR_XML_DUPLICATED_ELEMENT;
+                BAIL_ON_ERROR(dwError);
+            }
+            xszDescription = xmlNodeListGetString(
+                                    xmlDoc,
+                                    child->xmlChildrenNode,
+                                    TRUE);
+        }
+        else if (!xmlStrcmp(child->name, (const xmlChar*)"registry"))
+        {
+            if (pRegistry)
+            {
+                dwError = APP_ERROR_XML_DUPLICATED_ELEMENT;
+                BAIL_ON_ERROR(dwError);
+            }
+            dwError = RegistryAllocate(xmlDoc, child, &pRegistry);
+            BAIL_ON_ERROR(dwError);
+        }
+    }
+
+    if (!xszName || xszName[0] == '\0')
+    {
+        fprintf(stderr, "Improper format: Element 'name' not found or empty.\n");
+        dwError = APP_ERROR_XML_MISSING_ELEMENT;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    dwError = LwAllocateString((char*)xszName, &pszName);
+    BAIL_ON_ERROR(dwError);
+
+    if (xszDescription)
+    {
+        dwError = LwAllocateString((char*)xszDescription, &pszDescription);
+        BAIL_ON_ERROR(dwError);
+    }
+
+    dwError = LwAllocateMemory(sizeof(*pCapability), (PVOID*)&pCapability);
+    BAIL_ON_ERROR(dwError);
+
+    pCapability->xmlDoc = xmlDoc;
+
+    pCapability->xmlNodeCapability = xmlNodeCapability;
+
+    pCapability->pszName = pszName;
+    pszName = NULL;
+
+    pCapability->pszDescription = pszDescription;
+    pszDescription = NULL;
+
+    pCapability->pRegistry = pRegistry;
+    pRegistry = NULL;
+
+    *ppCapability = pCapability;
+
+cleanup:
+    xmlFree(xszName);
+    xmlFree(xszDescription);
+    return dwError;
+
+error:
+
+    LW_SAFE_FREE_STRING(pszName);
+    LW_SAFE_FREE_STRING(pszDescription);
+    RegistryFree(pRegistry);
+    CapabilityFree(pCapability);
+    goto cleanup;
+}
+
+void
+CapabilityFree(
+    PCAPABILITY pCapability
+    )
+{
+    if (pCapability)
+    {
+        RegistryFree(pCapability->pRegistry);
+        LW_SAFE_FREE_MEMORY(pCapability->pszName);
+        LW_SAFE_FREE_MEMORY(pCapability->pszDescription);
+        LW_SAFE_FREE_MEMORY(pCapability);
+    }
+}
+
+/*
+   If pszName matches exactly one item, use that.
+   Else if pszName matches more than one item exactly, report an error.
+   Else if pszName is prefix matches exactly one item, use that.
+   Else if pszName prefix matches more than one item, print the matches and
+   report an error.
+*/
+DWORD
+CapabilityFindByName(
+    xmlDocPtr xmlDoc,
+    PCSTR pszName,
+    PCAPABILITY *ppCapability
+    )
+{
+    DWORD dwError = 0;
+
+    xmlXPathContextPtr xpathCtx = NULL;
+    xmlXPathObjectPtr xpathObj = NULL;
+    xmlNodeSetPtr nodes = NULL; // Convienence pointer
+    xmlNodePtr xmlNodeCapability = NULL;
+    PCAPABILITY pCapability = NULL;
+    DWORD dwNameLength = 0;
+    BOOLEAN bNameMatchesMany = FALSE;
+    BOOLEAN bNameMatchesExactly = FALSE;
+    size_t i;
+    xmlNodePtr child = NULL;
+    xmlChar *xszName = NULL;
+
+    dwNameLength = strlen(pszName); // Calculate once
+
+    xpathCtx = xmlXPathNewContext(xmlDoc);
+    if (!xpathCtx)
+    {
+        dwError = ERROR_OUTOFMEMORY;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    xpathObj = xmlXPathEvalExpression(
+                    (const xmlChar*)"/capabilities/section/capability",
+                    xpathCtx);
+    if (!xpathObj)
+    {
+        dwError = APP_ERROR_XPATH_EVAL_FAILED;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    nodes = xpathObj->nodesetval;
+    for (i = 0; i < nodes->nodeNr; i++)
+    {
+        if (nodes->nodeTab[i]->type != XML_ELEMENT_NODE)
+            continue;
+
+        if (xmlStrcmp((const xmlChar*)"capability", nodes->nodeTab[i]->name))
+            continue;
+
+        child = FindNext(nodes->nodeTab[i]->xmlChildrenNode, "name");
+        if (!child)
+            continue;
+
+        xszName = xmlNodeListGetString(xmlDoc, child->xmlChildrenNode, TRUE);
+        if (!xszName)
+        {
+            dwError = ERROR_OUTOFMEMORY;
+            BAIL_ON_ERROR(dwError);
+        }
+
+        if (!xmlStrcasecmp(xszName, (const xmlChar*)pszName))
+        {
+            if (bNameMatchesExactly)
+            {
+                dwError = APP_ERROR_XML_DUPLICATED_ELEMENT;
+                BAIL_ON_ERROR(dwError);
+            }
+
+            xmlNodeCapability = nodes->nodeTab[i];
+            bNameMatchesExactly = TRUE;
+        }
+        else if (!xmlStrncasecmp(xszName, (const xmlChar*) pszName, dwNameLength))
+        {
+            if (!bNameMatchesExactly)
+            {
+                if (xmlNodeCapability)
+                {
+                    bNameMatchesMany = TRUE;
+                }
+                else
+                {
+                    xmlNodeCapability = nodes->nodeTab[i];
+                }
+            }
+        }
+
+        xmlFree(xszName);
+        xszName = NULL;
+    }
+
+    if (!bNameMatchesExactly && bNameMatchesMany)
+    {
+        fprintf(stderr, "%s partially matches:\n", pszName);
+        for (i = 0; i < nodes->nodeNr; i++)
+        {
+            if (nodes->nodeTab[i]->type != XML_ELEMENT_NODE)
+                continue;
+
+            if (xmlStrcmp((const xmlChar*)"capability", nodes->nodeTab[i]->name))
+                continue;
+
+            child = FindNext(nodes->nodeTab[i]->xmlChildrenNode, "name");
+            if (!child)
+                continue;
+
+
+            xszName = xmlNodeListGetString(xmlDoc, child->xmlChildrenNode, TRUE);
+            if (!xszName)
+            {
+                dwError = ERROR_OUTOFMEMORY;
+                BAIL_ON_ERROR(dwError);
+            }
+
+            if (!xmlStrncasecmp(xszName, (const xmlChar*)pszName, dwNameLength))
+            {
+                fprintf(stderr, "%s\n", (PCSTR)xszName);
+            }
+
+            xmlFree(xszName);
+            xszName = NULL;
+        }
+        dwError = APP_ERROR_CAPABILITY_MULTIPLE_MATCHES;
+        BAIL_ON_ERROR(dwError);
+    }
+    else if (!xmlNodeCapability)
+    {
+        dwError = APP_ERROR_CAPABILITY_NOT_FOUND;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    dwError = CapabilityAllocate(xmlDoc, xmlNodeCapability, &pCapability);
+    BAIL_ON_ERROR(dwError);
+
+    *ppCapability = pCapability;
+
+cleanup:
+
+    xmlXPathFreeObject(xpathObj);
+    xmlXPathFreeContext(xpathCtx);
+
+    xmlFree(xszName);
+    xszName = NULL;
+
+    return dwError;
+
+error:
+
+    CapabilityFree(pCapability);
+    goto cleanup;
+}
+
+static
+DWORD
+ValidateString(
+    PCSTR pszValue,
+    xmlDocPtr xmlDoc,
+    xmlNodePtr pxRegistry,
+    PBOOLEAN pbAccept
+    )
+{
+    DWORD dwError = 0;
+    xmlNodePtr xmlAccept = NULL;
+    xmlNodePtr xmlAcceptChild = NULL;
+    const DWORD UNDECIDED = 0;
+    const DWORD ACCEPT_VALUE = 1;
+    const DWORD REJECT_VALUE = 2;
+    DWORD dwDecision = UNDECIDED;
+    const DWORD NOTHING = 0;
+    const DWORD ACCEPT = 1;
+    const DWORD REJECT = 2;
+    DWORD dwState = NOTHING;
+    xmlChar *xszValue = NULL;
+    xmlChar *xszPattern = NULL;
+    regex_t patternExp;
+    regmatch_t matches[5];
+
+
+    for (xmlAccept = pxRegistry->xmlChildrenNode;
+         xmlAccept && dwDecision == UNDECIDED;
+         xmlAccept = xmlAccept->next)
+    {
+        if (xmlAccept->type != XML_ELEMENT_NODE)
+            continue;
+
+        if (!xmlStrcmp(xmlAccept->name, (const xmlChar*)"accept"))
+        {
+            dwState = ACCEPT;
+        }
+        else if (!xmlStrcmp(xmlAccept->name, (const xmlChar*)"reject"))
+        {
+            dwState = REJECT;
+        }
+        else
+        {
+            continue;
+        }
+
+        for (xmlAcceptChild = xmlAccept->xmlChildrenNode;
+             xmlAcceptChild && dwDecision == UNDECIDED;
+             xmlAcceptChild = xmlAcceptChild->next)
+        {
+            if (xmlAcceptChild->type != XML_ELEMENT_NODE)
+                continue;
+
+            if (!xmlStrcmp(xmlAcceptChild->name, (const xmlChar*)"value"))
+            {
+                xszValue = xmlNodeListGetString(
+                                xmlDoc,
+                                xmlAcceptChild->xmlChildrenNode,
+                                TRUE);
+                if (xszValue && !strcmp((PCSTR)xszValue, pszValue))
+                {
+                    if (dwState == ACCEPT)
+                    {
+                        dwDecision = ACCEPT_VALUE;
+                    }
+                    else
+                    {
+                        dwDecision = REJECT_VALUE;
+                    }
+                }
+                if (xszValue)
+                {
+                    xmlFree(xszValue);
+                    xszValue = NULL;
+                }
+
+            } else if (!xmlStrcmp(
+                        xmlAcceptChild->name,
+                        (const xmlChar*)"pattern"))
+            {
+                xszPattern = xmlNodeListGetString(
+                                xmlDoc,
+                                xmlAcceptChild->xmlChildrenNode,
+                                TRUE);
+
+                if (xszPattern)
+                {
+                    if (!regcomp(&patternExp, (PCSTR)xszPattern, REG_EXTENDED))
+                    {
+                        if (!regexec(&patternExp, pszValue,
+                                    sizeof(matches)/sizeof(matches[0]),
+                                    matches,
+                                    0))
+                        {
+                            if (dwState == ACCEPT)
+                            {
+                                dwDecision = ACCEPT_VALUE;
+                            }
+                            else
+                            {
+                                dwDecision = REJECT_VALUE;
+                            }
+                        }
+                        regfree(&patternExp);
+                    }
+                }
+                if (xszPattern)
+                {
+                    xmlFree(xszPattern);
+                    xszPattern = NULL;
+                }
+            }
+        }
+    }
+
+    if (dwDecision == ACCEPT_VALUE)
+    {
+        *pbAccept = TRUE;
+    }
+    else if (dwDecision == REJECT_VALUE)
+    {
+        *pbAccept = FALSE;
+    }
+    else
+    {
+        if (dwState == NOTHING)
+        {
+            *pbAccept = TRUE;
+        }
+        else if (dwState == ACCEPT)
+        {
+            *pbAccept = FALSE;
+        }
+        else if (dwState == REJECT)
+        {
+            *pbAccept = TRUE;
+        }
+    }
+
+    if (xszValue)
+    {
+        xmlFree(xszValue);
+        xszValue = NULL;
+    }
+    if (xszPattern)
+    {
+        xmlFree(xszPattern);
+        xszPattern = NULL;
+    }
+
+    return dwError;
+}
+
+static
+DWORD
+CapabilityRegistryGetUnitMultiplier(
+    PCSTR pszUnit,
+    xmlNodePtr pxRegistry,
+    PBOOLEAN pbMatched,
+    PDWORD pdwMultiplier,
+    PDWORD pdwDivisor
+    )
+{
+    DWORD dwError = 0;
+    xmlChar* xszUnitSuffix = NULL;
+    xmlChar* xszUnitMultiplier = NULL;
+    xmlChar* xszUnitDivisor = NULL;
+    DWORD dwUnitMultiplier = 1;
+    DWORD dwUnitDivisor = 1;
+    xmlNodePtr child = NULL;
+
+    if (pxRegistry)
+        child = pxRegistry->xmlChildrenNode;
+    for (; child; child = child->next)
+    {
+        if (child->type != XML_ELEMENT_NODE)
+            continue;
+
+        if (!xmlStrcmp(child->name, (const xmlChar*)"unit"))
+        {
+            xszUnitSuffix = xmlGetProp(child, (const xmlChar*)"suffix");
+            if (xszUnitSuffix && !strcmp((PCSTR)xszUnitSuffix, pszUnit))
+                break;
+        }
+    }
+
+    if (child)
+        xszUnitMultiplier = xmlGetProp(child, (const xmlChar*)"multiplier");
+    if (xszUnitMultiplier)
+    {
+        dwUnitMultiplier = strtol((PCSTR)xszUnitMultiplier, NULL, 10);
+    }
+
+    if (child)
+        xszUnitDivisor = xmlGetProp(child, (xmlChar*)"divisor");
+    if (xszUnitDivisor)
+    {
+        dwUnitDivisor = strtol((PCSTR)xszUnitDivisor, NULL, 10);
+    }
+
+    *pdwMultiplier = dwUnitMultiplier;
+    *pdwDivisor = dwUnitDivisor;
+    *pbMatched = TRUE;
+
+    xmlFree(xszUnitSuffix);
+    xszUnitSuffix = NULL;
+
+    xmlFree(xszUnitMultiplier);
+    xszUnitMultiplier = NULL;
+
+    xmlFree(xszUnitDivisor);
+    xszUnitDivisor = NULL;
+
+    return dwError;
+}
+
+static
+DWORD
+CapabilityNormalizeDword(
+    PCSTR pszValue,
+    xmlNodePtr pxRegistry,
+    PDWORD pdwValue
+    )
+{
+    DWORD dwError = 0;
+    PSTR pszEndChar = NULL; /* Don't free */
+    BOOLEAN bMatched = FALSE;
+    DWORD dwValue = 0;
+
+    dwValue = strtol(pszValue, &pszEndChar, 10);
+    if (dwValue == 0 && pszValue == pszEndChar)
+    {
+        fprintf(
+            stderr,
+            "Invalid parameter '%s': could not interpret as dword\n",
+            pszValue);
+        dwError = APP_ERROR_INVALID_DWORD;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    // Left over characters indicate a suffix -- look for element 'unit'.
+    if (pszEndChar && *pszEndChar != '\0')
+    {
+        DWORD dwUnitMultiplier = 1;
+        DWORD dwUnitDivisor = 1;
+
+        dwError = CapabilityRegistryGetUnitMultiplier(
+                        pszEndChar,
+                        pxRegistry,
+                        &bMatched,
+                        &dwUnitMultiplier,
+                        &dwUnitDivisor);
+        BAIL_ON_ERROR(dwError);
+
+        if (!bMatched)
+        {
+            fprintf(stderr, "Invalid parameter '%s': could not interpret %s\n",
+                    pszValue, pszEndChar);
+            dwError = APP_ERROR_INVALID_SUFFIX;
+            BAIL_ON_ERROR(dwError);
+        }
+
+
+        dwValue = dwValue * dwUnitMultiplier;
+        dwValue = dwValue / dwUnitDivisor;
+    }
+
+    *pdwValue = dwValue;
+
+cleanup:
+
+    return dwError;
+
+error:
+
+    goto cleanup;
+}
+
+static
+DWORD
+ValidateDword(
+    DWORD dwValue,
+    xmlNodePtr pxRegistry,
+    PBOOLEAN pbAccept
+    )
+{
+    DWORD dwError = 0;
+    xmlNodePtr xmlAccept = NULL;
+    xmlNodePtr xmlRange = NULL;
+    xmlChar *xszMin = NULL;
+    xmlChar *xszMax = NULL;
+    DWORD dwMin = 0;
+    DWORD dwMax = 0;
+    const DWORD UNDECIDED = 0;
+    const DWORD ACCEPT_VALUE = 1;
+    const DWORD REJECT_VALUE = 2;
+    DWORD dwDecision = UNDECIDED;
+    const DWORD NOTHING = 0;
+    const DWORD ACCEPT = 1;
+    const DWORD REJECT = 2;
+    DWORD dwState = NOTHING;
+
+    for (xmlAccept = pxRegistry->xmlChildrenNode;
+         xmlAccept && dwDecision == UNDECIDED;
+         xmlAccept = xmlAccept->next)
+    {
+        if (xmlAccept->type != XML_ELEMENT_NODE)
+            continue;
+
+        if (!xmlStrcmp(xmlAccept->name, (const xmlChar*)"accept"))
+        {
+            dwState = ACCEPT;
+        }
+        else if (!xmlStrcmp(xmlAccept->name, (const xmlChar*)"reject"))
+        {
+            dwState = REJECT;
+        }
+        else
+        {
+            continue;
+        }
+
+        for (xmlRange = xmlAccept->xmlChildrenNode;
+             xmlRange && dwDecision == UNDECIDED;
+             xmlRange = xmlRange->next)
+        {
+            if (xmlRange->type != XML_ELEMENT_NODE)
+                continue;
+
+            if (!xmlStrcmp(xmlRange->name, (const xmlChar*)"range"))
+            {
+                xszMin = xmlGetProp(xmlRange, (const xmlChar*)"min");
+                xszMax = xmlGetProp(xmlRange, (const xmlChar*)"max");
+
+                dwError = CapabilityNormalizeDword(
+                                (PCSTR)xszMin,
+                                pxRegistry,
+                                &dwMin);
+                BAIL_ON_ERROR(dwError);
+
+                dwError = CapabilityNormalizeDword(
+                                (PCSTR)xszMax,
+                                pxRegistry,
+                                &dwMax);
+                BAIL_ON_ERROR(dwError);
+
+                if (dwMin <= dwValue && dwValue <= dwMax)
+                {
+                    if (dwState == ACCEPT)
+                    {
+                        dwDecision = ACCEPT_VALUE;
+                    }
+                    else
+                        dwDecision = REJECT_VALUE;
+                }
+
+                if (xszMin)
+                {
+                    xmlFree(xszMin);
+                    xszMin = NULL;
+                }
+                if (xszMax)
+                {
+                    xmlFree(xszMax);
+                    xszMax = NULL;
+                }
+            }
+        }
+    }
+
+    if (dwDecision == ACCEPT_VALUE)
+    {
+        *pbAccept = TRUE;
+    }
+    else if (dwDecision == REJECT_VALUE)
+    {
+        *pbAccept = FALSE;
+    }
+    else
+    {
+        if (dwState == NOTHING)
+        {
+            *pbAccept = TRUE;
+        }
+        else if (dwState == ACCEPT)
+        {
+            *pbAccept = FALSE;
+        }
+        else if (dwState == REJECT)
+        {
+            *pbAccept = TRUE;
+        }
+    }
+
+cleanup:
+
+    if (xszMin)
+    {
+        xmlFree(xszMin);
+        xszMin = NULL;
+    }
+    if (xszMax)
+    {
+        xmlFree(xszMax);
+        xszMax = NULL;
+    }
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+static
+DWORD
+CapabilityNormalizeBoolean(
+    PCSTR pszValue,
+    PDWORD pdwValue
+    )
+{
+    DWORD dwError = 0;
+    DWORD dwValue = 0;
+
+    if (!strcasecmp("true", pszValue) ||
+        !strcasecmp("1", pszValue))
+    {
+        dwValue = 1;
+    }
+    else if (!strcasecmp("false", pszValue) ||
+             !strcasecmp("0", pszValue))
+    {
+        dwValue = 0;
+    }
+    else
+    {
+        fprintf(stderr, "Invalid parameter: Cannot interpret '%s' as boolean\n",
+                pszValue);
+        dwError = APP_ERROR_INVALID_BOOLEAN;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    *pdwValue = dwValue;
+
+cleanup:
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+DWORD
+DefaultValue(
+    xmlDocPtr xmlDoc,
+    xmlNodePtr pxDefault,
+    PSTR *ppszValue
+    )
+{
+    DWORD dwError = 0;
+    xmlNodePtr child = NULL;
+    xmlChar *xszDefault = NULL;
+    DWORD dwLength = 0;
+    PSTR pszValue = NULL;
+
+    if (pxDefault->type != XML_ELEMENT_NODE)
+    {
+        dwError = ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    dwLength = 0;
+    for (child = pxDefault->xmlChildrenNode; child; child = child->next)
+    {
+        if (child->type != XML_ELEMENT_NODE)
+           continue;
+
+        if (!xmlStrcmp(child->name, (const xmlChar*)"value"))
+        {
+            xszDefault = xmlNodeListGetString(
+                                xmlDoc,
+                                child->xmlChildrenNode,
+                                TRUE);
+
+            if (xszDefault)
+                dwLength += strlen((PSTR)xszDefault);
+            dwLength += 1;
+
+            xmlFree(xszDefault);
+            xszDefault = NULL;
+        }
+    }
+    dwLength += 1;
+
+    dwError = LwAllocateMemory(dwLength, (PVOID*)&pszValue);
+    BAIL_ON_ERROR(dwError);
+
+    dwLength = 0;
+    for (child = pxDefault->xmlChildrenNode; child; child = child->next)
+    {
+        if (child->type != XML_ELEMENT_NODE)
+           continue;
+
+        if (!xmlStrcmp(child->name, (xmlChar*)"value"))
+        {
+            xszDefault = xmlNodeListGetString(
+                                xmlDoc,
+                                child->xmlChildrenNode,
+                                TRUE);
+            if (xszDefault)
+            {
+                strcpy(pszValue + dwLength, (PSTR)xszDefault);
+                dwLength += strlen((PSTR)xszDefault);
+            }
+            pszValue[dwLength] = '\0';
+            dwLength += 1;
+
+            xmlFree(xszDefault);
+            xszDefault = NULL;
+        }
+    }
+
+    *ppszValue = pszValue;
+
+cleanup:
+    xmlFree(xszDefault);
+    xszDefault = NULL;
+
+    return dwError;
+
+error:
+    LW_SAFE_FREE_MEMORY(pszValue);
+    goto cleanup;
+}
+
+DWORD
+CapabilityEditRegistry(
+    PCAPABILITY pCapability,
+    PCSTR pszaArg,
+    BOOLEAN bVerbose
+    )
+{
+    DWORD dwError = 0;
+    DWORD dwValue = 0;
+    PREGISTRY pRegistry = NULL;
+    DWORD dwType = -1;
+    const BYTE *pData = NULL;
+    DWORD dwDataSize = 0;
+    PSTR pszRoot = NULL;
+    PSTR pszKey = NULL;
+    PSTR pszName = NULL;
+    PSTR pszaValue = NULL;
+    PCSTR pszValue = NULL;
+    BOOLEAN bUsingDefault = FALSE;
+    BOOLEAN bAccept = FALSE;
+
+    if (!pCapability)
+    {
+        dwError = ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (!pCapability->pRegistry)
+    {
+       goto cleanup;
+    }
+
+    pRegistry = pCapability->pRegistry;
+
+    if (pszaArg == NULL)
+    {
+        if (!pRegistry->pszaDefault)
+        {
+            fprintf(stderr, "Error: No parameter specified and no default value exist.\n");
+            dwError = APP_ERROR_PARAMETER_REQUIRED;
+            BAIL_ON_ERROR(dwError);
+        }
+        else
+        {
+            pszaArg = pRegistry->pszaDefault;
+            bUsingDefault = TRUE;
+        }
+    }
+
+    if (!strcmp(pRegistry->pszType, "string"))
+    {
+        dwError = ValidateString(pszaArg, pCapability->xmlDoc, pRegistry->pxRegistry, &bAccept);
+        BAIL_ON_ERROR(dwError);
+
+        if (!bAccept)
+        {
+            dwError = APP_ERROR_VALUE_NOT_ACCEPTED;
+            BAIL_ON_ERROR(dwError);
+        }
+        dwType = REG_SZ;
+        pData = (const BYTE*) pszaArg;
+        dwDataSize = strlen(pszaArg) + 1;
+    }
+    else if (!strcmp(pRegistry->pszType, "multistring"))
+    {
+        dwType = REG_MULTI_SZ;
+        pData = (const BYTE*) pszaArg;
+        dwDataSize = UtilMultistringLength(pszaArg);
+    }
+    else if (!strcmp(pRegistry->pszType, "dword"))
+    {
+        dwError = CapabilityNormalizeDword(pszaArg, pRegistry->pxRegistry, &dwValue);
+        BAIL_ON_ERROR(dwError);
+
+        dwError = ValidateDword(dwValue, pRegistry->pxRegistry, &bAccept);
+        BAIL_ON_ERROR(dwError);
+
+        if (!bAccept)
+        {
+            dwError = APP_ERROR_VALUE_NOT_ACCEPTED;
+            BAIL_ON_ERROR(dwError);
+        }
+
+        dwType = REG_DWORD;
+        pData = (const BYTE*) &dwValue;
+        dwDataSize = sizeof(dwValue);
+    }
+    else if (!strcmp(pRegistry->pszType, "boolean"))
+    {
+        dwError = CapabilityNormalizeBoolean(pszaArg, &dwValue);
+        BAIL_ON_ERROR(dwError);
+
+        dwType = REG_DWORD;
+        pData = (const BYTE*) &dwValue;
+        dwDataSize = sizeof(dwValue);
+    }
+    else
+    {
+        fprintf(stderr, "Unknown input type '%s'\n", pRegistry->pszType);
+        dwError = APP_ERROR_UNKNOWN_TYPE;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (bVerbose)
+    {
+        dwError = GetLocalPolicyValue(pCapability, &pszaValue);
+        BAIL_ON_ERROR(dwError);
+
+        fprintf(stdout, "Current local policy value(s): ");
+        if (pszaValue[0] == '\0')
+        {
+            fprintf(stdout, "\n");
+        }
+        else
+        {
+            for (pszValue = pszaValue;
+                 *pszValue;
+                 pszValue = pszValue + strlen(pszValue) + 1)
+            {
+                fprintf(stdout, "%s\n", pszValue);
+            }
+        }
+    }
+
+    if (bVerbose && bUsingDefault)
+    {
+        fprintf(stderr, "Using default value(s): ");
+        if (pszaArg[0] == '\0')
+        {
+            fprintf(stdout, "\n");
+        }
+        else
+        {
+            for (pszValue = pszaArg;
+                 *pszValue;
+                 pszValue = pszValue + strlen(pszValue) + 1)
+            {
+                fprintf(stdout, "%s\n", pszValue);
+            }
+        }
+    }
+
+    dwError = UtilParseRegName(
+                    pRegistry->pszLocalPath,
+                    &pszRoot,
+                    &pszKey,
+                    &pszName);
+    BAIL_ON_ERROR(dwError);
+
+    dwError = UtilSetValueExA(
+                    pszRoot,
+                    pszKey,
+                    pszName,
+                    dwType,
+                    pData,
+                    dwDataSize);
+    BAIL_ON_ERROR(dwError);
+
+cleanup:
+
+    LW_SAFE_FREE_STRING(pszRoot);
+    LW_SAFE_FREE_STRING(pszKey);
+    LW_SAFE_FREE_STRING(pszName);
+    LW_SAFE_FREE_MEMORY(pszaValue);
+
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+DWORD
+CapabilityApply(
+    PCAPABILITY pCapability,
+    BOOLEAN bVerbose
+    )
+{
+    DWORD dwError = 0;
+    PREGISTRY pRegistry = NULL;
+    xmlNodePtr child = NULL;
+    xmlChar *xszCommand = NULL;
+    PSTR pszCommand = NULL;
+    int ret = 0;
+
+    if (!pCapability)
+    {
+        dwError = ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (!pCapability->pRegistry)
+    {
+       goto cleanup;
+    }
+
+    pRegistry = pCapability->pRegistry;
+
+    for (child = pRegistry->pxRegistry->xmlChildrenNode; child; child =
+            child->next)
+    {
+        if (child->type != XML_ELEMENT_NODE)
+            continue;
+
+        if (!xmlStrcmp(child->name, (const xmlChar*) "apply"))
+        {
+            xszCommand = xmlGetProp(child, (const xmlChar*)"command");
+            if (xszCommand)
+            {
+                if (bVerbose)
+                {
+                    dwError = LwAllocateStringPrintf(
+                                    &pszCommand,
+                                    "%s",
+                                    (PCSTR)xszCommand);
+                }
+                else
+                {
+                    dwError = LwAllocateStringPrintf(
+                                    &pszCommand,
+                                    "%s >/dev/null 2>/dev/null",
+                                    (PCSTR)xszCommand);
+                }
+                BAIL_ON_ERROR(dwError);
+
+                if (bVerbose)
+                    fprintf(stdout, "Executing command: %s\n", pszCommand);
+
+                ret = system((PCSTR)pszCommand);
+                if (ret == -1)
+                {
+                    fprintf(stderr, "Problem executing '%s'\n", pszCommand);
+                    dwError = APP_ERROR_COULD_NOT_FORK;
+                }
+                else if (ret > 0)
+                {
+                    fprintf(stderr, "Problem executing '%s'\n", pszCommand);
+                    dwError = APP_ERROR_PROGRAM_ERROR;
+                }
+
+                xmlFree(xszCommand);
+                xszCommand = NULL;
+
+                LW_SAFE_FREE_STRING(pszCommand);
+            }
+        }
+    }
+
+cleanup:
+    LW_SAFE_FREE_STRING(pszCommand);
+    xmlFree(xszCommand);
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+static
+DWORD
+GetLocalPolicyValue(
+    PCAPABILITY pCapability,
+    PSTR *ppszaValue
+    )
+{
+    DWORD dwError = 0;
+    PREGISTRY pRegistry = NULL;
+    DWORD dwType = -1;
+    const BYTE *pData = NULL;
+    DWORD dwDataSize = 0;
+    PSTR pszRoot = NULL;
+    PSTR pszKey = NULL;
+    PSTR pszName = NULL;
+    DWORD dwValue = 0;
+    PSTR pszaArg = NULL;
+    PSTR pszaValue = NULL;
+    PSTR pszBuf = NULL;
+
+    if (!pCapability)
+    {
+        dwError = ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (!pCapability->pRegistry)
+    {
+       goto cleanup;
+    }
+
+    pRegistry = pCapability->pRegistry;
+
+    if (!strcmp(pRegistry->pszType, "string"))
+    {
+        dwType = REG_SZ;
+        pData = (const BYTE*) &pszaArg;
+        dwDataSize = 0;
+    }
+    else if (!strcmp(pRegistry->pszType, "multistring"))
+    {
+        dwType = REG_MULTI_SZ;
+        pData = (const BYTE*) &pszaArg;
+        dwDataSize = 0;
+    }
+    else if (!strcmp(pRegistry->pszType, "dword"))
+    {
+        dwType = REG_DWORD;
+        pData = (const BYTE*) &dwValue;
+        dwDataSize = sizeof(dwValue);
+    }
+    else if (!strcmp(pRegistry->pszType, "boolean"))
+    {
+        dwType = REG_DWORD;
+        pData = (const BYTE*) &dwValue;
+        dwDataSize = sizeof(dwValue);
+    }
+    else
+    {
+        fprintf(stderr, "Unknown input type '%s'\n", pRegistry->pszType);
+        dwError = APP_ERROR_UNKNOWN_TYPE;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    dwError = UtilParseRegName(
+                    pRegistry->pszLocalPath,
+                    &pszRoot,
+                    &pszKey,
+                    &pszName);
+    BAIL_ON_ERROR(dwError);
+
+    dwError = UtilGetValueExA(
+                    pszRoot,
+                    pszKey,
+                    pszName,
+                    dwType,
+                    (PVOID)pData,
+                    &dwDataSize);
+    BAIL_ON_ERROR(dwError);
+
+    if (!strcmp(pRegistry->pszType, "boolean"))
+    {
+        PCSTR pszTrue = "true";
+        PCSTR pszFalse = "false";
+        dwError = UtilAllocateMultistring(
+                        dwValue ? &pszTrue : &pszFalse,
+                        1,
+                        &pszaValue);
+        BAIL_ON_ERROR(dwError);
+    }
+    else if (dwType == REG_DWORD)
+    {
+        dwError = LwAllocateStringPrintf(
+                        &pszBuf,
+                        "%lu",
+                        (unsigned long) dwValue);
+        dwError = UtilAllocateMultistring((PCSTR*)&pszBuf, 1, &pszaValue);
+        BAIL_ON_ERROR(dwError);
+    }
+    else if (dwType == REG_SZ)
+    {
+        dwError = UtilAllocateMultistring((PCSTR*)&pszaArg, 1, &pszaValue);
+        BAIL_ON_ERROR(dwError);
+    }
+    else if (dwType == REG_MULTI_SZ)
+    {
+        dwError = UtilDuplicateMultistring(pszaArg, &pszaValue);
+        BAIL_ON_ERROR(dwError);
+    }
+
+    *ppszaValue = pszaValue;
+
+cleanup:
+
+    LW_SAFE_FREE_STRING(pszRoot);
+    LW_SAFE_FREE_STRING(pszKey);
+    LW_SAFE_FREE_STRING(pszName);
+    LW_SAFE_FREE_STRING(pszaArg);
+    LW_SAFE_FREE_STRING(pszBuf);
+
+    return dwError;
+
+error:
+    LW_SAFE_FREE_MEMORY(pszaValue);
+    goto cleanup;
+
+}
+
+static
+DWORD
+CapabilityGetRegistry(
+    PREGISTRY pRegistry,
+    PSTR *ppszaArg,
+    PDWORD pdwValue,
+    PBOOLEAN pbLocalPolicy
+)
+{
+    DWORD dwError = 0;
+    DWORD dwType = -1;
+    const BYTE *pData = NULL;
+    DWORD dwDataSize = 0;
+    PSTR pszRoot = NULL;
+    PSTR pszKey = NULL;
+    PSTR pszName = NULL;
+    BOOLEAN bTryLocalPolicy = TRUE;
+
+    if (!strcmp(pRegistry->pszType, "string"))
+    {
+        dwType = REG_SZ;
+        pData = (const BYTE*) ppszaArg;
+        dwDataSize = 0;
+    }
+    else if (!strcmp(pRegistry->pszType, "multistring"))
+    {
+        dwType = REG_MULTI_SZ;
+        pData = (const BYTE*) ppszaArg;
+        dwDataSize = 0;
+    }
+    else if (!strcmp(pRegistry->pszType, "dword"))
+    {
+        dwType = REG_DWORD;
+        pData = (const BYTE*) pdwValue;
+        dwDataSize = sizeof(*pdwValue);
+    }
+    else if (!strcmp(pRegistry->pszType, "boolean"))
+    {
+        dwType = REG_DWORD;
+        pData = (const BYTE*) pdwValue;
+        dwDataSize = sizeof(*pdwValue);
+    }
+    else
+    {
+        fprintf(stderr, "Unknown input type '%s'\n", pRegistry->pszType);
+        dwError = APP_ERROR_UNKNOWN_TYPE;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (pRegistry->pszPolicyPath)
+    {
+        dwError = UtilParseRegName(
+                        pRegistry->pszPolicyPath,
+                        &pszRoot,
+                        &pszKey,
+                        &pszName);
+        BAIL_ON_ERROR(dwError);
+
+        dwError = UtilGetValueExA(
+                        pszRoot,
+                        pszKey,
+                        pszName,
+                        dwType,
+                        (PVOID) pData,
+                        &dwDataSize);
+        LW_SAFE_FREE_STRING(pszRoot);
+        LW_SAFE_FREE_STRING(pszKey);
+        LW_SAFE_FREE_STRING(pszName);
+
+        if (!dwError)
+        {
+            bTryLocalPolicy = FALSE;
+        }
+    }
+
+    if (bTryLocalPolicy)
+    {
+        dwError = UtilParseRegName(
+                        pRegistry->pszLocalPath,
+                        &pszRoot,
+                        &pszKey,
+                        &pszName);
+        BAIL_ON_ERROR(dwError);
+
+        dwError = UtilGetValueExA(
+                        pszRoot,
+                        pszKey,
+                        pszName,
+                        dwType,
+                        (PVOID)pData,
+                        &dwDataSize);
+        BAIL_ON_ERROR(dwError);
+
+        *pbLocalPolicy = TRUE;
+    }
+
+error:
+    return dwError;
+}
+
+DWORD
+CapabilityDump(
+    PCAPABILITY pCapability
+    )
+{
+    DWORD dwError = 0;
+    PREGISTRY pRegistry = NULL;
+    DWORD dwValue = 0;
+    PSTR pszaArg = NULL;
+    PSTR pszEsc = NULL;
+    BOOLEAN bLocalPolicy = FALSE;
+
+    if (!pCapability)
+    {
+        dwError = ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (!pCapability->pRegistry)
+    {
+       goto cleanup;
+    }
+
+    pRegistry = pCapability->pRegistry;
+
+    dwError = CapabilityGetRegistry(pRegistry, &pszaArg, &dwValue, &bLocalPolicy);
+    if (dwError == LWREG_ERROR_NO_SUCH_KEY_OR_VALUE)
+    {
+        dwError = 0;
+        goto cleanup;
+    }
+    BAIL_ON_ERROR(dwError);
+
+    fprintf(stdout, "%s", pCapability->pszName);
+    if (!strcmp(pRegistry->pszType, "boolean"))
+    {
+        fprintf(stdout, " %s\n", dwValue ? "true" : "false");
+    }
+    else if (!strcmp(pRegistry->pszType, "dword"))
+    {
+        fprintf(stdout, " %lu\n", (unsigned long)dwValue);
+    }
+    else if (!strcmp(pRegistry->pszType, "string"))
+    {
+        dwError = UtilAllocateEscapedString(pszaArg, &pszEsc);
+        BAIL_ON_ERROR(dwError);
+
+        fprintf(stdout, " \"%s\"\n", pszEsc);
+
+        LW_SAFE_FREE_STRING(pszEsc);
+    }
+    else if (!strcmp(pRegistry->pszType, "multistring"))
+    {
+        PCSTR pszStr = pszaArg;
+        while (*pszStr)
+        {
+            dwError = UtilAllocateEscapedString(pszStr, &pszEsc);
+            BAIL_ON_ERROR(dwError);
+
+            fprintf(stdout, " \"%s\"", pszEsc);
+
+            LW_SAFE_FREE_STRING(pszEsc);
+
+            pszStr += strlen(pszStr) + 1;
+        }
+        fprintf(stdout, "\n");
+    }
+
+cleanup:
+
+    LW_SAFE_FREE_STRING(pszaArg);
+    LW_SAFE_FREE_STRING(pszEsc);
+
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+DWORD
+CapabilityShow(
+    PCAPABILITY pCapability,
+    BOOL bConcise
+    )
+{
+    DWORD dwError = 0;
+    PREGISTRY pRegistry = NULL;
+    DWORD dwValue = 0;
+    PSTR pszaArg = NULL;
+    PSTR pszEsc = NULL;
+    BOOLEAN bRegistryValueFound = FALSE;
+    BOOLEAN bLocalPolicy = FALSE;
+
+    if (!pCapability)
+    {
+        dwError = ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (!pCapability->pRegistry)
+    {
+       goto cleanup;
+    }
+
+    pRegistry = pCapability->pRegistry;
+
+    dwError = CapabilityGetRegistry(pRegistry, &pszaArg, &dwValue, &bLocalPolicy);
+    if (dwError == 0)
+    {
+        bRegistryValueFound = TRUE;
+    }
+    else if (dwError == LWREG_ERROR_NO_SUCH_KEY_OR_VALUE)
+    {
+        dwError = 0;
+        bRegistryValueFound = FALSE;
+    }
+    BAIL_ON_ERROR(dwError);
+
+    if (bConcise)
+    {
+        if (!bRegistryValueFound)
+        {
+            fprintf(stdout, "missing\n%s\n", pRegistry->pszType);
+        }
+        else if (!strcmp(pRegistry->pszType, "boolean"))
+        {
+            fprintf(stdout, "boolean\n%s\n", dwValue ? "true" : "false");
+        }
+        else if (!strcmp(pRegistry->pszType, "dword"))
+        {
+            fprintf(stdout, "dword\n%lu\n", (unsigned long) dwValue);
+        }
+        else if (!strcmp(pRegistry->pszType, "string"))
+        {
+            fprintf(stdout, "string\n%s\n", pszaArg);
+        }
+        else if (!strcmp(pRegistry->pszType, "multistring"))
+        {
+            fprintf(stdout, "multistring\n");
+            PCSTR pszStr = pszaArg;
+            while (*pszStr)
+            {
+                fprintf(stdout, "%s\n", pszStr);
+                pszStr += strlen(pszStr) + 1;
+            }
+            fprintf(stdout, "\n");
+        }
+
+        if (bRegistryValueFound)
+        {
+            if (bLocalPolicy)
+            {
+                fprintf(stdout, "local policy\n");
+            }
+            else
+            {
+                fprintf(stdout, "group policy\n");
+            }
+        }
+        else
+        {
+            fprintf(stdout, "no policy\n");
+        }
+    }
+    else
+    {
+        fprintf(stdout, "Name: %s\n", pCapability->pszName);
+        fprintf(stdout, "Description: %s\n",
+                pCapability->pszDescription ? pCapability->pszDescription : "");
+        if (!bRegistryValueFound)
+        {
+            fprintf(stdout, "Type (Missing From Registry): %s\n",
+                    pCapability->pRegistry->pszType);
+        }
+        else
+        {
+            fprintf(stdout, "Type: %s\n", pCapability->pRegistry->pszType);
+            if (!strcmp(pRegistry->pszType, "boolean"))
+            {
+                fprintf(stdout, "Current Value: %s\n", dwValue ? "true" : "false");
+                fprintf(stdout, "Accepted Values: true, false\n");
+            }
+            else if (!strcmp(pRegistry->pszType, "dword"))
+            {
+                xmlNodePtr xmlAccept = NULL;
+                fprintf(stdout, "Current Value: %lu\n", (unsigned long) dwValue);
+
+                xmlAccept = FindNext(
+                               pRegistry->pxRegistry->xmlChildrenNode,
+                               "accept");
+                if (!xmlAccept)
+                {
+                    fprintf(stdout, "Accepted Range: [0, 4294967295]\n");
+                }
+                while (xmlAccept)
+                {
+                    xmlNodePtr xmlRange = NULL;
+
+                    xmlRange = FindNext(xmlAccept->xmlChildrenNode, "range");
+                    while(xmlRange)
+                    {
+                        xmlChar *xszMin = NULL;
+                        xmlChar *xszMax = NULL;
+
+                        xszMin = xmlGetProp(xmlRange, (const xmlChar*)"min");
+                        xszMax = xmlGetProp(xmlRange, (const xmlChar*)"max");
+                        if (xszMin && xszMax)
+                        {
+                            fprintf(stdout,
+                                    "Accepted Range: [%s, %s]\n",
+                                    xszMin,
+                                    xszMax);
+                        }
+                        if (xszMin)
+                        {
+                            xmlFree(xszMin);
+                            xszMin = NULL;
+                        }
+                        if (xszMax)
+                        {
+                            xmlFree(xszMax);
+                            xszMax = NULL;
+                        }
+                        xmlRange = FindNext(xmlRange->next, "range");
+                    }
+                    xmlAccept = FindNext(xmlAccept->next, "accept");
+                }
+            }
+            else if (!strcmp(pRegistry->pszType, "string"))
+            {
+                xmlNodePtr xmlAccept = NULL;
+
+                dwError = UtilAllocateEscapedString(pszaArg, &pszEsc);
+                BAIL_ON_ERROR(dwError);
+
+                fprintf(stdout, "Current Value: \"%s\"\n", pszEsc);
+
+                LW_SAFE_FREE_STRING(pszEsc);
+
+                xmlAccept = FindNext(
+                               pRegistry->pxRegistry->xmlChildrenNode,
+                               "accept");
+                while (xmlAccept)
+                {
+                    xmlNodePtr xmlValue = NULL;
+
+                    xmlValue = FindNext(xmlAccept->xmlChildrenNode, "value");
+                    while(xmlValue)
+                    {
+                        xmlChar *xszValue = NULL;
+
+                        xszValue = xmlNodeListGetString(
+                                        pCapability->xmlDoc,
+                                        xmlValue->xmlChildrenNode,
+                                        TRUE);
+                        if (xszValue)
+                        {
+                            fprintf(stdout, "Acceptable Value: \"%s\"\n", (PSTR)xszValue);
+                            xmlFree(xszValue);
+                            xszValue = NULL;
+                        }
+                        xmlValue = FindNext(xmlValue->next, "value");
+                    }
+                    xmlAccept = FindNext(xmlAccept->next, "accept");
+                }
+            }
+            else if (!strcmp(pRegistry->pszType, "multistring"))
+            {
+                fprintf(stdout, "Current Values:\n");
+                PCSTR pszStr = pszaArg;
+                while (*pszStr)
+                {
+                    dwError = UtilAllocateEscapedString(pszStr, &pszEsc);
+                    BAIL_ON_ERROR(dwError);
+
+                    fprintf(stdout, "\"%s\"\n", pszEsc);
+
+                    LW_SAFE_FREE_STRING(pszEsc);
+
+                    pszStr += strlen(pszStr) + 1;
+                }
+            }
+
+            if (bLocalPolicy)
+                fprintf(stdout, "Current Value is determined by local policy.\n");
+            else
+                fprintf(stdout, "Value is determined by group policy in Active Directory.\n");
+        }
+    }
+cleanup:
+
+    LW_SAFE_FREE_STRING(pszaArg);
+    LW_SAFE_FREE_STRING(pszEsc);
+
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+static
+xmlNodePtr
+FindNext(
+    xmlNodePtr pxChild,
+    PSTR pszChild)
+{
+    while (pxChild)
+    {
+        if (pxChild->type == XML_ELEMENT_NODE)
+        {
+            if (!xmlStrcmp(pxChild->name, (const xmlChar*)pszChild))
+            {
+                break;
+            }
+        }
+        pxChild = pxChild->next;
+    }
+    return pxChild;
+}
+
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/src/capability.h likewise-open-6.0.0.53010/lwconfig/src/capability.h
--- /dev/null 1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/src/capability.h	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) Likewise Software.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.  You should have received a copy of the GNU General
+ * Public License along with this program.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * LIKEWISE SOFTWARE MAKES THIS SOFTWARE AVAILABLE UNDER OTHER LICENSING
+ * TERMS AS WELL.  IF YOU HAVE ENTERED INTO A SEPARATE LICENSE AGREEMENT
+ * WITH LIKEWISE SOFTWARE, THEN YOU MAY ELECT TO USE THE SOFTWARE UNDER THE
+ * TERMS OF THAT SOFTWARE LICENSE AGREEMENT INSTEAD OF THE TERMS OF THE GNU
+ * GENERAL PUBLIC LICENSE, NOTWITHSTANDING THE ABOVE NOTICE.  IF YOU
+ * HAVE QUESTIONS, OR WISH TO REQUEST A COPY OF THE ALTERNATE LICENSING
+ * TERMS OFFERED BY LIKEWISE SOFTWARE, PLEASE CONTACT LIKEWISE SOFTWARE AT
+ * license@likewise.com
+ */
+#ifndef LWCONFIG_CAPABILITY_H
+#define LWCONFIG_CAPABILITY_H
+
+DWORD
+CapabilityAllocate(
+    xmlDocPtr xmlDoc,
+    xmlNodePtr xmlNode,
+    PCAPABILITY *ppCapability
+    );
+
+void
+CapabilityFree(
+    PCAPABILITY pCapability
+    );
+
+DWORD
+CapabilityFindByName(
+    xmlDocPtr doc,
+    PCSTR name,
+    PCAPABILITY *ppCapability
+    );
+
+DWORD
+CapabilityEditRegistry(
+    PCAPABILITY pCapability,
+    PCSTR pszaArg,
+    BOOLEAN pVerbose
+    );
+
+DWORD
+CapabilityApply(
+    PCAPABILITY pCapability,
+    BOOLEAN bVerbose
+    );
+
+DWORD
+CapabilityDump(
+    PCAPABILITY pCapability
+    );
+
+DWORD
+CapabilityShow(
+    PCAPABILITY pCapability,
+    BOOL bConcise
+    );
+
+#endif
+
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/src/defs.h likewise-open-6.0.0.53010/lwconfig/src/defs.h
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/src/defs.h	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) Likewise Software.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.  You should have received a copy of the GNU General
+ * Public License along with this program.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * LIKEWISE SOFTWARE MAKES THIS SOFTWARE AVAILABLE UNDER OTHER LICENSING
+ * TERMS AS WELL.  IF YOU HAVE ENTERED INTO A SEPARATE LICENSE AGREEMENT
+ * WITH LIKEWISE SOFTWARE, THEN YOU MAY ELECT TO USE THE SOFTWARE UNDER THE
+ * TERMS OF THAT SOFTWARE LICENSE AGREEMENT INSTEAD OF THE TERMS OF THE GNU
+ * GENERAL PUBLIC LICENSE, NOTWITHSTANDING THE ABOVE NOTICE.  IF YOU
+ * HAVE QUESTIONS, OR WISH TO REQUEST A COPY OF THE ALTERNATE LICENSING
+ * TERMS OFFERED BY LIKEWISE SOFTWARE, PLEASE CONTACT LIKEWISE SOFTWARE AT
+ * license@likewise.com
+ */
+#ifndef DEFS_H
+#define DEFS_H
+
+#define BAIL_ON_ERROR(x) if (x) goto error
+
+#define APP_ERROR_BAD_XML                  0x20000000
+#define APP_ERROR_XML_DUPLICATED_ELEMENT   0x20000001
+#define APP_ERROR_XML_MISSING_ELEMENT      0x20000002
+#define APP_ERROR_XPATH_EVAL_FAILED        0x20000003
+#define APP_ERROR_CAPABILITY_NOT_FOUND     0x20000004
+#define APP_ERROR_INVALID_DWORD            0x20000005
+#define APP_ERROR_INVALID_BOOLEAN          0x20000006
+#define APP_ERROR_UNKNOWN_TYPE             0x20000007
+#define APP_ERROR_INVALID_SUFFIX           0x20000008
+#define APP_ERROR_PARAMETER_REQUIRED       0x20000009
+#define APP_ERROR_UNEXPECTED_VALUE         0x2000000a
+#define APP_ERROR_COULD_NOT_FORK           0x2000000b
+#define APP_ERROR_INVALID_ESCAPE_SEQUENCE  0x2000000c
+#define APP_ERROR_UNTERMINATED_QUOTE       0x2000000d
+#define APP_ERROR_BAD_REGISTRY_PATH        0x2000000e
+#define APP_ERROR_VALUE_NOT_ACCEPTED       0x2000000f
+#define APP_ERROR_PROGRAM_ERROR            0x20000010
+#define APP_ERROR_CAPABILITY_MULTIPLE_MATCHES 0x20000011
+#define APP_ERROR_XML_MISSING_ATTRIBUTE       0x20000012
+#endif
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/src/includes.h likewise-open-6.0.0.53010/lwconfig/src/includes.h
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/src/includes.h	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) Likewise Software.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.  You should have received a copy of the GNU General
+ * Public License along with this program.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * LIKEWISE SOFTWARE MAKES THIS SOFTWARE AVAILABLE UNDER OTHER LICENSING
+ * TERMS AS WELL.  IF YOU HAVE ENTERED INTO A SEPARATE LICENSE AGREEMENT
+ * WITH LIKEWISE SOFTWARE, THEN YOU MAY ELECT TO USE THE SOFTWARE UNDER THE
+ * TERMS OF THAT SOFTWARE LICENSE AGREEMENT INSTEAD OF THE TERMS OF THE GNU
+ * GENERAL PUBLIC LICENSE, NOTWITHSTANDING THE ABOVE NOTICE.  IF YOU
+ * HAVE QUESTIONS, OR WISH TO REQUEST A COPY OF THE ALTERNATE LICENSING
+ * TERMS OFFERED BY LIKEWISE SOFTWARE, PLEASE CONTACT LIKEWISE SOFTWARE AT
+ * license@likewise.com
+ */
+#include "config.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <assert.h>
+#include <unistd.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <regex.h>
+#include <locale.h>
+
+#include <libxml/tree.h>
+#include <libxml/parser.h>
+#include <libxml/xpath.h>
+#include <libxml/xpathInternals.h>
+
+#include <reg/lwreg.h>
+#include <reg/regutil.h>
+
+#include <lwstr.h>
+#include <lwmem.h>
+#include <lwerror.h>
+
+#include "defs.h"
+#include "structs.h"
+#include "util.h"
+#include "capability.h"
+
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/src/main.c likewise-open-6.0.0.53010/lwconfig/src/main.c
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/src/main.c	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,545 @@
+/*
+ * Copyright (c) Likewise Software.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.  You should have received a copy of the GNU General
+ * Public License along with this program.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * LIKEWISE SOFTWARE MAKES THIS SOFTWARE AVAILABLE UNDER OTHER LICENSING
+ * TERMS AS WELL.  IF YOU HAVE ENTERED INTO A SEPARATE LICENSE AGREEMENT
+ * WITH LIKEWISE SOFTWARE, THEN YOU MAY ELECT TO USE THE SOFTWARE UNDER THE
+ * TERMS OF THAT SOFTWARE LICENSE AGREEMENT INSTEAD OF THE TERMS OF THE GNU
+ * GENERAL PUBLIC LICENSE, NOTWITHSTANDING THE ABOVE NOTICE.  IF YOU
+ * HAVE QUESTIONS, OR WISH TO REQUEST A COPY OF THE ALTERNATE LICENSING
+ * TERMS OFFERED BY LIKEWISE SOFTWARE, PLEASE CONTACT LIKEWISE SOFTWARE AT
+ * license@likewise.com
+ */
+
+#include "includes.h"
+
+DWORD
+SetOperation(
+    xmlDocPtr doc,
+    PCSTR pszName,
+    PCSTR pszaArg,
+    BOOLEAN bVerbose
+    );
+
+DWORD
+ShowOperation(
+    xmlDocPtr doc,
+    PCSTR pszName,
+    BOOLEAN bConcise
+    );
+
+static
+void
+PrintUsage()
+{
+    fputs(
+"Usage: lwconfig [OPTIONS] [COMMAND]\n"
+"Modify or view the configuration.\n"
+"\n"
+" Options:\n"
+"    --verbose               Display additional information.\n"
+"\n"
+" Commands:\n"
+"  SETTING [VALUE]           Change SETTING to the given VALUE(s) or the\n"
+"                              default value if no value is specified.\n"
+"  --list                    Display names of all settings.\n"
+"  --show SETTING            Display current value(s) of SETTING.\n"
+"  --detail SETTING          Display current value(s) and details of SETTING.\n"
+"  --file FILE               Read FILE with each line beginning with a\n"
+"                              setting name followed by value(s). Use '.'\n"
+"                              for reading from stdin.\n"
+"  --dump                    Dump all settings in a format suitable for use\n"
+"                              with --file.\n"
+    ,stderr);
+}
+
+DWORD
+ListCapabilities(
+    xmlDocPtr doc
+    )
+{
+    DWORD dwError = 0;
+    xmlXPathContextPtr xpathCtx = NULL;
+    xmlXPathObjectPtr xpathObj = NULL;
+    xmlNodeSetPtr nodes = NULL;
+    size_t i;
+
+    xpathCtx = xmlXPathNewContext(doc);
+    if (!xpathCtx)
+    {
+        dwError = ERROR_OUTOFMEMORY;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    xpathObj = xmlXPathEvalExpression(
+                    (const xmlChar*)"/capabilities/section",
+                    xpathCtx);
+    if (!xpathObj)
+    {
+        dwError = APP_ERROR_XPATH_EVAL_FAILED;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    nodes = xpathObj->nodesetval;
+    for (i = 0; i < nodes->nodeNr; i++)
+    {
+        if (nodes->nodeTab[i]->type == XML_ELEMENT_NODE)
+        {
+            xmlNodePtr cur = nodes->nodeTab[i];
+            xmlNodePtr child = NULL;
+            xmlChar *section = NULL;
+
+            section = xmlGetProp(cur, (const xmlChar*) "section");
+            if (section)
+                fprintf(stdout, "[%s]\n", section);
+            else
+                fprintf(stdout, "\n");
+            xmlFree(section);
+            section = NULL;
+
+            for (child = cur->xmlChildrenNode; child; child = child->next)
+            {
+                PCAPABILITY cap = NULL;
+                if (child->type != XML_ELEMENT_NODE)
+                    continue;
+                if (xmlStrcmp(child->name, (const xmlChar*)"capability"))
+                    continue;
+
+                dwError = CapabilityAllocate(doc, child, &cap);
+                BAIL_ON_ERROR(dwError);
+
+                if (cap->pszName)
+                    fprintf(stdout, "\t%s\n", cap->pszName);
+
+                CapabilityFree(cap);
+                cap = NULL;
+            }
+        }
+    }
+
+cleanup:
+    xmlXPathFreeObject(xpathObj);
+    xmlXPathFreeContext(xpathCtx);
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+DWORD
+SetOperation(
+    xmlDocPtr doc,
+    PCSTR pszName,
+    PCSTR pszaArg,
+    BOOLEAN bVerbose
+    )
+{
+    DWORD dwError = 0;
+    PCAPABILITY pCapability = NULL;
+
+    dwError = CapabilityFindByName(doc, pszName, &pCapability);
+    BAIL_ON_ERROR(dwError);
+
+    dwError = CapabilityEditRegistry(pCapability, pszaArg, bVerbose);
+    BAIL_ON_ERROR(dwError);
+
+    dwError = CapabilityApply(pCapability, bVerbose);
+    BAIL_ON_ERROR(dwError);
+
+cleanup:
+    CapabilityFree(pCapability);
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+DWORD
+ShowOperation(
+    xmlDocPtr doc,
+    PCSTR pszName,
+    BOOLEAN bConcise
+    )
+{
+    DWORD dwError = 0;
+    PCAPABILITY pCapability = NULL;
+
+    dwError = CapabilityFindByName(doc, pszName, &pCapability);
+    BAIL_ON_ERROR(dwError);
+
+    dwError = CapabilityShow(pCapability, bConcise);
+    BAIL_ON_ERROR(dwError);
+
+cleanup:
+    CapabilityFree(pCapability);
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+DWORD
+DumpOperation(
+    xmlDocPtr doc,
+    BOOLEAN bPolicyOnly
+    )
+{
+    DWORD dwError = 0;
+    PCAPABILITY pCapability = NULL;
+    xmlXPathContextPtr xpathCtx = NULL;
+    xmlXPathObjectPtr xpathObj = NULL;
+    xmlNodeSetPtr nodes = NULL;
+    size_t i;
+
+    xpathCtx = xmlXPathNewContext(doc);
+    if (!xpathCtx)
+    {
+        dwError = ERROR_OUTOFMEMORY;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    xpathObj = xmlXPathEvalExpression(
+                    (const xmlChar*)"/capabilities/section/capability",
+                    xpathCtx);
+    if (!xpathObj)
+    {
+        dwError = APP_ERROR_XPATH_EVAL_FAILED;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    nodes = xpathObj->nodesetval;
+    for (i = 0; i < nodes->nodeNr; i++)
+    {
+        if (nodes->nodeTab[i]->type != XML_ELEMENT_NODE)
+            continue;
+
+        if (xmlStrcmp(nodes->nodeTab[i]->name, (const xmlChar*)"capability"))
+                continue;
+
+        dwError = CapabilityAllocate(doc, nodes->nodeTab[i], &pCapability);
+        BAIL_ON_ERROR(dwError);
+
+        dwError = CapabilityDump(pCapability);
+        BAIL_ON_ERROR(dwError);
+
+        CapabilityFree(pCapability);
+        pCapability = NULL;
+    }
+
+cleanup:
+    CapabilityFree(pCapability);
+    pCapability = NULL;
+    xmlXPathFreeObject(xpathObj);
+    xmlXPathFreeContext(xpathCtx);
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+int main(int argc, const char *argv[])
+{
+    DWORD dwError = 0;
+    BOOLEAN bListCapabilities = FALSE;
+    BOOLEAN bFile = FALSE;
+    PCSTR pszFile = NULL;
+    BOOLEAN bShowCapability = FALSE;
+    BOOLEAN bDumpCapability = FALSE;
+    BOOLEAN bDetailCapability = FALSE;
+    BOOLEAN bVerbose = FALSE;
+    PCSTR pszCapability = NULL;
+    FILE *fpFile = NULL;
+    PSTR pszLine = NULL;
+    PSTR *ppszArgs = NULL;
+    DWORD dwArgs = 0;
+    PSTR pszaArg = NULL;
+    xmlDocPtr doc = NULL;
+    int dwArgc = 1;
+    int returnErrorCode = 1;
+    size_t i;
+
+    setlocale(LC_ALL, "");
+
+    xmlInitParser();
+
+    doc = xmlParseFile(LWCONFIG_XML);
+    if (!doc)
+    {
+        dwError = APP_ERROR_BAD_XML;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (argc == 1)
+    {
+        PrintUsage();
+        goto cleanup;
+    }
+
+    for (dwArgc = 1; dwArgc < argc; dwArgc++)
+    {
+        if (!strcmp(argv[dwArgc], "--help"))
+        {
+            PrintUsage();
+            goto cleanup;
+        }
+        else if (!strcmp(argv[dwArgc], "--file"))
+        {
+            if (argc == dwArgc+1)
+            {
+                PrintUsage();
+                goto cleanup;
+            }
+
+            bFile = TRUE;
+            pszFile = argv[++dwArgc];
+        }
+        else if (!strcmp(argv[dwArgc], "--list"))
+        {
+            bListCapabilities = TRUE;
+        }
+        else if (!strcmp(argv[dwArgc], "--dump"))
+        {
+            bDumpCapability = TRUE;
+        }
+        else if (!strcmp(argv[dwArgc], "--show"))
+        {
+            if (argc == dwArgc+1)
+            {
+                PrintUsage();
+                goto cleanup;
+            }
+
+            bShowCapability = TRUE;
+            pszCapability = argv[++dwArgc];
+        }
+        else if (!strcmp(argv[dwArgc], "--detail") ||
+                 !strcmp(argv[dwArgc], "--details"))
+        {
+            if (argc == dwArgc+1)
+            {
+                PrintUsage();
+                goto cleanup;
+            }
+            bDetailCapability = TRUE;
+            pszCapability = argv[++dwArgc];
+        }
+        else if (!strcmp(argv[dwArgc], "--verbose"))
+        {
+            bVerbose = TRUE;
+        }
+        else if (!strncmp(argv[dwArgc], "--", 2))
+        {
+            PrintUsage();
+            goto cleanup;
+        }
+        else
+            break;
+    }
+
+    if (bListCapabilities)
+    {
+        dwError = ListCapabilities(doc);
+        BAIL_ON_ERROR(dwError);
+    }
+    else if (bDumpCapability)
+    {
+        dwError = DumpOperation(doc, TRUE);
+        BAIL_ON_ERROR(dwError);
+    }
+    else if (bFile)
+    {
+        if (!strcmp(pszFile, "."))
+            fpFile = stdin;
+        else if ((fpFile = fopen(pszFile, "r")) == NULL)
+        {
+            dwError = LwMapErrnoToLwError(errno);
+            BAIL_ON_ERROR(dwError);
+        }
+
+        while ((dwError = UtilReadLine(fpFile, &pszLine)) == 0)
+        {
+            dwError = UtilParseLine(pszLine, &ppszArgs, &dwArgs);
+            BAIL_ON_ERROR(dwError);
+
+            if (dwArgs > 0)
+            {
+                dwError = UtilAllocateMultistring((PCSTR*)ppszArgs + 1, dwArgs -
+                        1, &pszaArg);
+                BAIL_ON_ERROR(dwError);
+
+                dwError = SetOperation(doc, ppszArgs[0], pszaArg, bVerbose);
+                BAIL_ON_ERROR(dwError);
+
+                for (i = 0; i < dwArgs; i++)
+                    LW_SAFE_FREE_MEMORY(ppszArgs[i]);
+                dwArgs = 0;
+                LW_SAFE_FREE_MEMORY(ppszArgs);
+                LW_SAFE_FREE_MEMORY(pszaArg);
+             }
+
+            LW_SAFE_FREE_STRING(pszLine);
+        }
+        if (dwError == ERROR_HANDLE_EOF)
+        {
+            dwError = 0;
+        }
+        BAIL_ON_ERROR(dwError);
+    }
+    else if (bShowCapability || bDetailCapability)
+    {
+        dwError = ShowOperation(doc, pszCapability, bShowCapability);
+        BAIL_ON_ERROR(dwError);
+    }
+    else
+    {
+        if (argc - dwArgc > 0)
+        {
+            if (argc - dwArgc > 1)
+            {
+                dwError = UtilAllocateMultistring((PCSTR*)argv + dwArgc + 1,
+                        argc - dwArgc - 1, &pszaArg);
+                BAIL_ON_ERROR(dwError);
+            }
+
+            dwError = SetOperation(doc, argv[dwArgc], pszaArg, bVerbose);
+            BAIL_ON_ERROR(dwError);
+        }
+        else
+        {
+            PrintUsage();
+            goto cleanup;
+        }
+    }
+
+cleanup:
+
+    LW_SAFE_FREE_MEMORY(pszaArg);
+
+    for (i = 0; i < dwArgs; i++)
+        LW_SAFE_FREE_MEMORY(ppszArgs[i]);
+    dwArgs = 0;
+    LW_SAFE_FREE_MEMORY(ppszArgs);
+
+    if (fpFile && fpFile != stdin)
+    {
+        fclose(fpFile);
+        fpFile = NULL;
+    }
+    xmlFreeDoc(doc);
+    doc = NULL;
+
+    xmlCleanupParser();
+    if (dwError)
+    {
+        size_t size = 0;
+        char buf[1024];
+
+        buf[0] = '\0';
+
+        if (_LW_ERROR_REG_BASE <= dwError && dwError <= _LW_ERROR_REG_MAX)
+        {
+            size = LwRegGetErrorString(dwError, buf, sizeof(buf));
+            if (size > sizeof(buf))
+                buf[0] = '\0';
+        }
+        else if (dwError >= 0x20000000)
+        {
+            switch(dwError)
+            {
+                case APP_ERROR_XML_DUPLICATED_ELEMENT:
+                    strcpy(buf, "Duplicated XML element");
+                    break;
+                case APP_ERROR_XML_MISSING_ELEMENT:
+                    strcpy(buf, "Missing XML element");
+                    break;
+                case APP_ERROR_XPATH_EVAL_FAILED:
+                    strcpy(buf, "Could not evaluate XPath expression");
+                    break;
+                case APP_ERROR_CAPABILITY_NOT_FOUND:
+                    strcpy(buf, "Capability not found");
+                    returnErrorCode = 2;
+                    break;
+                case APP_ERROR_INVALID_DWORD:
+                    strcpy(buf, "Could not interpret value as dword");
+                    returnErrorCode = 3;
+                    break;
+                case APP_ERROR_INVALID_BOOLEAN:
+                    strcpy(buf, "Could not interpret value as boolean");
+                    returnErrorCode = 3;
+                    break;
+                case APP_ERROR_INVALID_SUFFIX:
+                    strcpy(buf, "Suffix on DWORD does not match known units");
+                    returnErrorCode = 3;
+                    break;
+                case APP_ERROR_PARAMETER_REQUIRED:
+                    strcpy(buf, "Argument required -- no default is present");
+                    returnErrorCode = 4;
+                    break;
+                case APP_ERROR_UNEXPECTED_VALUE:
+                    strcpy(buf, "Bad value in /var/lib/likewise/lwconfig.xml");
+                    break;
+                case APP_ERROR_COULD_NOT_FORK:
+                    strcpy(buf, "Could not fork");
+                    break;
+                case APP_ERROR_BAD_XML:
+                    strcpy(buf, "Malformed XML in /var/lib/likewise/lwconfig.xml");
+                    break;
+                case APP_ERROR_INVALID_ESCAPE_SEQUENCE:
+                    strcpy(buf, "Bad escape sequence");
+                    returnErrorCode = 3;
+                    break;
+                case APP_ERROR_UNTERMINATED_QUOTE:
+                    strcpy(buf, "Unterminated quote");
+                    returnErrorCode = 3;
+                    break;
+                case APP_ERROR_VALUE_NOT_ACCEPTED:
+                    strcpy(buf, "Value not in accepted range");
+                    returnErrorCode = 3;
+                    break;
+                case APP_ERROR_PROGRAM_ERROR:
+                    strcpy(buf, "Error returned by external program");
+                    returnErrorCode = 5;
+                    break;
+                case APP_ERROR_CAPABILITY_MULTIPLE_MATCHES:
+                    strcpy(buf, "Multiple capabilties matched; aborting.");
+                    returnErrorCode = 6;
+                    break;
+                case APP_ERROR_XML_MISSING_ATTRIBUTE:
+                    strcpy(buf, "Missing XML attribute");
+                    break;
+            }
+        }
+        if (buf[0] == '\0')
+        {
+            size = LwGetErrorString(dwError, buf, sizeof(buf));
+            if (size > sizeof(buf))
+                buf[0] = '\0';
+        }
+
+        if (buf[0])
+        {
+            fprintf(stderr, "Error: %s\n", buf);
+        }
+        else
+        {
+            fprintf(stderr, "Error: %lu\n", (unsigned long) dwError);
+        }
+        return returnErrorCode;
+    }
+    return 0;
+
+error:
+    goto cleanup;
+}
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/src/Makefile.am likewise-open-6.0.0.53010/lwconfig/src/Makefile.am
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/src/Makefile.am	2011-02-23 18:41:56.000000000 -0800
@@ -0,0 +1,19 @@
+bin_PROGRAMS = lwconfig
+
+lwconfig_SOURCES = \
+    capability.c \
+    main.c \
+    util.c
+
+lwconfig_CPPFLAGS = \
+    $(AM_CPPFLAGS) \
+    -I$(top_srcdir)/include \
+    $(XML2_INCLUDES) \
+    $(LWBASE_INCLUDES)
+
+lwconfig_LDADD = \
+    $(XML2_LIBS) \
+    $(LWBASE_LIBS) \
+    $(LWADVAPI_LIBS) \
+    $(LWREG_LIBS) \
+    -lregclient -lregcommon -llwadvapi_nothr
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/src/structs.h likewise-open-6.0.0.53010/lwconfig/src/structs.h
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/src/structs.h	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) Likewise Software.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or (at
+ * your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * for more details.  You should have received a copy of the GNU General
+ * Public License along with this program.  If not, see
+ * <http://www.gnu.org/licenses/>.
+ *
+ * LIKEWISE SOFTWARE MAKES THIS SOFTWARE AVAILABLE UNDER OTHER LICENSING
+ * TERMS AS WELL.  IF YOU HAVE ENTERED INTO A SEPARATE LICENSE AGREEMENT
+ * WITH LIKEWISE SOFTWARE, THEN YOU MAY ELECT TO USE THE SOFTWARE UNDER THE
+ * TERMS OF THAT SOFTWARE LICENSE AGREEMENT INSTEAD OF THE TERMS OF THE GNU
+ * GENERAL PUBLIC LICENSE, NOTWITHSTANDING THE ABOVE NOTICE.  IF YOU
+ * HAVE QUESTIONS, OR WISH TO REQUEST A COPY OF THE ALTERNATE LICENSING
+ * TERMS OFFERED BY LIKEWISE SOFTWARE, PLEASE CONTACT LIKEWISE SOFTWARE AT
+ * license@likewise.com
+ */
+
+#ifndef LWCONFIG_STRUCTS_H
+#define LWCONFIG_STRUCTS_H
+
+typedef struct _REGISTRY
+{
+    xmlNodePtr pxRegistry;
+    PSTR pszLocalPath;
+    PSTR pszPolicyPath;
+    PSTR pszType;
+    PSTR pszDescription;
+    PSTR pszaDefault;
+} REGISTRY, *PREGISTRY;
+
+typedef struct _CAPABILITY
+{
+    xmlDocPtr xmlDoc;
+    xmlNodePtr xmlNodeCapability;
+    PSTR pszName;
+    PSTR pszDescription;
+    PREGISTRY pRegistry;
+} CAPABILITY, *PCAPABILITY;
+
+#endif
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/src/util.c likewise-open-6.0.0.53010/lwconfig/src/util.c
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/src/util.c	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,660 @@
+/*
+* Copyright (c) Likewise Software.  All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or (at
+* your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+* or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+* for more details.  You should have received a copy of the GNU General
+* Public License along with this program.  If not, see
+* <http://www.gnu.org/licenses/>.
+*
+* LIKEWISE SOFTWARE MAKES THIS SOFTWARE AVAILABLE UNDER OTHER LICENSING
+* TERMS AS WELL.  IF YOU HAVE ENTERED INTO A SEPARATE LICENSE AGREEMENT
+* WITH LIKEWISE SOFTWARE, THEN YOU MAY ELECT TO USE THE SOFTWARE UNDER THE
+* TERMS OF THAT SOFTWARE LICENSE AGREEMENT INSTEAD OF THE TERMS OF THE GNU
+* GENERAL PUBLIC LICENSE, NOTWITHSTANDING THE ABOVE NOTICE.  IF YOU
+* HAVE QUESTIONS, OR WISH TO REQUEST A COPY OF THE ALTERNATE LICENSING
+* TERMS OFFERED BY LIKEWISE SOFTWARE, PLEASE CONTACT LIKEWISE SOFTWARE AT
+* license@likewise.com
+*/
+
+#include "includes.h"
+
+DWORD
+UtilAllocateMultistring(
+    PCSTR *ppszValues,
+    DWORD dwValues,
+    PSTR *ppszValue
+    )
+{
+    DWORD dwError = 0;
+    DWORD dwLength = 0;
+    PSTR pszValue = NULL;
+    size_t i;
+
+    if (dwValues)
+    {
+        for (i = 0; i < dwValues; i++)
+        {
+            dwLength += strlen(ppszValues[i]) + 1;
+        }
+        dwLength++;
+
+
+        dwError = LwAllocateMemory(dwLength, (PVOID*)&pszValue);
+        BAIL_ON_ERROR(dwError);
+
+        dwLength = 0;
+        for (i = 0; i < dwValues; i++)
+        {
+            strcpy(pszValue + dwLength, ppszValues[i]);
+            dwLength += strlen(ppszValues[i]) + 1;
+        }
+        pszValue[dwLength++] = '\0';
+    }
+
+    *ppszValue = pszValue;
+
+cleanup:
+    return dwError;
+
+error:
+    LW_SAFE_FREE_MEMORY(pszValue);
+    goto cleanup;
+}
+
+DWORD
+UtilMultistringLength(
+    PCSTR pszValue
+    )
+{
+    PCSTR pszEnd = NULL;
+
+    pszEnd = pszValue;
+    while (*pszEnd)
+    {
+        pszEnd = pszEnd + strlen(pszEnd) + 1;
+    }
+
+    return (pszEnd - pszValue) + 1;
+}
+
+DWORD
+UtilDuplicateMultistring(
+    PCSTR pszValue,
+    PSTR *ppszValue
+    )
+{
+    DWORD dwError = 0;
+    DWORD dwLength = 0;
+    PSTR pszOut = NULL;
+
+    dwLength = UtilMultistringLength(pszValue);
+
+    dwError = LwAllocateMemory(dwLength, (PVOID*)&pszOut);
+    BAIL_ON_ERROR(dwError);
+
+    memcpy(pszOut, pszValue, dwLength);
+
+    *ppszValue = pszOut;
+
+cleanup:
+    return dwError;
+
+error:
+    LW_SAFE_FREE_MEMORY(pszOut);
+    goto cleanup;
+}
+
+DWORD
+UtilParseRegName(
+    PCSTR pszPath,
+    PSTR *ppszRoot,
+    PSTR *ppszKey,
+    PSTR *ppszName
+    )
+{
+    DWORD dwError = 0;
+    PSTR pszRoot = NULL;
+    PSTR pszKey = NULL;
+    PSTR pszName = NULL;
+    PCSTR pszFirst = NULL;
+    PCSTR pszLast = NULL;
+    PCSTR pszEnd = NULL;
+
+    if (!pszPath)
+    {
+        dwError = APP_ERROR_BAD_REGISTRY_PATH;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    // Skip past a leading /
+    if (pszPath[0] == '\\')
+        pszPath++;
+
+    // Find the end of the string (before the terminator).
+    pszEnd = pszPath + strlen(pszPath) - 1;
+
+    pszFirst = strchr(pszPath, '\\');
+    if (!pszFirst)
+    {
+        dwError = APP_ERROR_BAD_REGISTRY_PATH;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    pszLast = strrchr(pszPath, '\\');
+
+    dwError = LwAllocateMemory(pszFirst - pszPath + 1, (PVOID*) &pszRoot);
+    BAIL_ON_ERROR(dwError);
+
+    memcpy(pszRoot, pszPath, pszFirst - pszPath);
+    pszRoot[pszFirst - pszPath] = '\0';
+
+    if (pszFirst != pszLast)
+    {
+        dwError = LwAllocateMemory(pszLast - pszFirst + 1, (PVOID*) &pszKey);
+        BAIL_ON_ERROR(dwError);
+
+        memcpy(pszKey, pszFirst + 1, (pszLast - pszFirst) - 1);
+        pszKey[pszLast - pszFirst] = '\0';
+    }
+
+    dwError = LwAllocateMemory(pszEnd - pszLast + 1, (PVOID*) &pszName);
+    BAIL_ON_ERROR(dwError);
+
+    memcpy(pszName, pszLast + 1, pszEnd - pszLast);
+    pszName[pszEnd - pszLast] = '\0';
+
+    *ppszRoot = pszRoot;
+    *ppszKey = pszKey;
+    *ppszName = pszName;
+
+cleanup:
+    return dwError;
+
+error:
+    LW_SAFE_FREE_STRING(pszRoot);
+    LW_SAFE_FREE_STRING(pszKey);
+    LW_SAFE_FREE_STRING(pszName);
+    goto cleanup;
+}
+
+DWORD
+UtilSetValueExA(
+    PCSTR pszRoot,
+    PCSTR pszKey,
+    PCSTR pszValueName,
+    DWORD dwType,
+    const BYTE *pData,
+    DWORD cbData
+    )
+{
+    DWORD dwError = 0;
+    HANDLE hReg = NULL;
+    HKEY hRootKey = NULL;
+    HKEY hKeyKey = NULL;
+
+    dwError = LwRegOpenServer(&hReg);
+    BAIL_ON_ERROR(dwError);
+
+    if (!strcmp(pszRoot, "HKEY_THIS_MACHINE"))
+    {
+        dwError = LwRegOpenKeyExA(hReg, NULL, HKEY_THIS_MACHINE, 0, KEY_WRITE, &hRootKey);
+        BAIL_ON_ERROR(dwError);
+    }
+    else
+    {
+        dwError = LW_ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (pszKey && pszKey[0])
+    {
+        dwError = LwRegOpenKeyExA(hReg, hRootKey, pszKey, 0, KEY_WRITE,
+                &hKeyKey);
+        BAIL_ON_ERROR(dwError);
+    }
+    else
+    {
+        hKeyKey = hRootKey;
+        hRootKey = NULL;
+    }
+
+    dwError =  LwRegSetValueExA(hReg, hKeyKey, pszValueName, 0, dwType, pData, cbData);
+    BAIL_ON_ERROR(dwError);
+
+cleanup:
+    if (hKeyKey)
+    {
+        LwRegCloseKey(hReg, hKeyKey);
+        hKeyKey = NULL;
+    }
+
+    if (hRootKey)
+    {
+        LwRegCloseKey(hReg, hRootKey);
+        hRootKey = NULL;
+    }
+
+    if (hReg)
+    {
+        LwRegCloseServer(hReg);
+        hReg = NULL;
+    }
+
+    return dwError;
+
+error:
+    goto cleanup;
+}
+
+DWORD
+UtilGetValueExA(
+    PCSTR pszRoot,
+    PCSTR pszKey,
+    PCSTR pszValueName,
+    DWORD dwType,
+    PVOID *ppvData,
+    PDWORD pcbData
+    )
+{
+    DWORD dwError = 0;
+    DWORD dwActualType = 0;
+    PSTR pszValue = NULL;
+    char szValue[MAX_VALUE_LENGTH];
+    DWORD cbData = sizeof(szValue);
+    HANDLE hReg = NULL;
+    HKEY hRootKey = NULL;
+    HKEY hKeyKey = NULL;
+
+    dwError = LwRegOpenServer(&hReg);
+    BAIL_ON_ERROR(dwError);
+
+    if (!strcmp(pszRoot, "HKEY_THIS_MACHINE"))
+    {
+        dwError = LwRegOpenKeyExA(hReg, NULL, HKEY_THIS_MACHINE, 0, KEY_READ, &hRootKey);
+        BAIL_ON_ERROR(dwError);
+    }
+    else
+    {
+        dwError = LW_ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (pszKey && pszKey[0])
+    {
+        dwError = LwRegOpenKeyExA(hReg, hRootKey, pszKey, 0, KEY_READ,
+                &hKeyKey);
+        BAIL_ON_ERROR(dwError);
+    }
+    else
+    {
+        hKeyKey = hRootKey;
+        hRootKey = NULL;
+    }
+
+    dwError =  LwRegQueryValueExA(hReg, hKeyKey, pszValueName, 0, &dwActualType,
+            (PBYTE)szValue, &cbData);
+    BAIL_ON_ERROR(dwError);
+
+    if (dwActualType != dwType)
+    {
+        dwError = ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+    if (dwType == REG_DWORD && cbData == sizeof(REG_DWORD))
+    {
+        memcpy(ppvData, szValue, sizeof(REG_DWORD));
+        *pcbData = sizeof(REG_DWORD);
+    }
+    else if (dwType == REG_SZ)
+    {
+       dwError = LwAllocateString(szValue, &pszValue);
+       BAIL_ON_ERROR(dwError);
+
+       *ppvData = pszValue;
+       *pcbData = cbData;
+    }
+    else if (dwType == REG_MULTI_SZ)
+    {
+        dwError = LwAllocateMemory(cbData, (PVOID*)&pszValue);
+        BAIL_ON_ERROR(dwError);
+
+        memcpy(pszValue, szValue, cbData);
+
+        *ppvData = pszValue;
+        *pcbData = cbData;
+    }
+    else
+    {
+        dwError = ERROR_INVALID_PARAMETER;
+        BAIL_ON_ERROR(dwError);
+    }
+
+
+cleanup:
+    if (hKeyKey)
+    {
+        LwRegCloseKey(hReg, hKeyKey);
+        hKeyKey = NULL;
+    }
+
+    if (hRootKey)
+    {
+        LwRegCloseKey(hReg, hRootKey);
+        hRootKey = NULL;
+    }
+
+    if (hReg)
+    {
+        LwRegCloseServer(hReg);
+        hReg = NULL;
+    }
+
+    return dwError;
+
+error:
+    LW_SAFE_FREE_MEMORY(pszValue);
+    goto cleanup;
+}
+
+static
+DWORD
+AppendCharacter(int c, PSTR *ppszLine, PDWORD pdwMaxSize)
+{
+    DWORD dwError = 0;
+    PSTR pszLine = NULL;
+    DWORD dwMaxSize = 0;
+    size_t i = 0;
+
+    if (*ppszLine)
+        for (i = 0; (*ppszLine)[i]; i++)
+            ;
+
+    if (!*ppszLine || i + 1 == *pdwMaxSize)
+    {
+        dwMaxSize = *pdwMaxSize + 16; // Not doing exponential growth
+        dwError = LwAllocateMemory(sizeof(char) * dwMaxSize, (PVOID*)&pszLine);
+        BAIL_ON_ERROR(dwError);
+
+        memcpy(pszLine, *ppszLine, *pdwMaxSize);
+
+        LW_SAFE_FREE_STRING(*ppszLine);
+        *ppszLine = pszLine;
+        pszLine = NULL;
+        *pdwMaxSize = dwMaxSize;
+    }
+    (*ppszLine)[i] = c;
+    (*ppszLine)[i+1] = '\0';
+
+cleanup:
+    return dwError;
+
+error:
+    LW_SAFE_FREE_STRING(pszLine);
+    goto cleanup;
+}
+
+static
+DWORD
+AppendArgument(PSTR pszLine, PSTR **pppszArgs, PDWORD pdwArgs)
+{
+    DWORD dwError = 0;
+    PSTR pszNewLine = NULL;
+    PSTR *ppszArgs = NULL;
+    DWORD dwArgs = 0;
+
+    dwError = LwAllocateString(pszLine, &pszNewLine);
+    BAIL_ON_ERROR(dwError);
+
+    dwArgs = *pdwArgs + 1;
+    dwError = LwAllocateMemory(sizeof(PSTR) * dwArgs, (PVOID*)&ppszArgs);
+    BAIL_ON_ERROR(dwError);
+
+    memcpy(ppszArgs, *pppszArgs, *pdwArgs * sizeof(*ppszArgs));
+    ppszArgs[*pdwArgs] = pszNewLine;
+    pszNewLine = NULL;
+
+    LW_SAFE_FREE_MEMORY(*pppszArgs);
+    *pppszArgs = ppszArgs;
+    ppszArgs = NULL;
+
+    *pdwArgs = dwArgs;
+
+cleanup:
+    return dwError;
+
+error:
+    LW_SAFE_FREE_STRING(pszNewLine);
+    goto cleanup;
+}
+
+DWORD
+UtilParseLine(
+    PCSTR pszLine,
+    PSTR **pppszArgs,
+    PDWORD pdwArgs
+    )
+{
+    DWORD dwError = 0;
+    PSTR pszArg = NULL;
+    DWORD dwArgMaxSize = 0;
+    PSTR *ppszArgs = NULL;
+    DWORD dwArgs = 0;
+    BOOLEAN bArgument = FALSE;
+    BOOLEAN bQuoted = FALSE;
+    BOOLEAN bEscaped = FALSE;
+    size_t i = 0;
+
+    dwArgMaxSize = 64;
+    dwError = LwAllocateMemory(sizeof(char) * dwArgMaxSize, (PVOID*)&pszArg);
+    BAIL_ON_ERROR(dwError);
+
+    for (i = 0; pszLine[i] && pszLine[i] != '\n' && pszLine[i] != '\r'; i++)
+    {
+        int c = pszLine[i];
+
+        if (!bArgument)
+        {
+            if (c == ' ' || c == '\t')
+                continue;
+        }
+        bArgument = TRUE;
+
+        if (bEscaped)
+        {
+            dwError = AppendCharacter(c, &pszArg, &dwArgMaxSize);
+            BAIL_ON_ERROR(dwError);
+            bEscaped = FALSE;
+        }
+        else if (c == '\\')
+        {
+            bEscaped = TRUE;
+        }
+        else if (bQuoted)
+        {
+            if (c == '"')
+            {
+                bQuoted = FALSE;
+                bArgument = FALSE;
+
+                // Terminate argument
+                dwError = AppendArgument(pszArg, &ppszArgs, &dwArgs);
+                BAIL_ON_ERROR(dwError);
+                pszArg[0] = '\0';
+            }
+            else
+            {
+                dwError = AppendCharacter(c, &pszArg, &dwArgMaxSize);
+                BAIL_ON_ERROR(dwError);
+            }
+        }
+        else if (c == '"')
+        {
+            bQuoted = TRUE;
+
+            // Terminate previous argument if there was one.
+            if (pszArg && pszArg[0])
+            {
+                dwError = AppendArgument(pszArg, &ppszArgs, &dwArgs);
+                BAIL_ON_ERROR(dwError);
+                pszArg[0] = '\0';
+            }
+        }
+        else if (c == ' ' || c == '\t')
+        {
+            bArgument = FALSE;
+
+            // Terminate previous argument
+            dwError = AppendArgument(pszArg, &ppszArgs, &dwArgs);
+            BAIL_ON_ERROR(dwError);
+            pszArg[0] = '\0';
+        }
+        else
+        {
+            dwError = AppendCharacter(c, &pszArg, &dwArgMaxSize);
+            BAIL_ON_ERROR(dwError);
+        }
+    }
+
+    if (bEscaped)
+    {
+        dwError = APP_ERROR_INVALID_ESCAPE_SEQUENCE;
+        BAIL_ON_ERROR(dwError);
+    }
+    if (bQuoted)
+    {
+        dwError = APP_ERROR_UNTERMINATED_QUOTE;
+        BAIL_ON_ERROR(dwError);
+    }
+    if (pszArg[0])
+    {
+        dwError = AppendArgument(pszArg, &ppszArgs, &dwArgs);
+        BAIL_ON_ERROR(dwError);
+    }
+
+    *pppszArgs = ppszArgs;
+    *pdwArgs = dwArgs;
+
+cleanup:
+    LW_SAFE_FREE_STRING(pszArg);
+    return dwError;
+
+error:
+
+    LW_SAFE_FREE_STRING(pszArg);
+    for (i = 0; i < dwArgs; i++)
+    {
+        LW_SAFE_FREE_STRING(ppszArgs[i]);
+    }
+    LW_SAFE_FREE_MEMORY(ppszArgs);
+    goto cleanup;
+}
+
+DWORD
+UtilReadLine(
+    FILE* pStream,
+    PSTR* ppszLine
+    )
+{
+    DWORD dwError = 0;
+    ssize_t sSize = 0, sCapacity = 0;
+    PSTR pszBuffer = NULL;
+    // Do not free
+    PSTR pszNewBuffer = NULL;
+
+    do
+    {
+        // There is not enough space. Allocate a larger buffer
+        sCapacity = sSize*2 + 10;
+        dwError = LwReallocMemory(
+                            pszBuffer,
+                            OUT_PPVOID(&pszNewBuffer),
+                            sCapacity + 1);
+        BAIL_ON_ERROR(dwError);
+        pszBuffer = pszNewBuffer;
+
+        // Read as much as the stream will give us up to the space in the
+        // buffer.
+        errno = 0;
+        if (fgets(pszBuffer + sSize, sCapacity - sSize, pStream) == NULL)
+        {
+            dwError = LwMapErrnoToLwError(errno);
+            if (dwError == 0)
+            {
+                dwError = ERROR_HANDLE_EOF;
+            }
+            BAIL_ON_ERROR(dwError);
+        }
+
+        sSize += strlen(pszBuffer + sSize);
+    }
+    // While the whole buffer is used and it does not end in a newline
+    while(sSize == sCapacity - 1 && pszBuffer[sSize-1] != '\n');
+
+    if (sSize == 0)
+    {
+        dwError = ERROR_HANDLE_EOF;
+        BAIL_ON_ERROR(dwError);
+    }
+    if (pszBuffer[sSize-1] == '\n')
+        pszBuffer[sSize-1] = '\0';
+
+    *ppszLine = pszBuffer;
+
+cleanup:
+    return dwError;
+
+error:
+    LW_SAFE_FREE_STRING(pszBuffer);
+    goto cleanup;
+}
+
+DWORD
+UtilAllocateEscapedString(
+    PCSTR pszStr,
+    PSTR *ppszEscapedStr
+    )
+{
+    DWORD dwError = 0;
+    const PCSTR pszEscapeChars = "\\\"";
+    DWORD i, j;
+    PSTR pszEscapedStr = NULL;
+    DWORD dwCount = 0;
+
+    for (i = 0; pszStr[i]; i++)
+    {
+        if (strchr(pszEscapeChars, pszStr[i]) != NULL)
+            dwCount++;
+        dwCount++;
+    }
+    dwCount++;
+
+    dwError = LwAllocateMemory(dwCount, (PVOID)&pszEscapedStr);
+    BAIL_ON_ERROR(dwError);
+
+    for (i = 0, j = 0; pszStr[i]; i++)
+    {
+        if (strchr(pszEscapeChars, pszStr[i]) != NULL)
+        {
+            pszEscapedStr[j++] = '\\';
+        }
+        pszEscapedStr[j++] = pszStr[i];
+    }
+    pszEscapedStr[j] = '\0';
+
+    *ppszEscapedStr = pszEscapedStr;
+
+cleanup:
+    return dwError;
+
+error:
+    LW_SAFE_FREE_MEMORY(pszEscapedStr);
+    goto cleanup;
+}
diff -Nurb likewise-open-6.0.0.53010.old/lwconfig/src/util.h likewise-open-6.0.0.53010/lwconfig/src/util.h
--- /dev/null	1969-12-31 16:00:00.000000000 -0800
+++ likewise-open-6.0.0.53010/lwconfig/src/util.h	2011-01-17 11:51:56.000000000 -0800
@@ -0,0 +1,95 @@
+/*
+* Copyright (c) Likewise Software.  All rights reserved.
+*
+* This program is free software; you can redistribute it and/or modify
+* it under the terms of the GNU General Public License as published by
+* the Free Software Foundation; either version 2 of the License, or (at
+* your option) any later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+* or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+* for more details.  You should have received a copy of the GNU General
+* Public License along with this program.  If not, see
+* <http://www.gnu.org/licenses/>.
+*
+* LIKEWISE SOFTWARE MAKES THIS SOFTWARE AVAILABLE UNDER OTHER LICENSING
+* TERMS AS WELL.  IF YOU HAVE ENTERED INTO A SEPARATE LICENSE AGREEMENT
+* WITH LIKEWISE SOFTWARE, THEN YOU MAY ELECT TO USE THE SOFTWARE UNDER THE
+* TERMS OF THAT SOFTWARE LICENSE AGREEMENT INSTEAD OF THE TERMS OF THE GNU
+* GENERAL PUBLIC LICENSE, NOTWITHSTANDING THE ABOVE NOTICE.  IF YOU
+* HAVE QUESTIONS, OR WISH TO REQUEST A COPY OF THE ALTERNATE LICENSING
+* TERMS OFFERED BY LIKEWISE SOFTWARE, PLEASE CONTACT LIKEWISE SOFTWARE AT
+* license@likewise.com
+*/
+#ifndef LWCONFIG_UTIL_H
+#define LWCONFIG_UTIL_H
+
+#include "includes.h"
+
+DWORD
+UtilAllocateMultistring(
+    PCSTR *ppszValues,
+    DWORD dwValues,
+    PSTR *ppszValue
+    );
+
+DWORD
+UtilMultistringLength(
+    PCSTR pszValue
+    );
+
+DWORD
+UtilDuplicateMultistring(
+    PCSTR pszValue,
+    PSTR *ppszValue
+    );
+
+DWORD
+UtilParseRegName(
+    PCSTR pszPath,
+    PSTR *ppszRoot,
+    PSTR *ppszKey,
+    PSTR *ppszValueName
+    );
+
+DWORD
+UtilSetValueExA(
+    PCSTR pszRoot,
+    PCSTR pszKey,
+    PCSTR pszValueName,
+    DWORD dwType,
+    const BYTE *pData,
+    DWORD cbData
+    );
+
+DWORD
+UtilGetValueExA(
+    PCSTR pszRoot,
+    PCSTR pszKey,
+    PCSTR pszValueName,
+    DWORD dwType,
+    PVOID *ppvData,
+    PDWORD pcbData
+    );
+
+DWORD
+UtilParseLine(
+    PCSTR pszLine,
+    PSTR **pppszArgs,
+    PDWORD pdwArgs
+    );
+
+DWORD
+UtilReadLine(
+    FILE* pStream,
+    PSTR* ppszLine
+    );
+
+DWORD
+UtilAllocateEscapedString(
+    PCSTR pszStr,
+    PSTR *ppszEscapedStr
+    );
+
+#endif
